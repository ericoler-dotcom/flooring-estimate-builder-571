<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Create Bid Items - Mobile v571</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&display=swap');
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    :root {
      --purple-900: #4c1d95; --purple-600: #7c3aed; --purple-100: #ede9fe; --purple-50: #f5f3ff;
      --blue-600: #2563eb; --blue-50: #eff6ff; --blue-100: #dbeafe;
      --green-600: #16a34a; --green-500: #22c55e; --green-100: #dcfce7; --green-50: #f0fdf4; --green-300: #86efac; --green-400: #4ade80;
      --amber-500: #f59e0b; --amber-400: #fbbf24; --amber-100: #fef3c7; --amber-50: #fffbeb;
      --gray-900: #111827; --gray-700: #374151; --gray-600: #4b5563; --gray-500: #6b7280;
      --gray-400: #9ca3af; --gray-300: #d1d5db; --gray-200: #e5e7eb; --gray-100: #f3f4f6; --gray-50: #f9fafb;
      --radius-sm: 8px; --radius-md: 12px; --radius-lg: 16px; --radius-full: 9999px;
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --carpet-600: #dc2626; --carpet-500: #ef4444; --carpet-400: #f87171;
      --carpet-300: #fca5a5; --carpet-200: #fecaca; --carpet-100: #fee2e2; --carpet-50: #fef2f2;
    }
    html, body { margin: 0; padding: 0; font-family: 'DM Sans', -apple-system, sans-serif; background: var(--gray-100); color: var(--gray-900); font-size: 16px; line-height: 1.5; }
    .app { display: flex; flex-direction: column; min-height: 100vh; }
    .header { background: linear-gradient(135deg, var(--purple-900), #5b21b6); color: white; padding: 12px 16px; position: sticky; top: 0; z-index: 100; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
    .header-top { display: flex; align-items: center; gap: 12px; }
    .header-logo { background: white; border-radius: var(--radius-sm); padding: 4px 8px; flex-shrink: 0; }
    .header-logo img { height: 24px; display: block; }
    .header-info { flex: 1; min-width: 0; }
    .header-title { font-size: 16px; font-weight: 700; line-height: 1.2; }
    .header-subtitle { font-size: 12px; opacity: 0.9; }
    .header-close { width: 36px; height: 36px; border-radius: var(--radius-full); background: rgba(255,255,255,0.15); border: none; color: white; font-size: 20px; cursor: pointer; flex-shrink: 0; display: flex; align-items: center; justify-content: center; }
    .progress-bar { display: flex; align-items: center; justify-content: center; gap: 6px; padding: 14px 16px; background: white; border-bottom: 1px solid var(--gray-200); }
    .progress-step { display: flex; align-items: center; gap: 6px; }
    .progress-dot { width: 32px; height: 32px; border-radius: var(--radius-full); background: var(--gray-200); color: var(--gray-500); font-size: 14px; font-weight: 600; display: flex; align-items: center; justify-content: center; transition: all 0.3s; }
    .progress-dot.active { background: var(--purple-600); color: white; transform: scale(1.1); }
    .progress-dot.completed { background: var(--green-500); color: white; }
    .progress-label { font-size: 11px; color: var(--gray-500); font-weight: 500; }
    @media (max-width: 380px) { .progress-label { display: none; } }
    .progress-label.active { color: var(--purple-600); font-weight: 600; }
    .progress-line { width: 24px; height: 3px; background: var(--gray-200); border-radius: 2px; }
    .progress-line.completed { background: var(--green-500); }
    .main { flex: 1; padding: 16px; padding-bottom: calc(120px + var(--safe-bottom)); overflow-y: auto; -webkit-overflow-scrolling: touch; }
    .step-container { display: none; animation: fadeIn 0.3s ease; }
    .step-container.active { display: block; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    .section-title { font-size: 20px; font-weight: 700; margin-bottom: 6px; }
    .section-hint { font-size: 14px; color: var(--gray-500); margin-bottom: 20px; }
    .card { background: white; border-radius: var(--radius-lg); padding: 16px; margin-bottom: 16px; box-shadow: 0 1px 3px rgba(0,0,0,0.08); border: 1px solid var(--gray-200); }
    .card-title { font-size: 14px; font-weight: 600; color: var(--gray-700); margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
    .search-container { position: relative; margin-bottom: 12px; }
    .search-input { width: 100%; padding: 16px 50px 16px 50px; font-size: 16px; border: 2px solid var(--gray-200); border-radius: var(--radius-md); background: var(--gray-50); font-family: inherit; }
    .search-input:focus { outline: none; border-color: var(--purple-600); background: white; box-shadow: 0 0 0 4px var(--purple-100); }
    .search-input.filtered { border-color: var(--green-500); background: #f0fdf4; }
    .search-icon { position: absolute; left: 16px; top: 50%; transform: translateY(-50%); color: var(--gray-400); font-size: 20px; }
    .filter-btn { position: absolute; right: 12px; top: 50%; transform: translateY(-50%); width: 36px; height: 36px; border-radius: var(--radius-full); border: 2px solid var(--gray-200); background: white; color: var(--gray-500); font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
    .filter-btn.active { background: var(--green-100); border-color: var(--green-500); color: var(--green-600); }
    .resource-filter-display { display: none; margin-top: 8px; padding: 10px 14px; background: var(--green-100); border: 1px solid var(--green-500); border-radius: var(--radius-md); font-size: 13px; color: var(--green-600); }
    .resource-filter-display.show { display: flex; align-items: center; justify-content: space-between; }
    .resource-filter-display .clear-filter { background: none; border: none; color: var(--gray-500); font-size: 18px; cursor: pointer; padding: 0 4px; }
    .search-results { position: absolute; top: calc(100% + 4px); left: 0; right: 0; background: white; border: 1px solid var(--gray-200); border-radius: var(--radius-md); box-shadow: 0 10px 25px rgba(0,0,0,0.15); max-height: 300px; overflow-y: auto; z-index: 50; display: none; }
    .search-results.show { display: block; }
    .search-result-item { padding: 16px; border-bottom: 1px solid var(--gray-100); cursor: pointer; }
    .search-result-item:active { background: var(--purple-50); }
    .search-result-item.carpet-item { border-left: 4px solid var(--carpet-500); }
    .search-result-main { font-weight: 500; margin-bottom: 4px; }
    .search-result-meta { font-size: 13px; color: var(--gray-500); display: flex; gap: 16px; flex-wrap: wrap; }
    .search-result-carpet-badge { display: inline-flex; align-items: center; gap: 4px; background: var(--carpet-100); color: var(--carpet-600); padding: 2px 8px; border-radius: var(--radius-full); font-size: 11px; font-weight: 600; }
    .selected-item { background: var(--green-100); border: 2px solid var(--green-500); border-radius: var(--radius-md); padding: 16px; display: none; }
    .selected-item.show { display: block; }
    .selected-item-header { display: flex; justify-content: space-between; margin-bottom: 8px; }
    .selected-item-label { font-size: 12px; font-weight: 600; color: var(--green-600); text-transform: uppercase; }
    .selected-item-clear { background: none; border: none; color: var(--gray-500); font-size: 24px; cursor: pointer; line-height: 1; }
    .selected-item-name { font-weight: 600; font-size: 16px; margin-bottom: 8px; }
    .selected-item-details { font-size: 13px; color: var(--gray-600); display: flex; flex-wrap: wrap; gap: 8px 16px; }
    .selected-item-badge { padding: 4px 10px; background: white; border-radius: var(--radius-full); font-size: 12px; font-weight: 500; color: var(--amber-500); border: 1px solid var(--amber-500); }
    .carpet-info-card { display: none; background: linear-gradient(135deg, var(--carpet-50), #fff1f2); border: 2px solid var(--carpet-500); border-radius: var(--radius-md); padding: 14px 16px; margin-top: 12px; }
    .carpet-info-card.show { display: block; }
    .carpet-info-title { font-size: 13px; font-weight: 700; color: var(--carpet-600); margin-bottom: 10px; display: flex; align-items: center; gap: 6px; }
    .carpet-info-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
    .carpet-info-item { text-align: center; background: white; padding: 8px; border-radius: var(--radius-sm); }
    .carpet-info-input { width: 100%; font-size: 18px; font-weight: 700; color: var(--carpet-600); text-align: center; border: 2px solid transparent; border-radius: var(--radius-sm); background: transparent; padding: 4px; font-family: inherit; }
    .carpet-info-input:focus { outline: none; border-color: var(--carpet-500); background: white; }
    .carpet-info-input::-webkit-inner-spin-button, .carpet-info-input::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
    .carpet-info-input { -moz-appearance: textfield; }
    .carpet-info-label { font-size: 11px; color: var(--gray-500); }
    .area-group { margin-bottom: 20px; }
    .area-group-label { font-size: 13px; font-weight: 600; color: #92400e; margin-bottom: 12px; cursor: pointer; display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; background: var(--amber-100); border: 1px solid var(--amber-400); border-radius: var(--radius-md); user-select: none; -webkit-user-select: none; transition: all 0.2s; }
    .area-group-label:active { background: var(--amber-50); }
    .area-group-label::after { content: '\25BE'; font-size: 16px; color: #b45309; transition: transform 0.2s; }
    .area-group.collapsed .area-group-label { background: var(--blue-50); border-color: var(--blue-100); color: var(--gray-600); }
    .area-group.collapsed .area-group-label::after { content: '\25B8'; color: var(--gray-400); }
    .area-group.collapsed .area-pills { display: none; }
    .area-group.collapsed .closet-picker { display: none; }
    .area-pills { display: flex; flex-wrap: wrap; gap: 10px; }
    .area-pill-wrapper { display: inline-flex; align-items: center; gap: 0; background: white; border-radius: var(--radius-full); border: 2px solid var(--gray-200); overflow: hidden; transition: all 0.2s; }
    .area-pill-wrapper.has-measurement { border-color: var(--green-500); background: var(--green-100); }
    .area-pill-wrapper.selected { border-color: var(--purple-600); background: var(--purple-50); }
    .area-pill { padding: 12px 16px; font-size: 15px; font-weight: 500; color: var(--gray-700); cursor: pointer; background: transparent; border: none; font-family: inherit; }
    .area-pill-wrapper.has-measurement .area-pill { color: var(--green-600); }
    .area-pill-wrapper.selected .area-pill { color: var(--purple-600); }
    .area-pill-measure { width: 44px; height: 44px; border: none; background: var(--gray-100); color: var(--gray-500); font-size: 20px; cursor: pointer; display: flex; align-items: center; justify-content: center; border-left: 1px solid var(--gray-200); transition: all 0.2s; }
    .area-pill-measure:hover { background: var(--blue-50); color: var(--blue-600); }
    .area-pill-wrapper.has-measurement .area-pill-measure { background: var(--green-500); color: white; border-left-color: var(--green-400); }
    .area-pill-wrapper.needs-measurement .area-pill-measure { background: #ec4899; color: white; border-left-color: #f472b6; animation: pulse-pink 1.5s ease-in-out infinite; }
    @keyframes pulse-pink { 0%, 100% { background: #ec4899; } 50% { background: #f472b6; } }
    .unmeasured-warning { display: flex; align-items: center; gap: 8px; padding: 12px 16px; background: #fce7f3; border: 2px solid #f472b6; border-radius: var(--radius-md); margin-bottom: 16px; color: #be185d; font-size: 14px; font-weight: 500; }
    .unmeasured-warning-icon { font-size: 18px; }
    .custom-area-row { display: flex; gap: 10px; margin-top: 20px; }
    .custom-area-input { flex: 1; padding: 14px 16px; font-size: 16px; border: 2px solid var(--gray-200); border-radius: var(--radius-md); font-family: inherit; }
    .custom-area-input:focus { outline: none; border-color: var(--purple-600); }
    .custom-area-btn { padding: 14px 24px; background: var(--purple-600); color: white; border: none; border-radius: var(--radius-md); font-size: 15px; font-weight: 600; cursor: pointer; }
    .product-reminder-card { background: linear-gradient(135deg, #faf5ff, #f3e8ff); border: 2px solid var(--purple-400); border-radius: var(--radius-md); padding: 14px 16px; margin-top: 20px; }
    .product-reminder-label { font-size: 12px; font-weight: 600; color: var(--purple-500); margin-bottom: 4px; }
    .product-reminder-name { font-size: 16px; font-weight: 700; color: var(--purple-700); margin-bottom: 6px; line-height: 1.3; }
    .product-reminder-details { display: flex; flex-wrap: wrap; gap: 12px; font-size: 13px; color: var(--purple-600); }
    .product-reminder-details span { background: white; padding: 2px 8px; border-radius: var(--radius-sm); }
    .carpet-summary-row { display: none; gap: 8px; margin-top: 10px; padding-top: 10px; border-top: 1px dashed var(--carpet-300); }
    .carpet-summary-row.show { display: flex; }
    .carpet-summary-item { flex: 1; text-align: center; background: white; padding: 8px; border-radius: var(--radius-sm); }
    .carpet-summary-value { font-size: 16px; font-weight: 700; color: var(--carpet-600); }
    .carpet-summary-label { font-size: 10px; color: var(--gray-500); text-transform: uppercase; }
    .selected-areas { background: var(--purple-50); border: 2px solid #c4b5fd; border-radius: var(--radius-md); padding: 16px; margin-top: 20px; }
    .selected-areas-header { display: flex; justify-content: space-between; margin-bottom: 12px; }
    .selected-areas-title { font-size: 14px; font-weight: 600; color: var(--purple-600); }
    .selected-areas-clear { font-size: 14px; color: var(--gray-500); background: none; border: none; cursor: pointer; text-decoration: underline; }
    .selected-areas-list { display: flex; flex-wrap: wrap; gap: 10px; }
    .selected-area-chip { display: inline-flex; align-items: center; gap: 8px; padding: 10px 14px; background: white; border-radius: var(--radius-full); font-size: 14px; font-weight: 500; border: 1px solid var(--gray-200); }
    .selected-area-chip.needs-measure { border-color: #f472b6; background: #fce7f3; }
    .selected-area-chip .sf-badge { background: var(--green-100); color: var(--green-600); padding: 2px 8px; border-radius: var(--radius-full); font-size: 12px; font-weight: 600; }
    .selected-area-chip .sy-badge { background: var(--carpet-100); color: var(--carpet-600); padding: 2px 8px; border-radius: var(--radius-full); font-size: 12px; font-weight: 600; }
    .selected-area-chip .notes-badge { font-size: 14px; cursor: help; }
    .selected-area-chip .photos-badge { font-size: 12px; background: var(--blue-100); color: var(--blue-600); padding: 2px 6px; border-radius: var(--radius-full); font-weight: 600; }
    .selected-area-chip-measure { width: 28px; height: 28px; border-radius: var(--radius-full); background: var(--purple-100); border: none; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
    .selected-area-chip.needs-measure .selected-area-chip-measure { background: #ec4899; color: white; }
    .selected-area-chip-remove { width: 22px; height: 22px; border-radius: var(--radius-full); background: var(--gray-200); border: none; font-size: 14px; cursor: pointer; }
    .selected-areas-empty { font-size: 14px; color: var(--gray-500); font-style: italic; }
    .closet-picker { background: #fef3c7; border: 2px solid #f59e0b; border-radius: 8px; padding: 12px; margin: 8px 0; }
    .closet-picker-title { font-weight: 600; color: #92400e; margin-bottom: 8px; }
    .closet-picker-options { display: flex; gap: 8px; flex-wrap: wrap; }
    .closet-option-btn, .closet-option-pill { background: #fff; border: 1px solid #f59e0b; border-radius: 16px; padding: 6px 14px; font-size: 14px; cursor: pointer; transition: all 0.2s; }
    .closet-option-btn:hover, .closet-option-pill:hover { background: #fef3c7; border-color: #d97706; }
    .area-group.closet-active, .closet-picker-active { background: #fffbeb; border-radius: 8px; padding: 8px; margin: -8px; }
    #demo-keywords.highlight-required { animation: highlightPulse 0.5s ease-in-out 2; border: 2px solid #ef4444 !important; border-radius: 8px; }
    @keyframes highlightPulse { 0%, 100% { background-color: transparent; } 50% { background-color: #fef2f2; } }
    .measure-summary-card { background: linear-gradient(135deg, #f0fdf4, #dcfce7); border: 2px solid var(--green-500); border-radius: var(--radius-lg); padding: 16px; margin-bottom: 16px; }
    .measure-summary-stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
    .measure-stat { text-align: center; background: white; padding: 12px; border-radius: var(--radius-md); box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    .measure-stat-value { display: block; font-size: 28px; font-weight: 700; color: #16a34a; }
    .measure-stat-label { display: block; font-size: 12px; color: var(--gray-500); margin-top: 2px; }
    .measure-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 9999; display: none; align-items: flex-end; }
    .measure-modal.show { display: flex; }
    .measure-modal-content { background: white; border-radius: var(--radius-lg) var(--radius-lg) 0 0; padding: 20px; width: 100%; max-height: 99vh; display: flex; flex-direction: column; animation: slideUp 0.3s ease; }
    @keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }
    .measure-modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; flex-shrink: 0; }
    .measure-modal-title { font-size: 18px; font-weight: 700; display: flex; align-items: center; gap: 8px; }
    .measure-modal-close { width: 40px; height: 40px; border-radius: var(--radius-full); background: var(--gray-100); border: none; font-size: 24px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
    .measure-modal-body { flex: 1; overflow-y: auto; }
    /* Room diagram with door/window markers + seam lines */
    .room-diagram-section { display: none; margin-bottom: 16px; }
    .room-diagram-section.show { display: block; }
    .room-diagram-title { font-size: 14px; font-weight: 600; color: var(--gray-700); margin-bottom: 8px; }
    .room-diagram-container { background: #f8fafc; border: 1px solid var(--gray-200); border-radius: var(--radius-md); padding: 12px; text-align: center; }
    #room-diagram-svg { width: 100%; max-width: 320px; height: 220px; }
    .room-diagram-actions { display: flex; align-items: center; gap: 12px; margin-top: 10px; }
    .door-add-btn { display: inline-flex; align-items: center; gap: 6px; padding: 8px 14px; border-radius: var(--radius-md); border: 1px solid var(--gray-300); background: white; font-size: 14px; font-weight: 500; cursor: pointer; color: var(--gray-700); transition: all 0.2s; }
    .door-add-btn:hover { background: var(--gray-50); }
    .door-add-btn.active { background: #e53e3e; color: white; border-color: #e53e3e; }
    .door-hint { display: none; font-size: 13px; color: #e53e3e; font-weight: 500; }
    .door-hint.show { display: inline; }
    /* Window Marker Styles */
    .window-add-btn { display: inline-flex; align-items: center; gap: 6px; padding: 8px 14px; border-radius: var(--radius-md); border: 1px solid var(--gray-300); background: white; font-size: 14px; font-weight: 500; cursor: pointer; color: var(--gray-700); transition: all 0.2s; }
    .window-add-btn:hover { background: var(--gray-50); }
    .window-add-btn.active { background: #2563eb; color: white; border-color: #2563eb; }
    /* Wall Picker (for precise door/window placement) */
    .wall-picker { display: none; background: var(--gray-50); border: 1px solid var(--gray-200); border-radius: var(--radius-md); padding: 10px 12px; margin-top: 8px; }
    .wall-picker.show { display: block; }
    .wall-picker-label { font-size: 12px; font-weight: 600; color: var(--gray-600); margin-bottom: 6px; }
    .wall-picker-btns { display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 8px; }
    .wall-picker-btn { padding: 6px 14px; border-radius: var(--radius-full); border: 1px solid var(--gray-300); background: white; font-size: 13px; cursor: pointer; transition: all 0.2s; }
    .wall-picker-btn:hover { background: var(--gray-100); }
    .wall-picker-btn.selected { background: var(--purple-600); color: white; border-color: var(--purple-600); }
    .wall-dist-row { display: none; align-items: center; gap: 8px; }
    .wall-dist-row.show { display: flex; }
    .wall-dist-input { width: 80px; padding: 8px; font-size: 14px; font-weight: 600; text-align: center; border: 2px solid var(--gray-200); border-radius: var(--radius-sm); font-family: inherit; }
    .wall-dist-input:focus { outline: none; border-color: var(--purple-600); box-shadow: 0 0 0 3px var(--purple-100); }
    .wall-dist-label { font-size: 13px; color: var(--gray-600); }
    .wall-dist-confirm { padding: 8px 16px; border-radius: var(--radius-md); border: none; background: var(--green-500); color: white; font-size: 13px; font-weight: 600; cursor: pointer; }
    /* Seam Conflict Warning */
    .seam-conflict-warning { display: none; margin-top: 10px; padding: 10px 14px; border-radius: var(--radius-md); font-size: 13px; line-height: 1.4; }
    .seam-conflict-warning.show { display: block; }
    .seam-conflict-warning.warning { background: #fef2f2; border: 1px solid #fca5a5; color: #991b1b; }
    .seam-conflict-warning.ok { background: #f0fdf4; border: 1px solid #86efac; color: #166534; }
    .seam-conflict-suggest { margin-top: 6px; }
    .seam-conflict-suggest button { padding: 4px 12px; border-radius: var(--radius-full); border: 1px solid #991b1b; background: white; color: #991b1b; font-size: 12px; font-weight: 600; cursor: pointer; margin-top: 4px; }
    .seam-conflict-suggest button:hover { background: #fef2f2; }
    /* Measure Product Reminder */
    .measure-product-reminder { background: linear-gradient(135deg, #fef3c7, #fde68a); border: 2px solid var(--amber-500); border-radius: var(--radius-md); padding: 12px 16px; margin-bottom: 12px; text-align: center; transition: all 0.3s; }
    .measure-product-reminder.has-dimensions { background: linear-gradient(135deg, #dcfce7, #bbf7d0); border-color: var(--green-500); }
    .measure-product-reminder .reminder-label { font-size: 11px; font-weight: 600; color: #92400e; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px; }
    .measure-product-reminder.has-dimensions .reminder-label { color: #166534; }
    .measure-product-reminder .reminder-product { font-size: 15px; font-weight: 700; color: #78350f; line-height: 1.3; margin-bottom: 6px; }
    .measure-product-reminder.has-dimensions .reminder-product { color: #15803d; }
    .measure-product-reminder .reminder-meta { display: flex; justify-content: center; gap: 16px; font-size: 12px; color: #a16207; }
    .measure-product-reminder.has-dimensions .reminder-meta { color: #166534; }
    .carpet-specs-row { display: none; gap: 8px; margin-top: 8px; padding-top: 8px; border-top: 1px dashed var(--carpet-300); }
    .carpet-specs-row.show { display: flex; }
    .carpet-spec { flex: 1; text-align: center; background: white; padding: 6px; border-radius: var(--radius-sm); }
    .carpet-spec-value { font-size: 14px; font-weight: 700; color: var(--carpet-600); }
    .measure-product-reminder.has-dimensions .carpet-spec-value { color: #15803d; }
    .carpet-spec-label { font-size: 10px; color: var(--gray-500); }
    .carpet-direction-section { display: none; margin-bottom: 16px; }
    .carpet-direction-section.show { display: block; }
    .carpet-direction-title { font-size: 14px; font-weight: 600; color: var(--gray-700); margin-bottom: 10px; }
    .carpet-direction-options { display: flex; gap: 10px; }
    .carpet-direction-btn { flex: 1; padding: 10px; border: 2px solid var(--gray-300); border-radius: var(--radius-md); background: white; font-size: 13px; font-weight: 500; cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 4px; transition: all 0.2s; color: var(--gray-600); }
    .carpet-direction-btn:hover { border-color: var(--green-400); background: var(--green-50); }
    .carpet-direction-btn.selected { border-color: var(--green-500); background: linear-gradient(135deg, #dcfce7, #bbf7d0); color: #166534; }
    .carpet-direction-btn .icon { font-size: 20px; }
    .carpet-calc-preview { display: none; background: linear-gradient(135deg, #dcfce7, #bbf7d0); border: 2px solid var(--green-500); border-radius: var(--radius-md); padding: 14px; margin-bottom: 16px; }
    .carpet-calc-preview.show { display: block; }
    .carpet-calc-title { font-size: 13px; font-weight: 700; color: #166534; margin-bottom: 10px; display: flex; align-items: center; gap: 6px; }
    .carpet-calc-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; }
    .carpet-calc-item { text-align: center; background: white; padding: 8px 4px; border-radius: var(--radius-sm); }
    .carpet-calc-value { font-size: 16px; font-weight: 700; color: #15803d; }
    .carpet-calc-label { font-size: 10px; color: var(--gray-500); line-height: 1.2; }
    .carpet-calc-formula { font-size: 12px; color: #166534; margin-top: 10px; padding: 8px; background: white; border-radius: var(--radius-sm); font-family: monospace; text-align: center; }
    .measure-section { margin-bottom: 20px; }
    .measure-section-title { font-size: 14px; font-weight: 700; color: var(--gray-700); margin-bottom: 12px; display: flex; align-items: center; gap: 8px; padding-bottom: 8px; border-bottom: 2px solid var(--gray-200); flex-wrap: wrap; }
    .measure-section-title .icon { font-size: 18px; }
    .measure-section-title.dimension-title { background: linear-gradient(135deg, #166534, #15803d); color: white; padding: 10px 12px; border-radius: var(--radius-md); border-bottom: none; margin-bottom: 12px; }
    .measure-section-title.dimension-title .icon { color: white; }
    .dimension-grid { display: flex; flex-direction: column; gap: 10px; }
    .dimension-row { display: flex; align-items: center; gap: 8px; padding: 10px; background: var(--gray-50); border-radius: var(--radius-md); border: 1px solid var(--gray-200); }
    .dimension-row.has-value { background: var(--green-50); border-color: var(--green-300); }
    .dimension-input { width: 80px; padding: 12px 6px; font-size: 16px; font-weight: 600; text-align: center; border: 2px solid var(--gray-200); border-radius: var(--radius-sm); font-family: inherit; background: white; transition: all 0.15s; }
    .dimension-input:focus { outline: none; border-color: var(--purple-600); box-shadow: 0 0 0 3px var(--purple-100); }
    .dimension-x { font-size: 16px; color: var(--gray-400); font-weight: 600; }
    .dimension-equals { font-size: 16px; color: var(--gray-400); font-weight: 600; }
    .dimension-total { min-width: 80px; padding: 12px 8px; font-size: 16px; font-weight: 700; text-align: center; background: var(--purple-100); color: var(--purple-600); border-radius: var(--radius-sm); }
    .dimension-row.has-value .dimension-total { background: var(--green-100); color: var(--green-600); }
    .dimension-remove { width: 36px; height: 36px; border-radius: var(--radius-full); border: none; background: var(--gray-200); color: var(--gray-500); font-size: 20px; cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
    .dimension-remove:hover { background: #fee2e2; color: #dc2626; }
    .input-with-clear { position: relative; display: inline-flex; align-items: center; }
    .input-with-clear input { padding-right: 32px; }
    .input-clear-btn { position: absolute; right: 6px; top: 50%; transform: translateY(-50%); width: 22px; height: 22px; border-radius: 50%; background: var(--gray-300); color: var(--gray-600); border: none; font-size: 14px; font-weight: 600; cursor: pointer; display: none; align-items: center; justify-content: center; line-height: 1; }
    .input-with-clear input:not(:placeholder-shown) + .input-clear-btn, .input-with-clear input:focus + .input-clear-btn { display: flex; }
    .input-clear-btn:hover { background: var(--gray-400); color: white; }
    .dimension-input-wrap { position: relative; display: inline-flex; align-items: center; }
    .dimension-input-wrap .dimension-input { padding-right: 28px; }
    .dimension-input-wrap .input-clear-btn { right: 4px; width: 20px; height: 20px; font-size: 12px; }
    .stair-input-wrap { position: relative; width: 100%; }
    .stair-input-wrap .stair-input { padding-right: 28px; }
    .stair-input-wrap .input-clear-btn { right: 4px; width: 20px; height: 20px; font-size: 12px; }
    .add-dimension-btn { display: flex; align-items: center; justify-content: center; gap: 8px; padding: 14px; background: var(--purple-50); border: 2px solid var(--purple-600); border-radius: var(--radius-md); color: var(--purple-600); font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s; }
    .add-dimension-btn:hover { background: var(--purple-100); border-color: var(--purple-700); }
    .dimension-footer { display: flex; gap: 10px; margin-top: 12px; align-items: stretch; }
    .dimension-footer .add-dimension-btn { flex: 1; margin: 0; padding: 10px 14px; font-size: 14px; }
    .dimension-footer .grand-total-row { flex: 1; margin: 0; padding: 10px 14px; justify-content: center; gap: 8px; }
    .grand-total-row { display: flex; align-items: center; justify-content: space-between; padding: 14px 16px; background: linear-gradient(135deg, var(--purple-600), #5b21b6); color: white; border-radius: var(--radius-md); margin-top: 12px; }
    .grand-total-label { font-size: 14px; font-weight: 600; }
    .grand-total-value { font-size: 24px; font-weight: 700; }
    .carpet-yardage-row { display: none; align-items: center; justify-content: space-between; padding: 14px 16px; background: linear-gradient(135deg, #166534, #15803d); color: white; border-radius: var(--radius-md); margin-top: 8px; margin-bottom: 20px; }
    .carpet-yardage-row.show { display: flex; }
    .carpet-yardage-details { font-size: 12px; opacity: 0.9; }
    .stair-section { display: none; margin-bottom: 16px; }
    .stair-section.show { display: block; }
    .stair-entries { display: flex; flex-direction: column; gap: 12px; }
    .stair-entry { display: flex; gap: 8px; align-items: flex-end; padding: 12px; background: var(--gray-50); border-radius: var(--radius-md); border: 1px solid var(--gray-200); }
    .stair-entry.has-value { background: var(--green-50); border-color: var(--green-300); }
    .stair-input-group { flex: 1; }
    .stair-input-label { font-size: 11px; color: var(--gray-600); margin-bottom: 4px; font-weight: 500; }
    .stair-input { width: 100%; padding: 10px; font-size: 14px; font-weight: 600; text-align: center; border: 2px solid var(--gray-200); border-radius: var(--radius-md); font-family: inherit; }
    .stair-input:focus { outline: none; border-color: var(--green-500); box-shadow: 0 0 0 3px var(--green-100); }
    .stair-remove { width: 32px; height: 32px; border-radius: var(--radius-full); border: none; background: var(--gray-200); color: var(--gray-500); font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; margin-bottom: 2px; }
    .stair-remove:hover { background: #fee2e2; color: #dc2626; }
    .add-stair-btn { display: flex; align-items: center; justify-content: center; gap: 8px; padding: 10px; background: var(--green-50); border: 2px dashed var(--green-300); border-radius: var(--radius-md); color: var(--green-600); font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; margin-top: 8px; }
    .add-stair-btn:hover { background: var(--green-100); border-color: var(--green-500); }
    .stair-calc-result { margin-top: 12px; padding: 12px; background: var(--green-100); border-radius: var(--radius-md); text-align: center; }
    .stair-calc-value { font-size: 20px; font-weight: 700; color: #15803d; }
    .stair-calc-label { font-size: 12px; color: var(--gray-600); }
    .stair-landing-hint { font-size: 13px; color: var(--gray-500); padding: 10px 14px; background: var(--amber-50); border: 1px dashed var(--amber-400); border-radius: var(--radius-md); margin-bottom: 12px; line-height: 1.4; }
    .stair-nose-section { background: var(--gray-50); border: 2px solid var(--gray-200); border-radius: var(--radius-md); padding: 12px 16px; margin-top: 12px; margin-bottom: 12px; }
    .stair-nose-row { display: flex; align-items: center; justify-content: space-between; padding: 8px 0; }
    .stair-nose-row + .stair-nose-row { border-top: 1px solid var(--gray-200); }
    .stair-nose-label { font-size: 14px; font-weight: 500; color: var(--gray-700); }
    .stair-nose-input-wrap { display: flex; align-items: center; gap: 6px; }
    .stair-nose-input-wrap .stair-input { width: 70px; }
    .stair-nose-unit { font-size: 14px; color: var(--gray-500); font-weight: 500; }
    .stair-nose-count { font-size: 18px; font-weight: 700; color: #15803d; }
    .demo-keywords { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px; }
    .demo-keyword { padding: 10px 16px; border-radius: var(--radius-full); border: 2px solid #fbbf24; background: linear-gradient(135deg, #fef9c3, #fef08a); font-size: 14px; font-weight: 500; color: #92400e; cursor: pointer; transition: all 0.2s; }
    .demo-keyword:hover { border-color: #f59e0b; background: linear-gradient(135deg, #fef08a, #fde047); }
    .demo-keyword:active { transform: scale(0.96); }
    .demo-keyword.selected { background: var(--green-100); border-color: var(--green-500); color: #166534; }
    .demo-keywords.has-selection .demo-keyword:not(.selected) { background: white; border-color: var(--gray-300); color: var(--gray-600); }
    .counter-grid { display: flex; flex-direction: column; gap: 12px; }
    .counter-row { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; background: var(--gray-50); border-radius: var(--radius-md); border: 1px solid var(--gray-200); }
    .counter-row.has-value { background: var(--amber-50); border-color: var(--amber-300); }
    .counter-label { font-size: 15px; font-weight: 500; color: var(--gray-700); }
    .counter-controls { display: flex; align-items: center; gap: 4px; }
    .counter-btn { width: 40px; height: 40px; border-radius: var(--radius-md); border: 2px solid var(--gray-200); background: white; color: var(--gray-600); font-size: 22px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
    .counter-btn:active { transform: scale(0.95); }
    .counter-btn.minus { color: #dc2626; }
    .counter-btn.minus:hover { background: #fee2e2; border-color: #fca5a5; }
    .counter-btn.plus { color: var(--green-600); }
    .counter-btn.plus:hover { background: var(--green-100); border-color: var(--green-400); }
    .counter-value { min-width: 60px; padding: 8px 12px; font-size: 18px; font-weight: 700; text-align: center; background: white; border: 2px solid var(--gray-200); border-radius: var(--radius-sm); }
    .counter-row.has-value .counter-value { background: var(--amber-100); border-color: var(--amber-400); color: #b45309; }
    .molding-items { display: flex; flex-direction: column; gap: 8px; }
    .molding-item { display: flex; align-items: center; justify-content: space-between; padding: 10px 14px; background: white; border: 2px solid var(--gray-200); border-radius: var(--radius-md); }
    .molding-item.has-value { background: #fef3c7; border-color: var(--amber-400); }
    .molding-item-name { font-size: 14px; font-weight: 500; color: var(--gray-700); flex: 1; }
    .molding-item-controls { display: flex; align-items: center; gap: 4px; }
    .molding-btn { width: 36px; height: 36px; border-radius: var(--radius-sm); border: 2px solid var(--gray-200); background: white; color: var(--gray-600); font-size: 18px; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; }
    .molding-btn.minus:hover { background: #fee2e2; border-color: #fca5a5; color: #dc2626; }
    .molding-btn.plus:hover { background: var(--green-100); border-color: var(--green-400); color: var(--green-600); }
    .molding-value { min-width: 50px; padding: 6px 10px; font-size: 16px; font-weight: 700; text-align: center; background: var(--gray-50); border-radius: var(--radius-sm); }
/* &#9472;&#9472; Room Diagram & Door Markers &#9472;&#9472; */
.room-diagram-section {
  margin: 12px 0;
  padding: 12px;
  background: #f8f9fa;
  border-radius: 8px;
  border: 1px solid #e0e0e0;
}
.room-diagram-section h4 {
  margin: 0 0 8px 0;
  font-size: 14px;
  color: #555;
}
.room-diagram-container {
  position: relative;
  width: 100%;
  max-width: 320px;
  margin: 0 auto;
}
.room-diagram-container svg {
  width: 100%;
  height: auto;
  display: block;
}
.room-wall {
  stroke: #333;
  stroke-width: 3;
  fill: none;
  cursor: pointer;
}
.room-wall:hover {
  stroke: #007bff;
  stroke-width: 4;
}
.room-wall.door-placement-active {
  stroke: #28a745;
  stroke-width: 4;
  animation: wallPulse 1s infinite;
}
@keyframes wallPulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}
.room-fill {
  fill: #fff;
  stroke: none;
}
.room-label {
  font-size: 11px;
  fill: #888;
  text-anchor: middle;
  pointer-events: none;
}
.door-marker {
  cursor: pointer;
  transition: transform 0.15s;
}
.door-marker:hover {
  transform: scale(1.2);
}
.door-marker-icon {
  font-size: 18px;
}
.room-add-btn {
  cursor: pointer;
}
.room-add-btn circle {
  fill: #007bff;
  transition: fill 0.15s;
}
.room-add-btn:hover circle {
  fill: #0056b3;
}
.room-add-btn text {
  fill: #fff;
  font-size: 18px;
  font-weight: bold;
  text-anchor: middle;
  dominant-baseline: central;
  pointer-events: none;
}
.door-feature-menu {
  position: absolute;
  background: #fff;
  border-radius: 10px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.25);
  padding: 8px;
  z-index: 100;
  display: none;
}
.door-feature-menu.active {
  display: block;
}
.door-feature-menu button {
  display: flex;
  align-items: center;
  gap: 8px;
  width: 100%;
  padding: 10px 16px;
  border: none;
  background: none;
  font-size: 15px;
  cursor: pointer;
  border-radius: 6px;
  white-space: nowrap;
}
.door-feature-menu button:hover {
  background: #f0f0f0;
}
.door-placement-banner {
  background: #d4edda;
  color: #155724;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 13px;
  text-align: center;
  margin-top: 8px;
  display: none;
}
.door-placement-banner.active {
  display: block;
}
.door-list {
  margin-top: 8px;
  font-size: 13px;
  color: #555;
}
.door-list-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 4px 8px;
  background: #fff;
  border-radius: 4px;
  margin: 4px 0;
  border: 1px solid #e0e0e0;
}
.door-list-item .remove-door {
  color: #dc3545;
  cursor: pointer;
  font-size: 16px;
  padding: 0 4px;
}
    
/* &#9472;&#9472; Room Diagram & Door Markers &#9472;&#9472; */
.room-diagram-section {
  margin: 12px 0;
  padding: 12px;
  background: #f8f9fa;
  border-radius: 8px;
  border: 1px solid #e0e0e0;
}
.room-diagram-section h4 {
  margin: 0 0 8px 0;
  font-size: 14px;
  color: #555;
}
.room-diagram-container {
  position: relative;
  width: 100%;
  max-width: 320px;
  margin: 0 auto;
}
.room-diagram-container svg {
  width: 100%;
  height: auto;
  display: block;
}
.room-wall {
  stroke: #333;
  stroke-width: 3;
  fill: none;
  cursor: pointer;
}
.room-wall:hover {
  stroke: #007bff;
  stroke-width: 4;
}
.room-wall.door-placement-active {
  stroke: #28a745;
  stroke-width: 4;
  animation: wallPulse 1s infinite;
}
@keyframes wallPulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}
.room-fill {
  fill: #fff;
  stroke: none;
}
.room-label {
  font-size: 11px;
  fill: #888;
  text-anchor: middle;
  pointer-events: none;
}
.door-marker {
  cursor: pointer;
  transition: transform 0.15s;
}
.door-marker:hover {
  transform: scale(1.2);
}
.door-marker-icon {
  font-size: 18px;
}
.room-add-btn {
  cursor: pointer;
}
.room-add-btn circle {
  fill: #007bff;
  transition: fill 0.15s;
}
.room-add-btn:hover circle {
  fill: #0056b3;
}
.room-add-btn text {
  fill: #fff;
  font-size: 18px;
  font-weight: bold;
  text-anchor: middle;
  dominant-baseline: central;
  pointer-events: none;
}
.door-feature-menu {
  position: absolute;
  background: #fff;
  border-radius: 10px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.25);
  padding: 8px;
  z-index: 100;
  display: none;
}
.door-feature-menu.active {
  display: block;
}
.door-feature-menu button {
  display: flex;
  align-items: center;
  gap: 8px;
  width: 100%;
  padding: 10px 16px;
  border: none;
  background: none;
  font-size: 15px;
  cursor: pointer;
  border-radius: 6px;
  white-space: nowrap;
}
.door-feature-menu button:hover {
  background: #f0f0f0;
}
.door-placement-banner {
  background: #d4edda;
  color: #155724;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 13px;
  text-align: center;
  margin-top: 8px;
  display: none;
}
.door-placement-banner.active {
  display: block;
}
.door-list {
  margin-top: 8px;
  font-size: 13px;
  color: #555;
}
.door-list-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 4px 8px;
  background: #fff;
  border-radius: 4px;
  margin: 4px 0;
  border: 1px solid #e0e0e0;
}
.door-list-item .remove-door {
  color: #dc3545;
  cursor: pointer;
  font-size: 16px;
  padding: 0 4px;
}

    .carpet-diagram-section { margin-top: 20px; padding: 16px; background: white; border-radius: var(--radius-lg); border: 2px solid var(--green-500); }
    .carpet-diagram-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; flex-wrap: wrap; gap: 10px; }
    .carpet-diagram-title { font-size: 16px; font-weight: 700; color: #166534; display: flex; align-items: center; gap: 8px; }
    .carpet-diagram-actions { display: flex; gap: 8px; flex-wrap: wrap; }
    .carpet-diagram-btn { padding: 8px 14px; border-radius: var(--radius-md); border: 2px solid var(--green-500); background: var(--green-50); color: #166534; font-size: 13px; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 6px; }
    .carpet-diagram-btn:hover { background: var(--green-100); }
    .carpet-diagram-btn.active { background: var(--green-500); color: white; }
    #carpet-diagram-container { overflow-x: auto; overflow-y: visible; margin-bottom: 16px; padding: 10px 0; -webkit-overflow-scrolling: touch; }
    #carpet-diagram-container svg { display: block; min-width: 100%; }
    .seam-controls { display: none; align-items: center; justify-content: center; gap: 8px; padding: 10px; background: var(--green-50); border: 2px solid var(--green-300); border-radius: var(--radius-md); margin-top: 10px; }
    .seam-controls.show { display: flex; }
    .seam-nudge-btn { width: 40px; height: 40px; border-radius: var(--radius-md); border: 2px solid var(--green-500); background: white; color: #166534; font-size: 18px; font-weight: 700; cursor: pointer; display: flex; align-items: center; justify-content: center; }
    .seam-nudge-btn:active { background: var(--green-100); transform: scale(0.95); }
    .seam-offset-input { width: 70px; padding: 8px 4px; font-size: 16px; font-weight: 700; text-align: center; border: 2px solid var(--green-400); border-radius: var(--radius-sm); font-family: inherit; color: #166534; }
    .seam-offset-input:focus { outline: none; border-color: var(--green-600); box-shadow: 0 0 0 3px var(--green-100); }
    .seam-controls-label { font-size: 12px; color: #166534; font-weight: 600; }
    .marker-nudge-controls { display: none; align-items: center; justify-content: center; gap: 6px; padding: 10px; border-radius: var(--radius-md); margin-top: 10px; flex-wrap: wrap; }
    .marker-nudge-controls.show-door { display: flex; background: #fef2f2; border: 2px solid #fca5a5; }
    .marker-nudge-controls.show-window { display: flex; background: #eff6ff; border: 2px solid #93c5fd; }
    .marker-nudge-label { font-size: 12px; font-weight: 600; }
    .marker-nudge-controls.show-door .marker-nudge-label { color: #dc2626; }
    .marker-nudge-controls.show-window .marker-nudge-label { color: #2563eb; }
    .marker-remove-btn { width: 36px; height: 36px; border-radius: var(--radius-md); border: 2px solid #fca5a5; background: white; color: #dc2626; font-size: 16px; font-weight: 700; cursor: pointer; display: flex; align-items: center; justify-content: center; }
    .marker-remove-btn:active { background: #fee2e2; transform: scale(0.95); }
    .seam-select-btn { padding: 10px 16px; border-radius: var(--radius-md); border: 2px solid var(--green-500); background: var(--green-50); color: #166534; font-size: 14px; font-weight: 600; cursor: pointer; display: none; align-items: center; gap: 4px; }
    .seam-select-btn.show { display: inline-flex; }
    .seam-select-btn:active { background: var(--green-100); }
    .carpet-plan-stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 16px; }
    .plan-stat { text-align: center; padding: 12px; background: var(--gray-50); border-radius: var(--radius-md); }
    .plan-stat.highlight { background: var(--green-100); }
    .plan-stat-value { display: block; font-size: 20px; font-weight: 700; color: #166534; }
    .plan-stat-label { display: block; font-size: 11px; color: var(--gray-500); margin-top: 2px; }
    .carpet-plan-waste { display: flex; gap: 16px; padding: 12px; background: var(--amber-50); border-radius: var(--radius-md); margin-bottom: 16px; flex-wrap: wrap; }
    .waste-item { display: flex; gap: 6px; align-items: center; }
    .waste-label { font-size: 12px; color: var(--gray-600); }
    .waste-value { font-size: 13px; font-weight: 600; color: #92400e; }
    .carpet-plan-rooms { padding: 12px; background: var(--gray-50); border-radius: var(--radius-md); }
    .plan-rooms-title { font-size: 12px; font-weight: 600; color: var(--gray-600); margin-bottom: 8px; }
    .plan-room-row { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--gray-200); font-size: 13px; }
    .plan-room-row:last-child { border-bottom: none; }
    .plan-room-name { font-weight: 500; color: var(--gray-700); }
    .plan-room-detail { color: var(--gray-500); }
    .from-leftover { color: #166534; font-weight: 600; }
    .molding-item.has-value .molding-value { background: var(--amber-100); color: #b45309; }
    .room-notes-input { width: 100%; min-height: 80px; padding: 12px 14px; font-size: 15px; border: 2px solid var(--gray-200); border-radius: var(--radius-md); font-family: inherit; resize: vertical; }
    .room-notes-input:focus { outline: none; border-color: var(--purple-600); box-shadow: 0 0 0 3px var(--purple-100); }
    .room-notes-input::placeholder { color: var(--gray-400); }
    .photo-capture-container { display: flex; flex-direction: column; gap: 12px; }
    .photo-thumbnails { display: flex; flex-wrap: wrap; gap: 10px; }
    .photo-thumbnail { position: relative; width: 70px; height: 70px; border-radius: var(--radius-md); overflow: hidden; border: 2px solid var(--gray-200); }
    .photo-thumbnail img { width: 100%; height: 100%; object-fit: cover; }
    .photo-thumbnail-remove { position: absolute; top: -6px; right: -6px; width: 22px; height: 22px; border-radius: var(--radius-full); background: #dc2626; color: white; border: 2px solid white; font-size: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-weight: bold; }
    .photo-capture-btn { display: flex; align-items: center; justify-content: center; gap: 8px; padding: 14px; background: var(--blue-50); border: 2px dashed var(--blue-300); border-radius: var(--radius-md); color: var(--blue-600); font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s; }
    .photo-capture-btn:hover { background: var(--blue-100); border-color: var(--blue-500); }
    .photo-capture-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .photo-capture-btn .camera-icon { font-size: 20px; }
    .measure-actions { display: flex; gap: 12px; margin-top: 16px; padding: 12px 0 8px 0; border-top: 3px solid var(--purple-600); flex-shrink: 0; background: white; }
    .measure-actions .btn { flex: 1; padding: 14px; font-size: 16px; font-weight: 600; }
    .measure-actions .btn-primary { background: var(--purple-600); box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4); }
    .resource-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 200; display: none; align-items: flex-end; }
    .resource-modal.show { display: flex; }
    .resource-modal-content { background: white; border-radius: var(--radius-lg) var(--radius-lg) 0 0; padding: 20px; padding-bottom: calc(20px + var(--safe-bottom)); width: 100%; max-height: 70vh; display: flex; flex-direction: column; animation: slideUp 0.3s ease; }
    .resource-modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
    .resource-modal-title { font-size: 18px; font-weight: 700; }
    .resource-modal-close { width: 40px; height: 40px; border-radius: var(--radius-full); background: var(--gray-100); border: none; font-size: 24px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
    .resource-search-input { width: 100%; padding: 14px 16px; font-size: 16px; border: 2px solid var(--gray-200); border-radius: var(--radius-md); font-family: inherit; margin-bottom: 12px; }
    .resource-search-input:focus { outline: none; border-color: var(--purple-600); }
    .resource-list { flex: 1; overflow-y: auto; border: 1px solid var(--gray-200); border-radius: var(--radius-md); }
    .resource-item { padding: 16px; border-bottom: 1px solid var(--gray-100); cursor: pointer; font-size: 15px; }
    .resource-item:last-child { border-bottom: none; }
    .resource-item:active { background: var(--purple-50); }
    .resource-item.selected { background: var(--green-100); color: var(--green-600); font-weight: 600; }
    .resource-empty { padding: 20px; text-align: center; color: var(--gray-400); font-size: 14px; }
    .resource-modal-actions { display: flex; gap: 12px; margin-top: 16px; }
    .resource-modal-actions .btn { flex: 1; padding: 16px; }
    .bottom-bar { position: fixed; bottom: 0; left: 0; right: 0; background: white; padding: 14px 16px; padding-bottom: calc(14px + var(--safe-bottom)); box-shadow: 0 -4px 20px rgba(0,0,0,0.1); z-index: 1000; display: flex; gap: 12px; -webkit-transform: translateZ(0); transform: translateZ(0); touch-action: manipulation; pointer-events: auto; }
    .btn { flex: 1; padding: 18px 24px; border-radius: var(--radius-md); font-size: 17px; font-weight: 600; cursor: pointer; border: none; font-family: inherit; transition: transform 0.2s; -webkit-tap-highlight-color: rgba(0,0,0,0.1); touch-action: manipulation; user-select: none; -webkit-user-select: none; pointer-events: auto; position: relative; z-index: 1; }
    .btn:active { transform: scale(0.98); }
    .btn:disabled { opacity: 0.5; }
    .btn-secondary { background: var(--gray-100); color: var(--gray-700); border: 2px solid var(--gray-200); flex: 0.4; }
    .btn-primary { background: var(--purple-600); color: white; }
    .btn-success { background: var(--green-600); color: white; }
    .loading-overlay { position: fixed; inset: 0; background: rgba(255,255,255,0.95); z-index: 300; display: none; flex-direction: column; align-items: center; justify-content: center; gap: 20px; }
    .loading-overlay.show { display: flex; }
    .loading-spinner { width: 56px; height: 56px; border: 5px solid var(--gray-200); border-top-color: var(--purple-600); border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .loading-text { font-size: 18px; font-weight: 500; color: var(--gray-600); }
    .toast { position: fixed; bottom: calc(100px + var(--safe-bottom)); left: 16px; right: 16px; background: var(--gray-900); color: white; padding: 16px 20px; border-radius: var(--radius-md); font-size: 15px; font-weight: 500; z-index: 250; transform: translateY(100px); opacity: 0; transition: all 0.3s; }
    .toast.show { transform: translateY(0); opacity: 1; }
    .toast.error { background: #dc2626; }
    .toast.success { background: var(--green-600); }
    .assembly-select-wrap { position: relative; margin-bottom: 16px; }
    .assembly-select { width: 100%; padding: 16px 44px 16px 16px; font-size: 16px; border: 2px solid var(--amber-400); border-radius: var(--radius-md); background: linear-gradient(135deg, #fffbeb, #fef3c7); appearance: none; font-family: inherit; color: #92400e; }
    .assembly-select:focus { outline: none; border-color: var(--purple-600); }
    .assembly-select.has-selection { background: white; border-color: var(--gray-200); color: var(--gray-900); }
    .assembly-select-arrow { position: absolute; right: 16px; top: 50%; transform: translateY(-50%); color: var(--gray-400); pointer-events: none; }
    .assembly-context { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 16px; }
    .assembly-context-chip { padding: 8px 14px; border-radius: var(--radius-full); font-size: 13px; font-weight: 500; }
    .assembly-context-chip.primary { background: var(--green-50); color: var(--green-600); border: 1px solid var(--green-500); }
    .assembly-context-chip.areas { background: var(--purple-50); color: var(--purple-600); border: 1px solid var(--purple-600); }
    .grid-actions { display: flex; gap: 10px; margin-top: 16px; margin-bottom: 16px; flex-wrap: wrap; }
    .grid-action-btn { padding: 12px 18px; border-radius: var(--radius-full); border: 2px solid var(--gray-200); background: white; font-size: 14px; font-weight: 600; color: var(--gray-600); cursor: pointer; }
    .grid-action-btn.primary { background: var(--purple-100); border-color: #c4b5fd; color: var(--purple-600); }
    .grid-summary { font-size: 14px; color: var(--gray-500); margin-bottom: 16px; font-weight: 500; }
    .primary-item-card { background: linear-gradient(135deg, #166534, #15803d); border-radius: var(--radius-lg); padding: 16px; margin-bottom: 16px; color: white; }
    .primary-item-header { display: flex; align-items: flex-start; gap: 12px; }
    .primary-item-checkbox { width: 28px; height: 28px; min-width: 28px; border-radius: 8px; background: white; display: flex; align-items: center; justify-content: center; color: #166534; font-size: 16px; font-weight: bold; margin-top: 2px; }
    .primary-item-info { flex: 1; }
    .primary-item-name { font-size: 15px; font-weight: 600; line-height: 1.3; margin-bottom: 4px; }
    .primary-item-sku { font-size: 12px; opacity: 0.9; margin-bottom: 8px; }
    .primary-item-badge { display: inline-block; padding: 4px 12px; background: rgba(255,255,255,0.2); border-radius: var(--radius-full); font-size: 12px; font-weight: 600; }
    .primary-item-qty-row { display: flex; align-items: center; gap: 12px; margin-top: 16px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.2); flex-wrap: wrap; }
    .primary-item-qty-row label { font-size: 14px; opacity: 0.9; }
    .primary-item-qty-input { width: 120px; padding: 12px; font-size: 18px; font-weight: 700; text-align: center; border: 2px solid rgba(255,255,255,0.3); border-radius: var(--radius-sm); background: rgba(255,255,255,0.95); color: #166534; }
    .primary-item-qty-uom { font-size: 16px; font-weight: 500; }
    .show-options-toggle { display: flex; align-items: center; gap: 10px; padding: 10px 14px; background: rgba(255,255,255,0.15); border-radius: var(--radius-md); cursor: pointer; }
    .show-options-toggle input[type="checkbox"] { display: none; }
    .show-options-box { width: 24px; height: 24px; min-width: 24px; border: 2px solid rgba(255,255,255,0.5); border-radius: 4px; background: transparent; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
    .show-options-toggle input:checked + .show-options-box { background: white url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%2316a34a'%3E%3Cpath d='M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z'/%3E%3C/svg%3E") center/16px no-repeat; border-color: white; }
    .show-options-label { font-size: 14px; font-weight: 500; color: white; opacity: 0.9; }
    #grid-container.grid-collapsed .group-item-section:not(.selected) { display: none !important; }
    #grid-container.grid-collapsed .group-item-section.selected .gd-container .gd-item:not(.selected) { display: none !important; }
    .qty-input { width: 100px; padding: 10px; font-size: 18px; font-weight: 600; text-align: center; border: 2px solid var(--gray-200); border-radius: var(--radius-md); font-family: inherit; }
    .qty-input:focus { outline: none; border-color: var(--purple-600); box-shadow: 0 0 0 4px var(--purple-100); }
    .qty-uom { font-size: 18px; color: var(--gray-600); font-weight: 500; }
    .qty-compact-row { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
    .qty-input-row { display: flex; align-items: center; gap: 8px; }
    .group-item-section { background: var(--gray-50); border: 2px solid var(--gray-200); border-radius: var(--radius-lg); margin-bottom: 12px; overflow: hidden; transition: all 0.2s; }
    .group-item-section.selected { border-color: var(--green-500); background: #f0fdf4; }
    .group-item-section.category-match { background: #fef9c3; border-color: #eab308; }
    .group-item-section.category-match.selected { background: linear-gradient(135deg, #fef9c3 0%, #f0fdf4 100%); border-color: var(--green-500); }
    .gi-header { display: flex; align-items: center; gap: 12px; padding: 14px 16px; cursor: pointer; }
    .gi-checkbox { width: 28px; height: 28px; min-width: 28px; border-radius: 8px; border: 2px solid var(--gray-300); background: var(--gray-100); display: flex; align-items: center; justify-content: center; font-size: 16px; color: white; transition: all 0.2s; }
    .group-item-section.selected .gi-checkbox { background: var(--green-500); border-color: var(--green-500); }
    .gi-info { flex: 1; min-width: 0; }
    .gi-name { font-size: 15px; font-weight: 600; color: var(--gray-400); margin-bottom: 2px; }
    .group-item-section.selected .gi-name { color: #166534; }
    .gi-meta { font-size: 12px; color: var(--gray-400); }
    .group-item-section.selected .gi-meta { color: #15803d; }
    .gi-qty-input { width: 80px; padding: 10px 8px; font-size: 16px; font-weight: 600; text-align: center; border: 2px solid var(--gray-200); border-radius: var(--radius-sm); background: var(--gray-100); color: var(--gray-400); }
    .group-item-section.selected .gi-qty-input { background: white; color: var(--gray-900); border-color: var(--green-400); }
    .gi-qty-input:focus { outline: none; border-color: var(--purple-600); color: var(--gray-900); }
    .gd-container { padding: 0 12px 12px 12px; display: none; }
    .group-item-section.selected .gd-container { display: block; }
    .gd-item { display: flex; align-items: center; gap: 12px; padding: 12px 14px; margin-bottom: 8px; background: var(--gray-50); border: 2px solid var(--gray-200); border-radius: var(--radius-md); transition: all 0.2s; }
    .gd-item:last-child { margin-bottom: 0; }
    .gd-item .gd-name { color: var(--gray-400); }
    .gd-item .gd-sku { color: var(--gray-300); }
    .gd-item.selected { background: white; border-color: var(--purple-400); }
    .gd-item.selected .gd-name { color: var(--gray-700); }
    .gd-item.selected .gd-sku { color: var(--gray-500); }
    .gd-checkbox { width: 24px; height: 24px; min-width: 24px; border-radius: 6px; border: 2px solid var(--gray-300); background: var(--gray-100); display: flex; align-items: center; justify-content: center; font-size: 14px; color: white; cursor: pointer; transition: all 0.2s; }
    .gd-item.selected .gd-checkbox { background: var(--purple-600); border-color: var(--purple-600); }
    .gd-info { flex: 1; min-width: 0; }
    .gd-name { font-size: 14px; font-weight: 600; margin-bottom: 2px; }
    .gd-sku { font-size: 12px; }
    .gd-qty-section { display: flex; align-items: center; gap: 6px; }
    .gd-qty-label { font-size: 12px; color: var(--gray-400); }
    .gd-item.selected .gd-qty-label { color: var(--gray-500); }
    .gd-qty-input { width: 70px; padding: 8px 6px; font-size: 14px; font-weight: 600; text-align: center; border: 2px solid var(--gray-200); border-radius: var(--radius-sm); background: var(--gray-100); color: var(--gray-400); }
    .gd-item.selected .gd-qty-input { background: white; color: var(--gray-900); border-color: var(--purple-300); }
    .gd-qty-input:focus { outline: none; border-color: var(--purple-600); color: var(--gray-900); }
    .empty-state { text-align: center; padding: 40px 20px; color: var(--gray-400); font-size: 15px; }
    .measurement-data-card { background: linear-gradient(135deg, #ecfdf5, #d1fae5); border: 2px solid var(--green-500); }
    .measurement-data-card .card-title { color: #166534; }
    .measurement-data-grid { display: flex; flex-direction: column; gap: 8px; }
    .measurement-data-row { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: white; border-radius: var(--radius-sm); font-size: 14px; }
    .measurement-data-row .label { color: var(--gray-600); display: flex; align-items: center; gap: 6px; }
    .measurement-data-row .label .icon { font-size: 16px; }
    .measurement-data-row .value { font-weight: 700; color: #166534; }
    .measurement-data-row.demo-row .value { color: #b45309; }
    .measurement-data-row.fixture-row .value { color: var(--purple-600); }
    .review-section { margin-bottom: 20px; }
    .review-section-title { font-size: 12px; font-weight: 600; color: var(--gray-500); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; }
    .review-value { font-size: 16px; font-weight: 500; }
    .review-chips { display: flex; flex-wrap: wrap; gap: 8px; }
    .review-chip { padding: 8px 14px; background: var(--gray-100); border-radius: var(--radius-full); font-size: 14px; font-weight: 500; }
    .review-items { background: var(--gray-50); border-radius: var(--radius-md); padding: 12px; max-height: 200px; overflow-y: auto; }
    .review-item-row { display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid var(--gray-200); }
    .review-item-row:last-child { border-bottom: none; }
    .review-item-name { font-weight: 500; flex: 1; padding-right: 12px; }
    .review-item-qty { font-weight: 600; color: var(--purple-600); }
    .comments-card { background: white; border: 1px solid var(--gray-200); }
    .comment-field { margin-bottom: 16px; }
    .comment-label { font-size: 14px; font-weight: 600; color: var(--gray-700); margin-bottom: 8px; }
    .comment-textarea { width: 100%; padding: 14px; font-size: 16px; border: 2px solid var(--gray-200); border-radius: var(--radius-md); font-family: inherit; resize: vertical; min-height: 90px; }
    .comment-textarea:focus { outline: none; border-color: var(--purple-600); }
    .direction-pills { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 12px; }
    .direction-pill { padding: 12px 18px; border-radius: var(--radius-full); border: 2px solid var(--amber-500); background: white; font-size: 14px; font-weight: 600; color: var(--amber-500); cursor: pointer; transition: all 0.2s; }
    .direction-pill:active { transform: scale(0.96); background: var(--amber-100); }
    .stair-demo-prompt { background: #fef9e7; border: 1px solid #f4d03f; border-radius: 12px; padding: 12px; margin: 12px 0; }
    .stair-demo-question { font-weight: 600; color: #7d6608; margin-bottom: 10px; font-size: 14px; }
    .stair-demo-options { display: flex; flex-wrap: wrap; gap: 8px; }
    .stair-demo-btn { padding: 8px 12px; border: 1px solid #e0e0e0; border-radius: 8px; background: #fff; font-size: 13px; cursor: pointer; transition: all 0.2s; }
    .stair-demo-btn:hover { background: #f5f5f5; }
    .stair-demo-btn.selected { background: #fff3cd; border-color: #f4d03f; color: #7d6608; font-weight: 600; }
  </style>
</head>
<body>
<div class="app">
  <header class="header" id="app-header">
    <div class="header-top">
      <div class="header-logo"><img src="https://qu-soft.quickbase.com/up/bi8ybvjs3/g/rri/eg/vb" alt="Qu-Soft"></div>
      <div class="header-info">
        <div class="header-title">Create Bid Items</div>
        <div class="header-subtitle" id="header-project">Project #--</div>
      </div>
      <button type="button" class="header-close" id="btn-close">&times;</button>
    </div>
  </header>
  <div class="progress-bar">
    <div class="progress-step"><div class="progress-dot active" id="prog-dot-1">1</div><span class="progress-label active" id="prog-label-1">Item</span></div>
    <div class="progress-line" id="prog-line-1"></div>
    <div class="progress-step"><div class="progress-dot" id="prog-dot-2">2</div><span class="progress-label" id="prog-label-2">Rooms</span></div>
    <div class="progress-line" id="prog-line-2"></div>
    <div class="progress-step"><div class="progress-dot" id="prog-dot-3">3</div><span class="progress-label" id="prog-label-3">Assembly</span></div>
    <div class="progress-line" id="prog-line-3"></div>
    <div class="progress-step"><div class="progress-dot" id="prog-dot-4">4</div><span class="progress-label" id="prog-label-4">Review</span></div>
  </div>
  <main class="main">
    <div class="step-container active" id="step-1">
      <div class="section-title">Select Primary Item</div>
      <div class="section-hint">Search for the main item that drives this bid</div>
      <div class="card">
        <div class="search-container">
          <span class="search-icon">&#128269;</span>
          <input type="text" class="search-input" id="primary-search" placeholder="Search by SKU or description..." autocomplete="off">
          <button type="button" class="filter-btn" id="filter-btn" title="Filter by Resource">&#9881;</button>
          <div class="search-results" id="primary-results"></div>
        </div>
        <div class="resource-filter-display" id="resource-filter-display">
          <span>Filtering by: <strong id="filter-resource-name">--</strong></span>
          <button type="button" class="clear-filter" id="clear-filter-btn">&times;</button>
        </div>
        <div class="selected-item" id="primary-selected">
          <div class="selected-item-header"><span class="selected-item-label">&#10003; Selected</span><button type="button" class="selected-item-clear" id="primary-clear">&times;</button></div>
          <div class="selected-item-name" id="primary-name">--</div>
          <div class="selected-item-details"><span class="selected-item-badge" id="primary-category">Category</span><span id="primary-sku">SKU: --</span><span id="primary-uom">UOM: --</span><span id="primary-rate">Rate: --</span></div>
        </div>
        <div class="carpet-info-card" id="carpet-info-card">
          <div class="carpet-info-title"><span>&#129526;</span> Carpet Specifications</div>
          <div class="carpet-info-grid">
            <div class="carpet-info-item"><div style="display:flex;align-items:center;justify-content:center;gap:2px;"><input type="number" class="carpet-info-input" id="carpet-width-ft-input" value="12" min="1" max="15" step="1" style="width:48%;padding:4px 2px;font-size:16px;"><span style="font-size:14px;color:var(--gray-500);font-weight:600;">'</span><input type="number" class="carpet-info-input" id="carpet-width-in-input" value="0" min="0" max="11" step="1" style="width:38%;padding:4px 2px;font-size:16px;"><span style="font-size:14px;color:var(--gray-500);font-weight:600;">"</span></div><div class="carpet-info-label">Roll Width (ft' in")</div></div>
            <div class="carpet-info-item"><input type="number" class="carpet-info-input" id="carpet-pm-width-input" value="0" min="0" max="99" step="0.1"><div class="carpet-info-label">PM Width (in)</div></div>
            <div class="carpet-info-item"><input type="number" class="carpet-info-input" id="carpet-pm-length-input" value="0" min="0" max="99" step="0.1"><div class="carpet-info-label">PM Length (in)</div></div>
          </div>
          <div style="display:flex;align-items:center;justify-content:center;gap:8px;margin-top:10px;padding:8px 12px;background:white;border-radius:var(--radius-sm);"><span style="font-size:12px;color:var(--gray-500);font-weight:600;">Seam Allowance:</span><input type="number" class="carpet-info-input" id="carpet-seam-allowance-input" value="2" min="0" max="12" step="0.5" style="width:60px;font-size:16px;padding:4px;"><span style="font-size:12px;color:var(--gray-500);font-weight:500;">in</span></div>
        </div>
      </div>
    </div>
    <div class="step-container" id="step-2">
      <div class="section-title">Measure Rooms</div>
      <div class="section-hint">Select rooms and tap &#128207; to enter measurements</div>
      <div class="unmeasured-warning" id="unmeasured-warning" style="display: none;"><span class="unmeasured-warning-icon">&#9888;&#65039;</span><span id="unmeasured-warning-text">Some selected rooms need measurements</span></div>
      <div class="measure-summary-card" id="measure-summary-card">
        <div class="measure-summary-stats" id="measure-summary-stats">
          <div class="measure-stat"><span class="measure-stat-value" id="rooms-measured-count">0</span><span class="measure-stat-label">Rooms</span></div>
          <div class="measure-stat"><span class="measure-stat-value" id="total-floor-sf">0</span><span class="measure-stat-label">Total SF</span></div>
          <div class="measure-stat" id="total-sy-stat" style="display: none;"><span class="measure-stat-value" id="total-carpet-sy">0</span><span class="measure-stat-label">Total SY</span></div>
        </div>
      </div>
      <div class="card">
        <div id="area-groups-container"></div>
        <div class="custom-area-row"><input type="text" class="custom-area-input" id="custom-area-input" placeholder="Custom area name..."><button type="button" class="custom-area-btn" id="add-custom-btn">Add</button></div>
      </div>
      <div class="product-reminder-card" id="step2-product-reminder">
        <div class="product-reminder-label">&#128230; Measuring for:</div>
        <div class="product-reminder-name" id="step2-product-name">--</div>
        <div class="product-reminder-details"><span id="step2-product-sku">SKU: --</span><span id="step2-product-uom">UOM: --</span><span id="step2-product-rate">Rate: --</span></div>
        <div class="carpet-summary-row" id="carpet-summary-row">
          <div class="carpet-summary-item"><div class="carpet-summary-value" id="carpet-total-sy">0</div><div class="carpet-summary-label">Total SY</div></div>
          <div class="carpet-summary-item"><div class="carpet-summary-value" id="carpet-total-cuts">0</div><div class="carpet-summary-label">Total Cuts</div></div>
          <div class="carpet-summary-item"><div class="carpet-summary-value" id="carpet-total-lf">0</div><div class="carpet-summary-label">Linear Ft</div></div>
        </div>
      </div>
      <div class="carpet-diagram-section" id="carpet-diagram-section" style="display: none;">
        <div class="carpet-diagram-header">
          <div class="carpet-diagram-title"><span>&#128208;</span> Cutting Diagram</div>
          <div class="carpet-diagram-actions">
            <button type="button" class="carpet-diagram-btn" id="btn-optimize-cuts"><span>&#128260;</span> Optimize</button>
            <button type="button" class="carpet-diagram-btn" id="btn-direction-length" data-dir="lengthwise">&#8597;&#65039; Lengthwise</button>
            <button type="button" class="carpet-diagram-btn" id="btn-direction-width" data-dir="widthwise">&#8596;&#65039; Widthwise</button>
          </div>
        </div>
        <div id="carpet-plan-summary"></div>
        <div id="carpet-diagram-container"></div>
      </div>
      <div class="selected-areas" id="selected-areas-container">
        <div class="selected-areas-header"><span class="selected-areas-title">Selected Rooms</span><button type="button" class="selected-areas-clear" id="clear-areas-btn">Clear All</button></div>
        <div class="selected-areas-list" id="selected-areas-list"><span class="selected-areas-empty">No rooms selected yet</span></div>
      </div>
    </div>
    <div class="step-container" id="step-3">
      <div class="section-title">Assembly &amp; Quantities</div>
      <div class="section-hint">Select template and confirm quantities</div>
      <div class="card">
        <div class="card-title">&#128230; Assembly Template</div>
        <div class="assembly-select-wrap"><select class="assembly-select" id="assembly-select"><option value="">-- Choose assembly --</option></select><span class="assembly-select-arrow">&#9660;</span></div>
        <div class="assembly-context"><span class="assembly-context-chip primary" id="ctx-primary">Primary: --</span><span class="assembly-context-chip areas" id="ctx-areas">Rooms: --</span></div>
      </div>
      <div class="card measurement-data-card" id="measurement-data-card" style="display: none;"><div class="card-title">&#128203; Captured from Measurements</div><div class="measurement-data-grid" id="measurement-data-grid"></div></div>
      <div class="card">
        <div class="qty-compact-row"><div class="card-title" style="margin-bottom: 0;">&#128208; Calculated Quantity</div><div class="qty-input-row"><input type="number" class="qty-input" id="primary-qty" placeholder="0" inputmode="decimal" step="0.01" min="0"><span class="qty-uom" id="qty-uom-display">SF</span></div></div>
        <div style="font-size: 13px; color: var(--gray-500); margin-top: 8px;" id="qty-source">From 0 measured rooms</div>
      </div>
      <div class="grid-summary" id="grid-summary">0 items selected</div>
      <div id="grid-container"></div>
      <div class="grid-actions"><button type="button" class="grid-action-btn primary" id="btn-use-defaults">Use Defaults</button><button type="button" class="grid-action-btn" id="btn-select-all">Select All</button><button type="button" class="grid-action-btn" id="btn-clear-all">Clear All</button></div>
    </div>
    <div class="step-container" id="step-4">
      <div class="section-title">Review &amp; Save</div>
      <div class="section-hint">Confirm selections and add comments</div>
      <div class="card">
        <div class="review-section"><div class="review-section-title">Primary Item</div><div class="review-value" id="review-primary">--</div></div>
        <div class="review-section"><div class="review-section-title">Quantity</div><div class="review-value" id="review-qty">--</div></div>
        <div class="review-section"><div class="review-section-title">Work Areas</div><div class="review-chips" id="review-areas">--</div></div>
        <div class="review-section"><div class="review-section-title">Assembly Items (<span id="review-item-count">0</span>)</div><div class="review-items" id="review-items"></div></div>
      </div>
      <div class="card comments-card">
        <div class="card-title">&#128172; Comments (Optional)</div>
        <div class="comment-field"><div class="comment-label">Customer Comment</div><textarea class="comment-textarea" id="cust-comment" placeholder="Notes visible to customer..."></textarea></div>
        <div class="comment-field"><div class="comment-label">Work Comment</div><textarea class="comment-textarea" id="work-comment" placeholder="Internal notes..."></textarea></div>
        <div class="direction-pills"><button type="button" class="direction-pill" data-comment="Install Front to Rear">Front to Rear</button><button type="button" class="direction-pill" data-comment="Install Side to Side">Side to Side</button><button type="button" class="direction-pill" id="sync-comments-btn">&#128260; Sync</button></div>
      </div>
    </div>
  </main>
  <div class="bottom-bar"><button type="button" class="btn btn-secondary" id="btn-back" style="display:none;">Back</button><button type="button" class="btn btn-primary" id="btn-next">Next</button></div>
  <div class="measure-modal" id="measure-modal">
    <div class="measure-modal-content" id="measure-modal-content">
      <div class="measure-modal-header"><span class="measure-modal-title" id="measure-modal-title">&#128207; Room Measurements</span><button type="button" class="measure-modal-close" id="measure-modal-close">&times;</button></div>
      <div class="measure-modal-body">
        <div class="measure-product-reminder" id="measure-product-reminder">
          <div class="reminder-label">Product:</div><div class="reminder-product" id="reminder-product-name">--</div>
          <div class="reminder-meta"><span id="reminder-product-sku">SKU: --</span><span id="reminder-product-rate">Rate: --</span><span id="reminder-product-uom">UOM: --</span></div>
          <div class="carpet-specs-row" id="carpet-specs-row"><div class="carpet-spec"><div class="carpet-spec-value" id="modal-carpet-width">12'</div><div class="carpet-spec-label">Roll Width</div></div><div class="carpet-spec"><div class="carpet-spec-value" id="modal-carpet-pm">0"</div><div class="carpet-spec-label">Pattern Match</div></div></div>
        </div>
        <div class="stair-landing-hint" id="stair-landing-hint" style="display: none;">Measure the stair landings here and the stairs below.</div><div class="measure-section"><div class="measure-section-title dimension-title" id="dimension-section-title"><span class="icon">&#128208;</span> Dimensions (Width x Length)</div><div class="dimension-grid" id="dimension-grid"></div><div class="dimension-footer"><button type="button" class="add-dimension-btn" id="add-dimension-btn"><span>+</span> Add Another Area</button><div class="grand-total-row" id="grand-total-row"><span class="grand-total-value" id="grand-total-sf">0 SF</span></div></div></div>
        <!-- Room Diagram with Door Markers -->
            <div class="room-diagram-section" id="room-diagram-section"><div class="room-diagram-title">Room Diagram</div><div class="room-diagram-container" id="room-diagram-container"><svg id="room-diagram-svg" viewBox="0 0 320 220"></svg></div><div class="seam-controls" id="seam-controls"><span class="seam-controls-label">Seam Position:</span><button type="button" class="seam-nudge-btn" onclick="nudgeSeam('left')">&#9664;</button><input type="number" class="seam-offset-input" id="seam-offset-input" value="0.0" step="0.5" inputmode="decimal" onchange="setSeamOffset(this.value)"><button type="button" class="seam-nudge-btn" onclick="nudgeSeam('right')">&#9654;</button><span class="seam-controls-label">ft offset</span></div><div class="marker-nudge-controls" id="marker-nudge-controls"><span class="marker-nudge-label" id="marker-nudge-label">Door 1</span><button type="button" class="seam-nudge-btn" onclick="nudgeMarker('back')">&#9664;</button><input type="number" class="seam-offset-input" id="marker-position-input" value="0.0" step="0.5" inputmode="decimal" onchange="setMarkerPosition(this.value)"><button type="button" class="seam-nudge-btn" onclick="nudgeMarker('forward')">&#9654;</button><span class="seam-controls-label">ft</span><button type="button" class="marker-remove-btn" onclick="removeSelectedMarker()">&times;</button></div><div class="room-diagram-actions"><button type="button" class="door-add-btn" id="door-add-btn">&#128682; Add Door</button><button type="button" class="window-add-btn" id="window-add-btn">&#129695; Add Window</button><button type="button" class="seam-select-btn" id="seam-select-btn">&#9986; Seam</button></div><div class="wall-picker" id="wall-picker"><div class="wall-picker-label" id="wall-picker-label">Select wall:</div><div class="wall-picker-btns"><button type="button" class="wall-picker-btn" data-wall="top">Top</button><button type="button" class="wall-picker-btn" data-wall="bottom">Bottom</button><button type="button" class="wall-picker-btn" data-wall="left">Left</button><button type="button" class="wall-picker-btn" data-wall="right">Right</button></div><div class="wall-dist-row" id="wall-dist-row"><span class="wall-dist-label" id="wall-dist-label">Distance from left (ft):</span><input type="number" class="wall-dist-input" id="wall-dist-input" placeholder="0" inputmode="decimal" step="0.1" min="0"><button type="button" class="wall-dist-confirm" id="wall-dist-confirm">Place</button></div></div><div class="seam-conflict-warning" id="seam-conflict-warning"></div></div>
	<div class="carpet-direction-section" id="carpet-direction-section"><div class="carpet-direction-title">Carpet Direction (relative to room length)</div><div class="carpet-direction-options"><button type="button" class="carpet-direction-btn selected" data-direction="lengthwise"><span class="icon">&#8597;&#65039;</span><span>Lengthwise</span></button><button type="button" class="carpet-direction-btn" data-direction="widthwise"><span class="icon">&#8596;&#65039;</span><span>Widthwise</span></button></div></div>
        <div class="carpet-calc-preview" id="carpet-calc-preview"><div class="carpet-calc-title"><span>&#129518;</span> Carpet Calculation</div><div class="carpet-calc-grid"><div class="carpet-calc-item"><div class="carpet-calc-value" id="calc-strips">0</div><div class="carpet-calc-label">Strips</div></div><div class="carpet-calc-item"><div class="carpet-calc-value" id="calc-cut-length">0'</div><div class="carpet-calc-label">Cut Length</div></div><div class="carpet-calc-item"><div class="carpet-calc-value" id="calc-linear-ft">0</div><div class="carpet-calc-label">Linear Ft</div></div><div class="carpet-calc-item"><div class="carpet-calc-value" id="calc-sq-yds">0</div><div class="carpet-calc-label">Sq Yds</div></div></div><div class="carpet-calc-formula" id="carpet-calc-formula">--</div></div>
        <div class="measure-section stair-section" id="stair-section"><div class="measure-section-title" id="stair-section-title"><span class="icon">&#129692;</span> Stairs</div><div class="stair-entries" id="stair-entries"><div class="stair-entry" data-stair-idx="0"><div class="stair-input-group"><div class="stair-input-label">Count</div><input type="number" class="stair-input stair-count-input" placeholder="0" min="0"></div><div class="stair-input-group"><div class="stair-input-label">Width (in)</div><input type="number" class="stair-input stair-width-input" placeholder="36" min="0"></div><div class="stair-input-group"><div class="stair-input-label">Tread (in)</div><input type="number" class="stair-input stair-tread-input" placeholder="12" min="0"></div><div class="stair-input-group"><div class="stair-input-label">Riser (in)</div><input type="number" class="stair-input stair-riser-input" placeholder="12" min="0"></div><button type="button" class="stair-remove" data-stair-idx="0">x</button></div></div><div class="stair-btn-row" style="display: flex; gap: 10px; margin-top: 8px;"><button type="button" class="add-stair-btn" id="add-stair-btn" style="flex:1;margin-top:0;"><span>+</span> Add Another Stair</button><button type="button" class="add-stair-btn" id="add-landing-btn" style="flex:1;margin-top:0;background:var(--amber-50);border-color:var(--amber-400);color:#92400e;"><span>+</span> Add Mid Landing</button></div><div class="stair-landing-entries" id="stair-landing-entries" style="display:none;margin-top:12px;"></div><div class="stair-nose-section" id="stair-nose-section" style="display: none;"><div class="stair-nose-row"><span class="stair-nose-label">Stair Nose Length</span><div class="stair-nose-input-wrap"><input type="number" class="stair-input" id="stair-nose-length-input" value="78" min="1" oninput="updateStairNoseCalc()"><span class="stair-nose-unit">in</span></div></div><div class="stair-nose-row"><span class="stair-nose-label">Stair Nose Needed</span><span class="stair-nose-count" id="stair-nose-count">0 pcs</span></div></div><div class="stair-calc-result" id="stair-calc-result" style="display: none;"><div class="stair-calc-value" id="stair-sy-result">0 SY</div><div class="stair-calc-label" id="stair-calc-label">Stairs Carpet Total</div></div></div>
        <div class="carpet-yardage-row" id="carpet-yardage-row"><div><span class="grand-total-label">Carpet Sq Yards</span><div class="carpet-yardage-details" id="carpet-yardage-details">0 strips @ 0' = 0 LF</div></div><span class="grand-total-value" id="carpet-total-sy-modal">0 SY</span></div>
        <div class="measure-section" id="moldings-section"><div class="measure-section-title"><span class="icon">&#128207;</span> Needed Moldings</div><div class="molding-items" id="molding-items"><div class="molding-item" data-molding="t-molding"><span class="molding-item-name">T-Molding</span><div class="molding-item-controls"><button type="button" class="molding-btn minus">-</button><span class="molding-value">0</span><button type="button" class="molding-btn plus">+</button></div></div><div class="molding-item" data-molding="reducer"><span class="molding-item-name">Reducer</span><div class="molding-item-controls"><button type="button" class="molding-btn minus">-</button><span class="molding-value">0</span><button type="button" class="molding-btn plus">+</button></div></div><div class="molding-item" data-molding="threshold"><span class="molding-item-name">Threshold</span><div class="molding-item-controls"><button type="button" class="molding-btn minus">-</button><span class="molding-value">0</span><button type="button" class="molding-btn plus">+</button></div></div><div class="molding-item" data-molding="stair-nose"><span class="molding-item-name">Stair Nose</span><div class="molding-item-controls"><button type="button" class="molding-btn minus">-</button><span class="molding-value">0</span><button type="button" class="molding-btn plus">+</button></div></div></div></div>
        <div class="measure-section" id="bathroom-fixtures-section" style="display: none;"><div class="measure-section-title"><span class="icon">&#128701;</span> Bathroom Fixtures</div><div class="counter-grid"><div class="counter-row" data-counter="toilet"><span class="counter-label">Toilet</span><div class="counter-controls"><button type="button" class="counter-btn minus">-</button><span class="counter-value">0</span><button type="button" class="counter-btn plus">+</button></div></div><div class="counter-row" data-counter="pedestal"><span class="counter-label">Pedestal</span><div class="counter-controls"><button type="button" class="counter-btn minus">-</button><span class="counter-value">0</span><button type="button" class="counter-btn plus">+</button></div></div></div></div>
        <div class="measure-section" id="appliances-section" style="display: none;"><div class="measure-section-title"><span class="icon">&#128268;</span> Appliances</div><div class="counter-grid"><div class="counter-row" data-counter="appliances"><span class="counter-label">Appliances</span><div class="counter-controls"><button type="button" class="counter-btn minus">-</button><span class="counter-value">0</span><button type="button" class="counter-btn plus">+</button></div></div></div></div>
        <div class="measure-section"><div class="measure-section-title"><span class="icon">&#128296;</span> Existing Floor (Demo)</div><div class="demo-keywords" id="demo-keywords"><button type="button" class="demo-keyword" data-demo="carpet">Carpet</button><button type="button" class="demo-keyword" data-demo="tile">Tile</button><button type="button" class="demo-keyword" data-demo="hardwood">Hardwood</button><button type="button" class="demo-keyword" data-demo="laminate">Laminate</button><button type="button" class="demo-keyword" data-demo="vinyl">Vinyl/LVP</button><button type="button" class="demo-keyword" data-demo="stained concrete">Stained Concrete</button><button type="button" class="demo-keyword" data-demo="none">None</button></div></div>
<div class="stair-demo-prompt" id="stair-demo-prompt" style="display: none;"><div class="stair-demo-question">Does the stair area have existing flooring to remove?</div><div class="stair-demo-options" id="stair-demo-options"><button type="button" class="stair-demo-btn" data-stair-demo="none">No Demo</button><button type="button" class="stair-demo-btn" data-stair-demo="same">Same as Room</button><button type="button" class="stair-demo-btn" data-stair-demo="carpet">Carpet</button><button type="button" class="stair-demo-btn" data-stair-demo="hardwood">Hardwood</button><button type="button" class="stair-demo-btn" data-stair-demo="vinyl">Vinyl</button><button type="button" class="stair-demo-btn" data-stair-demo="tile">Tile</button></div></div>
<div class="measure-section"><div class="measure-section-title"><span class="icon">&#128247;</span> Room Photos (up to 5)</div><div class="photo-capture-container"><div class="photo-thumbnails" id="photo-thumbnails"></div><button type="button" class="photo-capture-btn" id="photo-capture-btn"><span class="camera-icon">&#128248;</span><span>Take Photo</span></button><input type="file" id="photo-input" accept="image/*" capture="environment" multiple style="display: none;"></div></div>        <div class="measure-section"><div class="measure-section-title"><span class="icon">&#128221;</span> Room Notes</div><textarea class="room-notes-input" id="room-notes-input" placeholder="Notes for this room (e.g., furniture move, obstacles, special instructions...)"></textarea></div>
      </div>
      <div class="measure-actions"><button type="button" class="btn btn-secondary" id="measure-cancel-btn">Cancel</button><button type="button" class="btn btn-primary" id="measure-save-btn">Save Measurements</button></div>
    </div>
  </div>
  <div class="resource-modal" id="resource-modal">
    <div class="resource-modal-content">
      <div class="resource-modal-header"><span class="resource-modal-title">Filter by Resource</span><button type="button" class="resource-modal-close" id="resource-modal-close">&times;</button></div>
      <input type="text" class="resource-search-input" id="resource-search-input" placeholder="Search resources..." autocomplete="off">
      <div class="resource-list" id="resource-list"><div class="resource-empty">Loading resources...</div></div>
      <div class="resource-modal-actions"><button type="button" class="btn btn-secondary" id="resource-clear-btn">Clear Filter</button><button type="button" class="btn btn-primary" id="resource-apply-btn">Apply</button></div>
    </div>
  </div>
  <div class="loading-overlay" id="loading-overlay"><div class="loading-spinner"></div><div class="loading-text" id="loading-text">Saving...</div></div>
  <div class="toast" id="toast"></div>
</div>
<script>

"use strict";

/**
 * =============================================================================
 * FLOORING ESTIMATE BUILDER
 * =============================================================================
 *
 * A multi-step wizard for creating flooring bid items with room measurements,
 * carpet/hard-surface calculations, and QuickBase integration.
 *
 * ARCHITECTURE OVERVIEW:
 * ---------------------
 *  Step 1: Select primary flooring product (search + resource filter)
 *  Step 2: Select rooms/areas and enter measurements per room
 *  Step 3: Choose assembly, configure group items & quantities
 *  Step 4: Review and save to QuickBase
 *
 * SECTIONS IN THIS FILE:
 *  1. Configuration & Constants
 *  2. Application State
 *  3. Utility Functions
 *  4. QuickBase API Layer
 *  5. Data Loading (Resources, Items, Assemblies)
 *  6. Product Selection (Step 1)
 *  7. Room/Area Management (Step 2)
 *  8. Measurement Modal
 *  9. Carpet Calculations
 * 10. Stair Calculations
 * 11. Assembly & Grid (Step 3)
 * 12. Measurement Aggregation
 * 13. Review & Save (Step 4)
 * 14. Wizard Navigation
 * 15. UI Rendering Helpers
 * 16. Event Binding & Initialization
 * =============================================================================
 */


/* =============================================================================
 * 1. CONFIGURATION & CONSTANTS
 * =============================================================================
 * QuickBase table/field IDs and static reference data.
 * Update these if the QB schema changes.
 * ========================================================================== */

/** QuickBase application token */
var APP_TOKEN = "cs8ici6ch7465cdhgbttdbpjgag";

// -- QuickBase Table (Database) IDs ------------------------------------------
var DBID_PROJECTS       = "bk8aj55i2";
var DBID_ITEMS          = "bk8aj56xu";
var DBID_GROUP_ITEMS    = "bk8aj56x9";
var DBID_GROUP_DETAILS  = "bk8dn4dga";
var DBID_ASSEMBLIES     = "bk8aj56yc";
var DBID_BID_ITEMS      = "bk8aj55jj";
var DBID_EST_DETAILS    = "bk8apr8k7";
var DBID_RESOURCES      = "bk8aj56i8";
var DBID_MEASURES       = "bs53x5zw8";
var DBID_MEASURE_DETAILS = "bt96wsdjd";
var DBID_ATTACHMENTS    = "bk8aj58nc";

// -- Field ID Maps -----------------------------------------------------------
// Each constant maps a friendly name to the QuickBase field ID (fid).
// Naming convention: TABLE_ABBREVIATION = { FIELD_NAME: fid, ... }

/** Measures table fields */
var ME = {
  RID: 3, AREA: 6, WIDTH: 7, LENGTH: 8, REL_PROJECT: 11, TYPE: 13, MEASURED_AREAS: 36,
  DIRECTION: 16, NOTES: 17, STAIR_QTY: 39, STAIR_WIDTH: 40,
  PICTURE_1: 42, PICTURE_2: 50, PICTURE_3: 51, REL_ITEM: 71,
  MEASURED_MOLDINGS: 74, MOLDING_COUNT: 75, TOTAL_MOLDING_LF: 81,
  PM_WIDTH: 83, PM_LENGTH: 84, TOTAL_SY: 85, TOTAL_LF: 86,
  TOTAL_CUTS: 87, PRIMARY_QTY: 88, ITEM_SKU: 89, ITEM_DESC: 90
};

/** Measure Details table fields */
var MD = {
  RID: 3, WIDTH: 6, LENGTH: 7, REL_MEASURE: 8, NOTES: 22,
  MOLDING_QTY: 34, ROOM_NAME: 35, TOTAL_SF: 36, DEMO_TYPE: 37,
  DIMENSIONS_JSON: 38, CARPET_DIRECTION: 39, CARPET_STRIPS: 40,
  CARPET_CUT_LENGTH: 41, CARPET_LF: 42, CARPET_SY: 43,
  SHOE_BASE_LF: 44, QUARTER_ROUND_LF: 45, TRANSITION_QTY: 46,
  THRESHOLD_QTY: 47, REDUCER_QTY: 48, TOILET_QTY: 49,
  PEDESTAL_QTY: 50, APPLIANCE_QTY: 51, STAIR_QTY: 52,
  STAIR_WIDTH: 53, STAIR_SY: 54
};

/** Resources table fields */
var RES = { RID: 3, NAME: 6, SURCHARGE: 561, B2B_LOCK: 518 };

/** Items table fields */
var IT = {
  RID: 3, SKU: 6, DESC: 11, CAT: 116, ITEM_TYPE: 34,
  COST_L: 126, COST_M: 127, COST_H: 128, COST_HH: 166,
  RATE_L: 121, RATE_M: 122, RATE_H: 123, RATE_HH: 438,
  QTY_UOM: 51, WASTE: 83, UOM: 9, RES: 18, WIDTH: 425,
  PATTERN_MATCH_WIDTH: 426, PATTERN_MATCH_LENGTH: 427
};

/** Group Items table fields */
var GI = {
  RID: 3, NAME: 6, CAT: 35, SORT: 17, LOAD_DEF: 136,
  QTY: 204, WASTE: 68, UOM: 67, WA_TEXT: 60
};

/** Group Details table fields */
var GD = {
  RID: 3, REL_GRP: 6, REL_ITEM: 8, SKU: 9, DESC: 41,
  COST: 10, RATE_L: 23, RATE_M: 24, RATE_H: 25, RATE_HH: 34,
  QTY: 15, QTY_UOM: 19, UOM: 12, WASTE: 16, ITEM_TYPE: 33,
  PURCH_DESC: 40
};

/** Bid Items table fields */
var BI = {
  REL_PROJ: 26, REL_GROUP_ITEM: 967, TASK: 962, WA_ENT: 7,
  WA_TXT: 608, ITEM_SKU: 6, QTY: 8, WASTE: 9, UOM: 10,
  SALES: 297, REL_TASK: 955, GI_REL_TASK: 1211, COMBINED_TEXT: 1195,
  TOTEXT_COMBINED: 1199, ATTACH_2: 119, ATTACH_3: 120,
  WA_PRELOADED: 1143
};

/** Estimate Details table fields */
var ED = {
  REL_PROJ: 86, REL_BI: 17, REL_ITEM: 18, SKU: 19, DESC: 6,
  QTY: 11, COST: 12, RATE: 43, QTY_UOM: 14, UOM: 7, WASTE: 15,
  CUST: 81, WORK: 91, RES: 167, SEQUENCE: 98, EXCLUDE_FROM_SALES: 92
};

/** Attachments table fields */
var ATT = {
  RID: 3, TITLE: 6, DESC: 7, TYPE: 14,
  ATTACHMENT_1: 9, ATTACHMENT_2: 58, ATTACHMENT_3: 59,
  ATTACHMENT_4: 159, ATTACHMENT_5: 160,
  REL_PROJECT: 10, REL_BID_ITEM: 231
};

// -- Magic Number Constants --------------------------------------------------

/** Maximum photos per room */
var MAX_PHOTOS_PER_ROOM = 5;

/** Minimum characters to trigger search */
var SEARCH_MIN_CHARS = 2;

/** Debounce delay for search input (ms) */
var SEARCH_DEBOUNCE_MS = 300;

/** Auto-advance delay for dimension inputs (ms) */
var DIMENSION_AUTO_ADVANCE_MS = 1500;

/** Auto-advance delay for stair inputs (ms) */
var STAIR_AUTO_ADVANCE_MS = 750;

/** Default carpet width in feet */
var DEFAULT_CARPET_WIDTH_FT = 12;

/** Default stair measurements (inches) */
var DEFAULT_STAIR = {
  WIDTH_IN: 36,
  TREAD_IN: 12,
  RISER_IN: 12
};

/** Default stair nose lengths by category (inches) */
var STAIR_NOSE_DEFAULTS = {
  HARDWOOD: 78,
  OTHER: 94
};

/** Carpet pad waste factor (5%) */
var CARPET_PAD_WASTE_FACTOR = 1.05;

/** Seam allowance per cut (inches) */
var SEAM_ALLOWANCE_IN = 2;

/** Minimum leftover piece size worth tracking (sq ft) */
var MIN_LEFTOVER_SQFT = 4;

/** Minimum leftover dimension (feet) - pieces smaller than this are scrap */
var MIN_LEFTOVER_DIM_FT = 1.5;

/** Retry delays for polling combined text (ms) */
var COMBINED_TEXT_POLL_DELAYS = [300, 600, 1000, 1500];

/** Molding increment/decrement step size */
var MOLDING_STEP = 0.5;

/** Toast display duration (ms) */
var TOAST_DURATION_MS = 4000;

/** Delay before resetting after save (ms) */
var POST_SAVE_RESET_DELAY_MS = 1500;

/** Total wizard steps */
var TOTAL_STEPS = 4;


// -- Room/Area Definitions ---------------------------------------------------
// Each group contains selectable rooms. `hasClosets` triggers a closet picker
// sub-prompt before the room is added.

var areaGroups = [
  {
    id: "entry_core", label: "Entry and Core", sortOrder: 1,
    items: [
      { id: "entry", label: "Entry", hasClosets: true, sortOrder: 1 },
      { id: "living", label: "Living Room", sortOrder: 2 },
      { id: "dining", label: "Dining Room", hasClosets: true, sortOrder: 3 },
      { id: "study", label: "Study", hasClosets: true, sortOrder: 4 },
      { id: "exercise_room", label: "Exercise Room", hasClosets: true, sortOrder: 5 },
      { id: "media_room", label: "Media Room", hasClosets: true, sortOrder: 6 },
      { id: "game_room", label: "Game Room", hasClosets: true, sortOrder: 7 },
      { id: "bonus_room", label: "Bonus Room", hasClosets: true, sortOrder: 8 }
    ]
  },
  {
    id: "kitchen_zone", label: "Kitchen and Service", sortOrder: 2,
    items: [
      { id: "kitchen", label: "Kitchen", sortOrder: 1 },
      { id: "breakfast", label: "Breakfast", sortOrder: 2 },
      { id: "pantry", label: "Pantry", hasClosets: true, sortOrder: 3 },
      { id: "mud_room", label: "Mud Room", hasClosets: true, sortOrder: 4 },
      { id: "prep_kitchen", label: "Prep Kitchen", sortOrder: 5 },
      { id: "butlers_pantry", label: "Butler's Pantry", sortOrder: 6 },
      { id: "laundry", label: "Laundry", hasClosets: true, sortOrder: 7 },
      { id: "utility", label: "Utility", hasClosets: true, sortOrder: 8 },
      { id: "wine_room", label: "Wine Room", sortOrder: 9 },
      { id: "studio", label: "Studio", hasClosets: true, sortOrder: 10 }
    ]
  },
  {
    id: "hallways_zone", label: "Hallways", sortOrder: 3,
    items: [
      { id: "hallways", label: "Hallways", hasClosets: true, sortOrder: 1 },
      { id: "alcove", label: "Alcove", hasAlcoves: true, sortOrder: 2 },
      { id: "left_hall", label: "Left Hall", hasClosets: true, sortOrder: 3 },
      { id: "right_hall", label: "Right Hall", hasClosets: true, sortOrder: 4 },
      { id: "front_hall", label: "Front Hall", hasClosets: true, sortOrder: 5 },
      { id: "rear_hall", label: "Rear Hall", hasClosets: true, sortOrder: 6 }
    ]
  },
  {
    id: "bedrooms", label: "Bedrooms", sortOrder: 4,
    items: [
      { id: "primary_bed", label: "Primary Bedroom", hasClosets: true, sortOrder: 1 },
      { id: "nursery", label: "Nursery", hasClosets: true, sortOrder: 2 },
      { id: "guest_bed", label: "Guest Bedroom", hasClosets: true, sortOrder: 3 },
      { id: "sitting_room", label: "Sitting Room", hasClosets: true, sortOrder: 4 },
      { id: "bed_2", label: "Bedroom 2", hasClosets: true, sortOrder: 5 },
      { id: "bed_3", label: "Bedroom 3", hasClosets: true, sortOrder: 6 },
      { id: "bed_4", label: "Bedroom 4", hasClosets: true, sortOrder: 7 },
      { id: "bed_5", label: "Bedroom 5", hasClosets: true, sortOrder: 8 },
      { id: "bed_6", label: "Bedroom 6", hasClosets: true, sortOrder: 9 },
      { id: "bed_7", label: "Bedroom 7", hasClosets: true, sortOrder: 10 }
    ]
  },
  {
    id: "baths", label: "Bathrooms", sortOrder: 5,
    items: [
      { id: "master_bath", label: "Master Bath", sortOrder: 1 },
      { id: "guest_bath", label: "Guest Bath", sortOrder: 2 },
      { id: "jack_jill", label: "Jack and Jill", sortOrder: 3 },
      { id: "powder", label: "Powder Room", sortOrder: 4 },
      { id: "bath_2", label: "Bath 2", sortOrder: 5 },
      { id: "bath_3", label: "Bath 3", sortOrder: 6 },
      { id: "bath_4", label: "Bath 4", sortOrder: 7 },
      { id: "bath_5", label: "Bath 5", sortOrder: 8 },
      { id: "bath_6", label: "Bath 6", sortOrder: 9 },
      { id: "bath_7", label: "Bath 7", sortOrder: 10 }
    ]
  },
  {
    id: "upper_interior", label: "Upper Interior", sortOrder: 6,
    items: [
      { id: "upper_hall", label: "Upper Hallway", hasClosets: true, sortOrder: 1 },
      { id: "upper_den", label: "Upper Den", hasClosets: true, sortOrder: 2 },
      { id: "catwalk", label: "Catwalk", sortOrder: 3 },
      { id: "juliet", label: "Juliet Balcony", sortOrder: 4 }
    ]
  },
  {
    id: "exterior", label: "Exterior Areas", sortOrder: 7,
    items: [
      { id: "front_porch", label: "Front Porch", sortOrder: 1 },
      { id: "back_porch", label: "Back Porch", sortOrder: 2 },
      { id: "left_porch", label: "Left Porch", sortOrder: 3 },
      { id: "right_porch", label: "Right Porch", sortOrder: 4 },
      { id: "pool_deck", label: "Pool Deck", sortOrder: 5 },
      { id: "upper_deck", label: "Upper Deck", sortOrder: 6 }
    ]
  },
  {
    id: "optional_other", label: "Optional / Other Areas", sortOrder: 8,
    items: [
      { id: "materials_only", label: "Materials Only", sortOrder: 1 },
      { id: "tbd_requires_site_measure", label: "TBD (Requires Site Measure)", sortOrder: 2 }
    ]
  }
];

/** Closet sub-options shown when a room has `hasClosets: true` */
var closetOptions = [
  { id: "includes", label: "Includes Closet(s)" },
  { id: "excludes", label: "Excludes Closet(s)" }
];

/** Alcove sub-options shown when a room has `hasAlcoves: true` */
var alcoveOptions = [
  { id: "master_alcove", label: "Master Alcove" },
  { id: "guest_alcove", label: "Guest Alcove" },
  { id: "study_alcove", label: "Study Alcove" },
  { id: "hall_alcove", label: "Hall Alcove" }
];

/* =============================================================================
 * 2. APPLICATION STATE
 * =============================================================================
 * All mutable state lives here. Keeping it in one place makes it easy to
 * understand what can change and to implement a future reset.
 * ========================================================================== */

var globalEstimateDetailSequence = 0;  // Auto-increment counter for ED.SEQUENCE
var currentStep          = 1;          // Active wizard step (14)
var projectId            = "";         // QuickBase project record ID (from URL)
var MARGIN_TIER          = "low";      // Pricing tier: "low" | "mid" | "high" | "highest"

// -- Step 1: Product Selection -----------------------------------------------
var currentPrimaryItem   = null;       // Selected primary flooring item object
var currentResourceRid   = "";         // Active resource filter (record ID)
var pendingResourceRid   = "";         // Resource selected in modal before "Apply"
var allResources         = [];         // All resources loaded from QB
var allAssemblies        = [];         // All assemblies loaded from QB

// -- Step 2: Rooms & Measurements --------------------------------------------
var selectedAreas        = [];         // Array of { id, label, closetId?, closetLabel? }
var roomMeasurements     = {};         // Map: areaId &#8594; measurement data object
var pendingClosetArea    = null;       // Area awaiting closet selection
var pendingClosetMeasure = false;      // True if measure stick triggered closet picker

// -- Measurement Modal State -------------------------------------------------
var currentMeasureRoom       = null;   // { id, label } of room being measured
var currentDimensionRows     = [];     // Array of { width, length } for current room
var dimensionAutoAdvanceTimer = null;  // Timer for auto-advancing to next field
var landingAutoAdvanceTimer = null;  // Timer for auto-advancing to next field
var currentRoomPhotos        = [];     // Array of { data, name } for current room
var currentStairEntries      = [];     // Stair measurement entries for current room
var currentLandingEntries    = [];     // Mid landing entries for current room
var stairAutoAdvanceTimer    = null;   // Timer for stair field auto-advance

// -- Door Marker State -------------------------------------------------------
var currentDoorMarkers       = [];     // Array of { wall, positionFt } for current room
var doorPlacementMode        = false;  // True when user is placing a door on diagram
var DOOR_SEAM_BUFFER_FT      = 1.0;   // 1-foot buffer zone around doors for seam avoidance

// -- Window Marker State -----------------------------------------------------
var currentWindowMarkers     = [];     // Array of { wall, positionFt } for current room
var windowPlacementMode      = false;  // True when user is placing a window on diagram

// -- Wall Picker State -------------------------------------------------------
var wallPickerTarget         = null;   // "door" or "window"
var wallPickerWall           = null;   // Currently selected wall in picker

// -- Carpet Mode State -------------------------------------------------------
var isCarpetMode             = false;  // True when primary item is carpet
var carpetWidth              = DEFAULT_CARPET_WIDTH_FT;
var currentOptimizedPlan = null;
var patternMatchWidth        = 0;      // Pattern match width (inches)
var patternMatchLength       = 0;      // Pattern match length (inches)
var currentCarpetDirection   = "lengthwise"; // "lengthwise" or "widthwise"
var seamOffset               = 0;            // Feet offset for seam nudging
var selectedMarkerType       = null;         // "door" or "window" when nudging
var selectedMarkerIdx        = -1;           // Index of selected marker
var diagramIdleScrollTimer   = null;         // Timer for scrolling past diagram
var currentStairDemoType = "none";

// -- Carpet Cutting Optimizer State ------------------------------------------
var carpetCuttingPlan = null;        // Current optimized cutting plan
var carpetLeftoverInventory = [];    // Tracked leftover pieces

// -- Hard Surface Stair Mode -------------------------------------------------
var isHardSurfaceStairMode   = false;  // True for hardwood/LVP stair rooms

// -- Step 3: Assembly Grid ---------------------------------------------------
var assemblyGroupItems   = [];         // Loaded group items for selected assembly
var groupItemsCache      = {};         // Cache: assemblyId &#8594; groupItems[]
var showAllOptions       = false;      // Toggle to show/hide unselected items

// -- Search ------------------------------------------------------------------
var searchTimeout        = null;       // Debounce timer for product search


/* =============================================================================
 * 3. UTILITY FUNCTIONS
 * =============================================================================
 * Pure helpers with no side effects or dependencies on app state.
 * ========================================================================== */

/**
 * Safely get textContent from a DOM element that may be null.
 * Replaces optional chaining: el?.textContent
 * @param {Element|null} el
 * @returns {string}
 */
function _txt(el) {
  return el ? el.textContent : "";
}

/**
 * Safely get a property value from an object that may be null.
 * Replaces optional chaining: obj?.prop
 * @param {Object|null} obj
 * @param {string} prop
 * @returns {*}
 */
function _get(obj, prop) {
  return obj ? obj[prop] : undefined;
}

/**
 * Extract a URL query parameter by name.
 * @param {string} name - Parameter name
 * @returns {string} Parameter value or empty string
 */
function getParam(name) {
  return new URLSearchParams(location.search).get(name) || "";
}

/**
 * Safely parse a value to a number, returning 0 for NaN.
 * @param {*} value - Value to parse
 * @returns {number}
 */

// Parse carpet width from various text formats into decimal feet
// Handles: "13' 2\"", "13'2", "13.17", "13 2", "13", etc.
function parseCarpetWidth(value) {
  if (value === null || value === undefined) return 0;
  var str = String(value).trim();
  if (!str) return 0;
  
  // Try feet-inches pattern: 13'2", 13' 2", 13'2, 13' 2
  var ftInMatch = str.match(/^(\d+)\s*['']\s*(\d+)\s*["""]?\s*$/);
  if (ftInMatch) {
    return parseInt(ftInMatch[1]) + (parseInt(ftInMatch[2]) / 12);
  }
  
  // Try space-separated: "13 2" (feet inches)
  var spaceMatch = str.match(/^(\d+)\s+(\d+)$/);
  if (spaceMatch) {
    return parseInt(spaceMatch[1]) + (parseInt(spaceMatch[2]) / 12);
  }
  
  // Fall back to numeric parse (handles "13", "13.17", "12.5", etc.)
  var n = parseFloat(str);
  return isNaN(n) ? 0 : n;
}

// Convert decimal feet to readable ft-in string (e.g., 12.5 &#8594; "12'6\"")
function toFtInStr(decimalFt) {
  if (decimalFt === null || decimalFt === undefined || isNaN(decimalFt)) return "0'0\"";
  var totalInches = Math.round(decimalFt * 12);
  var ft = Math.floor(totalInches / 12);
  var inches = totalInches % 12;
  return ft + "'" + inches + "\"";
}

function toNum(value) {
  var n = parseFloat(value);
  return isNaN(n) ? 0 : n;
}

/**
 * Escape a string for safe inclusion in XML content.
 * @param {*} value
 * @returns {string}
 */
function escXml(value) {
  return value == null ? "" : String(value)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}

/**
 * Escape a string for safe inclusion in HTML content.
 * @param {string} str
 * @returns {string}
 */
function escHtml(str) {
  return (str || "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}

/**
 * Format a number for QuickBase (rounded to 2 decimal places).
 * @param {*} value
 * @returns {string}
 */
function toQBNum(value) {
  var n = toNum(value);
  return String(Math.round(n * 100) / 100);
}


/* =============================================================================
 * 3b. UI FEEDBACK HELPERS
 * =============================================================================
 * Toast notifications and loading overlay.
 * ========================================================================== */

/**
 * Show a toast notification.
 * @param {string} message - Message to display
 * @param {"info"|"success"|"error"} type - Toast style
 */
function toast(message, type) {
  if (!type) type = "info";
  var el = document.getElementById("toast");
  if (!el) { alert(message); return; }
  el.textContent = message;
  el.className = "toast " + type + " show";
  setTimeout(function() { el.classList.remove("show"); }, TOAST_DURATION_MS);
}

/**
 * Show the full-screen loading overlay with a message.
 * @param {string} message
 */
function showLoad(message) {
  var textEl = document.getElementById("loading-text");
  var overlayEl = document.getElementById("loading-overlay");
  if (textEl) textEl.textContent = message || "Saving...";
  if (overlayEl) overlayEl.classList.add("show");
}

/** Hide the loading overlay. */
function hideLoad() {
  var overlayEl = document.getElementById("loading-overlay");
  if (overlayEl) overlayEl.classList.remove("show");
}


/* =============================================================================
 * 4. QUICKBASE API LAYER
 * =============================================================================
 * Low-level wrappers for QuickBase HTTP API calls.
 * All QB communication goes through these four functions.
 * ========================================================================== */

/**
 * Execute a QuickBase query and return the parsed XML document.
 * @param {string} dbid - Table database ID
 * @param {string} query - QB query string
 * @param {string} clist - Comma-separated field IDs to return
 * @param {string} [options=""] - Additional options (e.g. sort, num)
 * @returns {Promise<Document>} Parsed XML response
 */
async function qbQuery(dbid, query, clist, options) {
  if (!options) options = "";
  var url = "/db/" + dbid
    + "?a=API_DoQuery&useFids=1"
    + "&apptoken=" + encodeURIComponent(APP_TOKEN)
    + "&query=" + encodeURIComponent(query)
    + "&clist=" + encodeURIComponent(clist)
    + (options ? "&options=" + encodeURIComponent(options) : "");

  var response = await fetch(url, { credentials: "include" });
  return new DOMParser().parseFromString(await response.text(), "text/xml");
}

/**
 * Add a new record to a QuickBase table.
 * @param {string} dbid - Table database ID
 * @param {Object} fieldMap - { fid: value, ... }
 * @returns {Promise<string>} The new record's RID
 * @throws {Error} If QB returns an error
 */
async function qbAdd(dbid, fieldMap) {
  var xml = "<qdbapi>";
  for (var fid in fieldMap) {
    xml += '<field fid="' + fid + '">' + escXml(fieldMap[fid]) + "</field>";
  }
  xml += "</qdbapi>";

  var response = await fetch(
    "/db/" + dbid + "?a=API_AddRecord&apptoken=" + encodeURIComponent(APP_TOKEN),
    { method: "POST", credentials: "include", headers: { "Content-Type": "text/xml" }, body: xml }
  );

  var doc = new DOMParser().parseFromString(await response.text(), "text/xml");
  var errNode = doc.querySelector("errcode");
  if (!errNode || errNode.textContent !== "0") {
    throw new Error(_txt(doc.querySelector("errtext")));
  }
  return _txt(doc.querySelector("rid"));
}

/**
 * Edit an existing QuickBase record.
 * @param {string} dbid - Table database ID
 * @param {string} rid - Record ID to update
 * @param {Object} fieldMap - { fid: value, ... }
 * @throws {Error} If QB returns an error
 */
async function qbEdit(dbid, rid, fieldMap) {
  var xml = "<qdbapi><rid>" + escXml(rid) + "</rid>";
  for (var fid in fieldMap) {
    xml += '<field fid="' + fid + '">' + escXml(fieldMap[fid]) + "</field>";
  }
  xml += "</qdbapi>";

  var response = await fetch(
    "/db/" + dbid + "?a=API_EditRecord&apptoken=" + encodeURIComponent(APP_TOKEN),
    { method: "POST", credentials: "include", headers: { "Content-Type": "text/xml" }, body: xml }
  );

  var doc = new DOMParser().parseFromString(await response.text(), "text/xml");
  var errNode = doc.querySelector("errcode");
  if (!errNode || errNode.textContent !== "0") {
    throw new Error(_txt(doc.querySelector("errtext")));
  }
}

/**
 * Upload a base64-encoded file to a QuickBase file attachment field.
 * @param {string} dbid - Table database ID
 * @param {string} rid - Record ID
 * @param {number} fid - File attachment field ID
 * @param {string} base64Data - Data URI (e.g. "data:image/jpeg;base64,...")
 * @param {string} fileName - Name for the uploaded file
 * @returns {Promise<boolean>} True if upload succeeded
 */
async function qbUploadFile(dbid, rid, fid, base64Data, fileName) {
  var base64Match = base64Data.match(/^data:([^;]+);base64,(.+)$/);
  if (!base64Match) return false;

  var xml = '<qdbapi><rid>' + escXml(rid) + '</rid>'
    + '<field fid="' + fid + '" filename="' + escXml(fileName) + '">'
    + base64Match[2]  // raw base64 content (no data URI prefix)
    + '</field></qdbapi>';

  try {
    var response = await fetch(
      "/db/" + dbid + "?a=API_EditRecord&apptoken=" + encodeURIComponent(APP_TOKEN),
      { method: "POST", credentials: "include", headers: { "Content-Type": "text/xml" }, body: xml }
    );
    var doc = new DOMParser().parseFromString(await response.text(), "text/xml");
    var errNode = doc.querySelector("errcode");
    return errNode && errNode.textContent === "0";
  } catch (e) {
    return false;
  }
}


/* =============================================================================
 * 5. DATA LOADING (Resources, Items, Assemblies)
 * =============================================================================
 * Functions that fetch reference data from QuickBase on initialization.
 * ========================================================================== */

/**
 * Load the project context: reads the margin tier from the project record
 * and updates the header display.
 */
async function loadCtx() {
  var headerEl = document.getElementById("header-project");
  if (headerEl && projectId) headerEl.textContent = "Project #" + projectId;
  if (!projectId) return;
  try {
    var xml = await qbQuery(
      DBID_PROJECTS,
      "{'3'.EX.'" + projectId + "'}",
      "3.358",
      "num-1"
    );
    var record = xml.querySelector("record");
    if (record) {
      var marginNode = record.querySelector('f[id="358"]');
      var margin = (marginNode ? marginNode.textContent : "").toLowerCase();
      if (margin === "middle") margin = "mid";
      if (["low", "mid", "high", "highest"].indexOf(margin) === -1) margin = "low";
      MARGIN_TIER = margin;
    }

    } catch (e) { /* silently fail  project display is non-critical */ }
}

/**
 * Load all resources (vendors/suppliers) from QB into `allResources`.
 */
async function loadResources() {
  try {
    var xml = await qbQuery(
      DBID_RESOURCES,
      "{'18'.EX.'Supplier'}AND{'20'.XEX.'1'}",
      [RES.RID, RES.NAME, RES.SURCHARGE, RES.B2B_LOCK].join("."),
      "slist." + RES.NAME
    );
    allResources = [];
    xml.querySelectorAll("record").forEach(function(r) {
      var g = function(fid) { var node = r.querySelector('f[id="' + fid + '"]'); return node ? node.textContent.trim() : ""; };
      allResources.push({ rid: g(RES.RID), name: g(RES.NAME) });
    });
  } catch (e) { /* resources are optional for basic operation */ }
}

/**
 * Pick the correct cost and rate values based on the current MARGIN_TIER.
 * @param {Object} item - Object with cost_low/mid/high/highest and rate_low/mid/high/highest
 * @returns {{ cost: number, rate: number }}
 */
function pickCR(item) {
  var cost = toNum(item.cost_low || item.cost);
  var rate = toNum(item.rate_low);

  if (MARGIN_TIER === "mid") {
    cost = toNum(item.cost_mid || cost);
    rate = toNum(item.rate_mid || rate);
  } else if (MARGIN_TIER === "high") {
    cost = toNum(item.cost_high || cost);
    rate = toNum(item.rate_high || rate);
  } else if (MARGIN_TIER === "highest") {
    cost = toNum(item.cost_highest || cost);
    rate = toNum(item.rate_highest || rate);
  }

  return { cost: cost, rate: rate };
}

/**
 * Search for flooring items by keyword, optionally filtered by resource.
 * @param {string} term - Search keyword (min 2 chars)
 * @param {string} [resourceRid] - Optional resource RID to filter by
 * @returns {Promise<Object[]>} Array of item objects
 */
async function searchItems(term, resourceRid) {
  if (!term || term.length < SEARCH_MIN_CHARS) return [];

  // Exclude assemblies (type=1) and services; search SKU and description
  var escapedTerm = term.replace(/'/g, "''");
  var query = "{'13'.XEX.'1'}AND{'34'.XEX.'Service'}"
    + "AND({'6'.CT.'" + escapedTerm + "'}OR{'10'.CT.'" + escapedTerm + "'})";
  if (resourceRid) {
    query += "AND{'18'.EX.'" + resourceRid + "'}";
  }

  var clist = [
    IT.RID, IT.SKU, IT.DESC, IT.RATE_L, IT.UOM,
    IT.COST_L, IT.COST_M, IT.COST_H, IT.COST_HH,
    IT.RATE_M, IT.RATE_H, IT.RATE_HH, IT.QTY_UOM,
    IT.WASTE, IT.RES, IT.CAT, IT.ITEM_TYPE,
    IT.WIDTH, IT.PATTERN_MATCH_WIDTH, IT.PATTERN_MATCH_LENGTH
  ].join(".");

  var xml = await qbQuery(DBID_ITEMS, query, clist, "num-20");
  var results = [];

  xml.querySelectorAll("record").forEach(function(r) {
    var g = function(fid) { var node = r.querySelector('f[id="' + fid + '"]'); return node ? node.textContent.trim() : ""; };
    var item = {
      id: g(IT.RID),
      sku: g(IT.SKU),
      desc: g(IT.DESC),
      uom: g(IT.UOM),
      qtyUom: g(IT.QTY_UOM),
      wastePct: toNum(g(IT.WASTE)),
      resourceRid: g(IT.RES),
      category: g(IT.CAT),
      itemType: g(IT.ITEM_TYPE),
      carpetWidth: parseCarpetWidth(g(IT.WIDTH)) || DEFAULT_CARPET_WIDTH_FT,
      patternMatchWidth: toNum(g(IT.PATTERN_MATCH_WIDTH)),
      patternMatchLength: toNum(g(IT.PATTERN_MATCH_LENGTH)),
      // Raw tier-specific values (used by pickCR)
      cost_low: g(IT.COST_L), cost_mid: g(IT.COST_M),
      cost_high: g(IT.COST_H), cost_highest: g(IT.COST_HH),
      rate_low: g(IT.RATE_L), rate_mid: g(IT.RATE_M),
      rate_high: g(IT.RATE_H), rate_highest: g(IT.RATE_HH)
    };
    var cr = pickCR(item);
    item.cost = cr.cost;
    item.rate = cr.rate;
    results.push(item);
  });

  return results;
}

/**
 * Load all assemblies from QB. Used to populate the assembly dropdown.
 * @returns {Promise<Object[]>} Array of { id, config, category }
 */
async function loadAsm() {
  var xml = await qbQuery(DBID_ASSEMBLIES, "{'7'.XEX.'1'}", "3.6.26", "slist.26");
  var results = [];
  xml.querySelectorAll("record").forEach(function(r) {
    var g = function(fid) { var node = r.querySelector('f[id="' + fid + '"]'); return node ? node.textContent.trim() : ""; };
    results.push({ id: g(3), config: g(6), category: g(26) });
  });
  return results;
}

/**
 * Load group items and their details for a given assembly.
 * Results are cached to avoid redundant API calls.
 * @param {string} assemblyId - Assembly record ID
 * @returns {Promise<Object[]>} Deep-cloned array of group items with nested groupDetails
 */
async function loadAsmRows(assemblyId) {
  // Cache key includes primary item to handle tier-dependent pricing
  var cacheKey = assemblyId + (currentPrimaryItem ? "_" + currentPrimaryItem.id : "_noprimary");
  if (groupItemsCache[cacheKey]) {
    return JSON.parse(JSON.stringify(groupItemsCache[cacheKey]));
  }

  // Load group items
  var xml = await qbQuery(
    DBID_GROUP_ITEMS,
    "{'131'.EX.'" + assemblyId + "'}AND{'7'.XEX.'1'}",
    [GI.RID, GI.NAME, GI.CAT, GI.LOAD_DEF, GI.QTY, GI.WASTE, GI.UOM, GI.WA_TEXT].join("."),
    "slist." + GI.SORT
  );

  var groupItems = [];
  xml.querySelectorAll("record").forEach(function(r) {
    var g = function(fid) { var node = r.querySelector('f[id="' + fid + '"]'); return node ? node.textContent.trim() : ""; };
    groupItems.push({
      giRid: g(GI.RID),
      name: g(GI.NAME),
      category: g(GI.CAT),
      loadDefault: g(GI.LOAD_DEF) === "1",
      generateQty: toNum(g(GI.QTY)),
      wastePct: toNum(g(GI.WASTE)),
      uom: g(GI.UOM),
      waText: g(GI.WA_TEXT),
      selected: g(GI.LOAD_DEF) === "1",
      currentQty: null,
      groupDetails: []
    });
  });

  // Load group details (child items) for each group item  IN PARALLEL
  var detailPromises = groupItems.map(function(gi) {
    return qbQuery(
      DBID_GROUP_DETAILS,
      "{'6'.EX.'" + gi.giRid + "'}AND{'14'.EX.'0'}",
      [
        GD.RID, GD.REL_GRP, GD.REL_ITEM, GD.SKU, GD.DESC, GD.COST,
        GD.RATE_L, GD.RATE_M, GD.RATE_H, GD.RATE_HH, GD.QTY,
        GD.QTY_UOM, GD.UOM, GD.WASTE, GD.ITEM_TYPE, GD.PURCH_DESC,
        "20"  // fid 20 = "is default" flag
      ].join("."),
      "slist.1"
    ).catch(function(err) {
      console.error("Error loading details for group item " + gi.giRid + ":", err);
      return null;
    });
  });

  var detailResults = await Promise.all(detailPromises);

  for (var gi_i = 0; gi_i < groupItems.length; gi_i++) {
    var gi = groupItems[gi_i];
    var detailXml = detailResults[gi_i];
    if (!detailXml) continue;

    detailXml.querySelectorAll("record").forEach(function(gr) {
      var gg = function(fid) { var node = gr.querySelector('f[id="' + fid + '"]'); return node ? node.textContent.trim() : ""; };
      var isDefault = gg("20") === "1";
      var gd = {
        gdRid: gg(GD.RID),
        itemRid: gg(GD.REL_ITEM) || "",
        itemSku: gg(GD.SKU),
        desc: gg(GD.DESC),
        cost_low: gg(GD.COST),
        rate_low: gg(GD.RATE_L), rate_mid: gg(GD.RATE_M),
        rate_high: gg(GD.RATE_H), rate_highest: gg(GD.RATE_HH),
        qty: toNum(gg(GD.QTY)),
        qtyUom: gg(GD.QTY_UOM),
        uom: gg(GD.UOM),
        wastePct: toNum(gg(GD.WASTE)),
        itemType: gg(GD.ITEM_TYPE),
        purchDesc: gg(GD.PURCH_DESC),
        isDefault: isDefault,
        selected: isDefault,
        currentQty: null
      };
      var cr = pickCR(gd);
      gd.cost = cr.cost;
      gd.rate = cr.rate;
      gi.groupDetails.push(gd);
    });
  }


/* =============================================================================
 * 6. PRODUCT SELECTION (Step 1)
 * =============================================================================
 * Search, select, and clear the primary flooring product.
 * ========================================================================== */

/**
 * Handle search input with debounce.
 * @param {string} term - Search term
 */
async function handleSearch(term) {
  var resultsEl = document.getElementById("primary-results");
  if (!resultsEl) return;

  if (!term || term.length < SEARCH_MIN_CHARS) {
    resultsEl.classList.remove("show");
    return;
  }

  try {
    var items = await searchItems(term, currentResourceRid);

    if (items.length === 0) {
      resultsEl.innerHTML = '<div class="search-result-item">'
        + '<div class="search-result-main">No items found</div></div>';
      resultsEl.classList.add("show");
      return;
    }

    var html = "";
    items.forEach(function(item) {
      var isCarpet = isCarpetCategory(item.category);
      html += '<div class="search-result-item' + (isCarpet ? " carpet-item" : "")
        + '" data-item-id="' + item.id + '">';
      html += '<div class="search-result-main">' + escHtml(item.desc || "(no description)") + '</div>';
      html += '<div class="search-result-meta">';
      html += '<span>SKU: ' + escHtml(item.sku) + '</span>';
      html += '<span>$' + toNum(item.rate).toFixed(2) + '/' + escHtml(item.uom || "EA") + '</span>';
      if (item.category) html += '<span>' + escHtml(item.category) + '</span>';
      if (isCarpet) html += '<span class="search-result-carpet-badge">&#129526; Carpet</span>';
      html += '</div></div>';
    });

    resultsEl.innerHTML = html;
    resultsEl.classList.add("show");

    // Bind click handlers to each result
    resultsEl.querySelectorAll(".search-result-item").forEach(function(el) {
      el.addEventListener("click", function() {
        var item = items.find(function(i) { return i.id === el.dataset.itemId; });
        if (item) selectPrimaryItem(item);
      });
    });
  } catch (err) {
    resultsEl.innerHTML = '<div class="search-result-item">'
      + '<div class="search-result-main">Error searching</div></div>';
    resultsEl.classList.add("show");
  }
}

/**
 * Set the selected primary item and update all related UI.
 * @param {Object} item - Item object from search results
 */
function selectPrimaryItem(item) {
  currentPrimaryItem = item;
  updateCarpetMode();

  // Update the selected item display card
  var el = function(id) { return document.getElementById(id); };
  var primarySelected = el("primary-selected");
  if (primarySelected) primarySelected.classList.add("show");
  if (el("primary-name")) el("primary-name").textContent = item.desc || "(no description)";
  if (el("primary-category")) el("primary-category").textContent = item.category || "Uncategorized";
  if (el("primary-sku")) el("primary-sku").textContent = "SKU: " + (item.sku || "--");
  if (el("primary-uom")) el("primary-uom").textContent = "UOM: " + (item.uom || "--");
  if (el("primary-rate")) el("primary-rate").textContent = "Rate: $" + (item.rate ? toNum(item.rate).toFixed(2) : "--");

  // Hide search results
  var resultsEl = el("primary-results");
  if (resultsEl) resultsEl.classList.remove("show");
  var searchEl = el("primary-search");
  if (searchEl) searchEl.value = "";
  autoSelectAssemblyByCategory(item.category);
}

async function autoSelectAssemblyByCategory(category) {
  if (!category) return;
  var catLower = category.toLowerCase().trim();
  var assemblySelect = document.getElementById("assembly-select");
  if (!assemblySelect) return;
  var bestMatch = null;
  for (var i = 0; i < allAssemblies.length; i++) {
    var asmCat = (allAssemblies[i].category || "").toLowerCase().trim();
    if (asmCat === catLower) {
      bestMatch = allAssemblies[i].id;
      break;
    }
  }
  if (!bestMatch) {
    for (var i = 0; i < allAssemblies.length; i++) {
      var asmCat = (allAssemblies[i].category || "").toLowerCase().trim();
      if (asmCat.includes(catLower) || catLower.includes(asmCat)) {
        bestMatch = allAssemblies[i].id;
        break;
      }
    }
  }
  if (bestMatch) {
    assemblySelect.value = bestMatch;
    assemblySelect.classList.add("has-selection");
    try {
      assemblyGroupItems = await loadAsmRows(bestMatch);
      if (currentStep === 3) {
        await renderAssemblyGrid();
      }
    } catch (err) {
      console.error("Auto-select assembly error:", err);
    }
  }
}

/** Clear the selected primary item and reset carpet mode. */
function clearPrimaryItem() {
  currentPrimaryItem = null;
  isCarpetMode = false;

  var primarySelected = document.getElementById("primary-selected");
  if (primarySelected) primarySelected.classList.remove("show");
  var carpetInfoCard = document.getElementById("carpet-info-card");
  if (carpetInfoCard) carpetInfoCard.classList.remove("show");
}


/* =============================================================================
 * 6b. RESOURCE FILTER
 * =============================================================================
 * Modal for filtering item search by vendor/resource.
 * ========================================================================== */

/** Open the resource filter modal. */
function openResourceModal() {
  pendingResourceRid = currentResourceRid;
  var searchInput = document.getElementById("resource-search-input");
  if (searchInput) searchInput.value = "";
  renderResourceList();
  var modal = document.getElementById("resource-modal");
  if (modal) modal.classList.add("show");
}

/** Close the resource filter modal without applying. */
function closeResourceModal() {
  var modal = document.getElementById("resource-modal");
  if (modal) modal.classList.remove("show");
}

/**
 * Render the filterable list of resources inside the modal.
 * @param {string} [filter=""] - Text to filter resource names
 */
function renderResourceList(filter) {
  if (!filter) filter = "";
  var container = document.getElementById("resource-list");
  if (!container) return;

  var filterLower = filter.toLowerCase();
  var filtered = filter
    ? allResources.filter(function(r) { return r.name.toLowerCase().indexOf(filterLower) !== -1; })
    : allResources;

  if (filtered.length === 0) {
    container.innerHTML = '<div class="resource-empty">No resources found</div>';
    return;
  }

  var html = "";
  filtered.forEach(function(r) {
    var isSelected = r.rid === pendingResourceRid;
    html += '<div class="resource-item' + (isSelected ? " selected" : "")
      + '" data-rid="' + r.rid + '" data-name="' + escHtml(r.name) + '">'
      + escHtml(r.name) + '</div>';
  });
  container.innerHTML = html;

  container.querySelectorAll(".resource-item").forEach(function(item) {
    item.addEventListener("click", function() {
      container.querySelectorAll(".resource-item").forEach(function(i) { i.classList.remove("selected"); });
      item.classList.add("selected");
      pendingResourceRid = item.dataset.rid;
    });
  });
}

/** Apply the pending resource filter and close the modal. */
function applyResourceFilter() {
  currentResourceRid = pendingResourceRid;

  var filterBtn = document.getElementById("filter-btn");
  var filterDisplay = document.getElementById("resource-filter-display");
  var filterResourceName = document.getElementById("filter-resource-name");
  var searchInput = document.getElementById("primary-search");

  if (currentResourceRid) {
    var resource = allResources.find(function(r) { return r.rid === currentResourceRid; });
    if (filterBtn) filterBtn.classList.add("active");
    if (filterDisplay) filterDisplay.classList.add("show");
    if (filterResourceName) filterResourceName.textContent = resource ? resource.name : "Unknown";
    if (searchInput) searchInput.classList.add("filtered");
  } else {
    if (filterBtn) filterBtn.classList.remove("active");
    if (filterDisplay) filterDisplay.classList.remove("show");
    if (searchInput) searchInput.classList.remove("filtered");
  }

  closeResourceModal();
}

/** Clear the active resource filter. */
function clearResourceFilter() {
  currentResourceRid = "";
  pendingResourceRid = "";
  applyResourceFilter();
}


/* =============================================================================
 * 7. ROOM/AREA MANAGEMENT (Step 2)
 * =============================================================================
 * Selecting rooms, closet picker, and rendering room pills/chips.
 * ========================================================================== */

// -- Category Detection Helpers ----------------------------------------------

/** @returns {boolean} True if category indicates carpet */
function isCarpetCategory(category) {
  if (!category) return false;
  var cat = category.toLowerCase().trim();
  return cat === "carpet" || cat.indexOf("carpet") !== -1;
}

/** @returns {boolean} True if category indicates tile */
function isTileCategory(category) {
  if (!category) return false;
  var cat = category.toLowerCase().trim();
  return cat === "tile" || cat.indexOf("tile") !== -1;
}

/** @returns {boolean} True if category indicates hard surface flooring (hardwood, LVP, etc.) */
function isHardSurfaceFlooringCategory(category) {
  if (!category) return false;
  var cat = category.toLowerCase().trim();
  return cat.indexOf("hardwood") !== -1 
    || cat.indexOf("laminate") !== -1
    || cat.indexOf("luxury vinyl") !== -1 
    || cat.indexOf("vinyl resilient") !== -1
    || cat.indexOf("vinyl plank") !== -1
    || cat.indexOf("vinyl") !== -1
    || cat.indexOf("resilient") !== -1
    || cat.indexOf("lvp") !== -1
    || cat.indexOf("lvt") !== -1;
}

/** @returns {boolean} True if the area represents stairs */
function isStairRoom(areaId) {
  if (!areaId) return false;
  var id = areaId.toLowerCase();
  return id.indexOf("stair") !== -1 || id.indexOf("half_set") !== -1;
}

/**
 * Check if a room has any valid measurements saved.
 * @param {string} roomId
 * @returns {boolean}
 */
function roomHasMeasurements(roomId) {
  var m = roomMeasurements[roomId];
  if (!m) return false;
  if (m.totalSF > 0) return true;
  if (m.stairEntries && m.stairEntries.some(function(e) { return toNum(e.qty || e.count) > 0; })) return true;
  if (m.stairsCalc && (m.stairsCalc.squareFeet > 0 || m.stairsCalc.squareYards > 0)) return true;
  return false;
}

/**
 * Get a human-readable stair label based on product category.
 * @param {string} category
 * @returns {string}
 */
function getStairLabelForCategory(category) {
  if (!category) return "Stair Nosing";
  var cat = category.toLowerCase().trim();
  if (cat.indexOf("hardwood") !== -1) return "Hardwood Stairs";
  if (cat.indexOf("carpet") !== -1) return "Carpet Stairs";
  if (cat.indexOf("laminate") !== -1) return "Laminate Stairs";
  if (cat.indexOf("vinyl") !== -1 || cat.indexOf("lvp") !== -1 || cat.indexOf("lvt") !== -1) return "Vinyl Stairs";
  if (cat.indexOf("tile") !== -1) return "Tile Stairs";
  return "Stair Nosing";
}

/**
 * Check if a group item name matches carpet pad products.
 * @param {string} name
 * @returns {boolean}
 */
function isCarpetPadItem(name) {
  if (!name) return false;
  var lower = name.toLowerCase();
  return lower.indexOf("pad") !== -1 || lower.indexOf("cushion") !== -1
    || lower.indexOf("spillmaster") !== -1 || lower.indexOf("spillsafe") !== -1
    || lower.indexOf("sunguard") !== -1 || lower.indexOf("memory step") !== -1;
}

// -- Area Selection Logic ----------------------------------------------------

/**
 * Add an area to the selection (no-op if already selected).
 * @param {string} areaId
 * @param {string} areaLabel
 */
function addAreaToSelection(areaId, areaLabel) {
  if (!selectedAreas.some(function(a) { return a.id === areaId; })) {
    selectedAreas.push({ id: areaId, label: areaLabel });
  }
}

/**
 * Toggle an area's selection. If the area has closets, opens the closet picker.
 * If the area is being deselected, removes its measurements too.
 */
function toggleAreaSelection(areaId, areaLabel, hasClosets) {
  var existingIdx = selectedAreas.findIndex(function(a) { return a.id === areaId; });
  if (existingIdx >= 0) {
    // Deselect: remove area and its measurements
    selectedAreas.splice(existingIdx, 1);
    delete roomMeasurements[areaId];
    closeClosetPicker();
    updatePillStates();
    renderSelectedAreas();
    updateMeasureSummary();
  } else {
    // Select: check if closet picker is needed
    if (hasClosets) {
      pendingClosetMeasure = false;
      var groupId = findGroupIdForArea(areaId);
      renderClosetPicker(areaId, areaLabel, groupId);
    } else {
      closeClosetPicker();
      addAreaToSelection(areaId, areaLabel);
      updatePillStates();
      renderSelectedAreas();
      updateMeasureSummary();
    }
  }
}

/**
 * Find which area group contains a given area ID.
 * @param {string} areaId
 * @returns {string} Group ID or empty string
 */
function findGroupIdForArea(areaId) {
  for (var i = 0; i < areaGroups.length; i++) {
    if (areaGroups[i].items.some(function(item) { return item.id === areaId; })) return areaGroups[i].id;
  }
  return "";
}

// -- Closet Picker -----------------------------------------------------------

/**
 * Render the closet option picker below the relevant area group.
 * Only one closet picker can be open at a time.
 */
function renderClosetPicker(areaId, areaLabel, groupId) {
  closeClosetPicker();
  pendingClosetArea = { id: areaId, label: areaLabel, groupId: groupId };

  var picker = document.createElement("div");
  picker.id = "closet-picker";
  picker.className = "closet-picker";

  var html = '<div class="closet-picker-title">Closets for ' + escHtml(areaLabel) + ':</div>';
  html += '<div class="closet-picker-options">';
  closetOptions.forEach(function(opt) {
    html += '<button type="button" class="closet-option-pill" data-closet-id="'
      + opt.id + '" data-closet-label="' + escHtml(opt.label) + '">'
      + escHtml(opt.label) + '</button>';
  });
  html += '</div>';
  picker.innerHTML = html;

  var groupEl = document.getElementById("group-" + groupId);
  if (groupEl) {
    groupEl.classList.add("closet-picker-active");
    groupEl.appendChild(picker);
    setTimeout(function() {
      picker.scrollIntoView({ behavior: "smooth", block: "center" });
    }, 100);
  }

  // Bind click handlers
  picker.querySelectorAll(".closet-option-pill").forEach(function(btn) {
    btn.addEventListener("click", function(e) {
      e.preventDefault();
      e.stopPropagation();
      onClosetOptionSelected(areaId, areaLabel, {
        id: btn.dataset.closetId,
        label: btn.dataset.closetLabel
      });
    });
  });
}

/** Close and remove the closet picker from the DOM. */
function closeClosetPicker() {
  var picker = document.getElementById("closet-picker");
  if (picker) picker.remove();
  document.querySelectorAll(".closet-picker-active").forEach(function(el) {
    el.classList.remove("closet-picker-active");
  });
  pendingClosetArea = null;
}

/**
 * Handle a closet option being selected  adds the area with closet metadata
 * and immediately opens the measurement modal.
 */
function onClosetOptionSelected(areaId, areaLabel, closetOpt) {
  selectedAreas.push({
    id: areaId, label: areaLabel,
    closetId: closetOpt.id, closetLabel: closetOpt.label
  });
  var shouldMeasure = pendingClosetMeasure;
  closeClosetPicker();
  updatePillStates();
  renderSelectedAreas();
  updateMeasureSummary();
  if (shouldMeasure) {
    openMeasureModal(areaId, areaLabel);
  } else {
    // Scroll back to the room pill so user can keep selecting
    var pill = document.querySelector('.area-pill-wrapper[data-area-id="' + areaId + '"]');
    if (pill) {
      setTimeout(function() {
        pill.scrollIntoView({ behavior: "smooth", block: "center" });
      }, 150);
    }
  }
}


/* =============================================================================
 * 8. MEASUREMENT MODAL
 * =============================================================================
 * The room measurement modal handles dimensions, demo type, moldings,
 * fixtures, photos, notes, and (for carpet/hard surface) stair entries.
 * ========================================================================== */

/**
 * Open the measurement modal for a given room.
 * Restores previously saved data if the room was already measured.
 * @param {string} areaId
 * @param {string} areaLabel
 */
function openMeasureModal(areaId, areaLabel) {
  currentMeasureRoom = { id: areaId, label: areaLabel };
  var modal = document.getElementById("measure-modal");
  if (modal) modal.classList.add("show");
  var modalBody = document.querySelector('.measure-modal-body');
  if (modalBody) modalBody.scrollTop = 0;
  var existing = roomMeasurements[areaId];

  // ------------------- Determine stair mode early -----------------------
  var primaryCat = currentPrimaryItem ? currentPrimaryItem.category : null;
  isHardSurfaceStairMode = isHardSurfaceFlooringCategory(primaryCat);

  // --------------------- Restore or initialize state -----------------------
  var areaEntry = selectedAreas.find(function(a) { return a.id === areaId; });
  var hasCloset = areaEntry && areaEntry.closetLabel;
  var closetCount = 0;
  if (hasCloset) {
    var cl = areaEntry.closetLabel.toLowerCase();
    closetCount = (cl.indexOf("closets") !== -1) ? 2 : 1;
  }
  currentDimensionRows = existing && existing.dimensions
    ? JSON.parse(JSON.stringify(existing.dimensions))
    : (function() {
        var rows = [{ width: "", length: "" }];
        for (var c = 0; c < closetCount; c++) rows.push({ width: "", length: "" });
        return rows;
      })();

  currentRoomPhotos = existing && existing.photos
    ? JSON.parse(JSON.stringify(existing.photos))
    : [];

  currentStairEntries = existing && existing.stairEntries
    ? JSON.parse(JSON.stringify(existing.stairEntries))
    : [{ count: "", width: String(DEFAULT_STAIR.WIDTH_IN), tread: String(DEFAULT_STAIR.TREAD_IN), riser: String(DEFAULT_STAIR.RISER_IN) }];

  currentLandingEntries = existing && existing.landingEntries
    ? JSON.parse(JSON.stringify(existing.landingEntries))
    : [];

  currentCarpetDirection = (existing && existing.carpetDirection) || "lengthwise";
  seamOffset = (existing && existing.seamOffset) || 0;
  selectedMarkerType = null;
  selectedMarkerIdx = -1;
  currentStairDemoType = (existing && existing.stairDemoType) || "none";
  currentDoorMarkers = (existing && existing.doors) ? JSON.parse(JSON.stringify(existing.doors)) : [];
  currentWindowMarkers = (existing && existing.windows) ? JSON.parse(JSON.stringify(existing.windows)) : [];
  // Migrate old ratio-based door positions to feet-based
  var migW = toNum((currentDimensionRows[0] && currentDimensionRows[0].width) || 0);
  var migL = toNum((currentDimensionRows[0] && currentDimensionRows[0].length) || 0);
  currentDoorMarkers.forEach(function(d) {
    if (d.position !== undefined && d.positionFt === undefined) {
      d.positionFt = (d.wall === "top" || d.wall === "bottom") ? d.position * migW : d.position * migL;
      delete d.position;
    }
  });


  // -- Modal title -------------------------------------------------------
  var titleEl = document.getElementById("measure-modal-title");
  if (titleEl) titleEl.innerHTML = "&#128207; " + escHtml(areaLabel);

  // -- Product reminder --------------------------------------------------
  var reminder = document.getElementById("measure-product-reminder");
  if (reminder) {
    if (currentPrimaryItem) {
      reminder.textContent = currentPrimaryItem.desc + " (" + (currentPrimaryItem.sku || "") + ")";
      reminder.style.display = "block";
    } else {
      reminder.style.display = "none";
    }
  }

  // -- Dimension grid ----------------------------------------------------
  renderDimensionRows();
  updateGrandTotal();
  renderStairEntries();
  // Show closet measurement reminder if this room has closets
  var closetReminder = document.getElementById("closet-measure-reminder");
  if (!closetReminder) {
    var dimFooter = document.querySelector(".dimension-footer");
    if (dimFooter) {
      closetReminder = document.createElement("div");
      closetReminder.id = "closet-measure-reminder";
      closetReminder.style.cssText = "display:none;background:#fce4ec;border:2px solid #f48fb1;border-radius:8px;padding:10px 14px;margin-bottom:8px;font-size:13px;font-weight:600;color:#c2185b;text-align:center;";
      dimFooter.parentNode.insertBefore(closetReminder, dimFooter);
    }
  }
  if (closetReminder) {
    if (hasCloset) {
      closetReminder.textContent = closetCount === 1
        ? "Line 2 is for measuring the closet - please don't forget!"
        : "Lines 2 & 3 are for measuring the closets - please don't forget!";
      closetReminder.style.display = "block";
    } else {
      closetReminder.style.display = "none";
    }
  }
  // Focus first width input AFTER rows are rendered
  var firstWidth = document.querySelector('#dimension-grid .dim-width');
  if (firstWidth) firstWidth.focus();

  // -- Photos ------------------------------------------------------------
  renderPhotoThumbnails();

  // -- Demo type selection -----------------------------------------------
  var demoKeywords = document.getElementById("demo-keywords");
  if (demoKeywords) {
    demoKeywords.querySelectorAll(".demo-keyword").forEach(function(btn) {
      btn.classList.remove("selected");
      if (existing && existing.demoType && btn.dataset.demo === existing.demoType) {
        btn.classList.add("selected");
      }
    });
    demoKeywords.classList.toggle("has-selection", !!(existing && existing.demoType));
  }

  // -- Molding counters --------------------------------------------------
  document.querySelectorAll(".molding-item").forEach(function(item) {
    var type = item.dataset.molding;
    var valueEl = item.querySelector(".molding-value");
    if (valueEl) {
      var count = (existing && existing.moldings && existing.moldings[type]) || 0;
      valueEl.textContent = count;
      item.classList.toggle("has-value", count > 0);
    }
  });

  // -- Fixture counters --------------------------------------------------
  document.querySelectorAll(".counter-row").forEach(function(row) {
    var type = row.dataset.counter;
    var valueEl = row.querySelector(".counter-value");
    if (valueEl) {
      var count = (existing && existing.fixtures && existing.fixtures[type]) || 0;
      valueEl.textContent = count;
      row.classList.toggle("has-value", count > 0);
    }
  });

  // -- Notes -------------------------------------------------------------
  var notesInput = document.getElementById("room-notes-input");
  if (notesInput) notesInput.value = (existing && existing.notes) || "";

  // -- Contextual sections (bathroom fixtures, appliances) ---------------
  var roomLower = areaLabel.toLowerCase();
  var isBathroom = roomLower.indexOf("bath") !== -1 || roomLower.indexOf("powder") !== -1;
  var isKitchen = roomLower.indexOf("kitchen") !== -1 || roomLower.indexOf("pantry") !== -1
    || roomLower.indexOf("laundry") !== -1;

  var bathroomSection = document.getElementById("bathroom-fixtures-section");
  var appliancesSection = document.getElementById("appliances-section");
  if (bathroomSection) bathroomSection.style.display = isBathroom ? "block" : "none";
  if (appliancesSection) appliancesSection.style.display = isKitchen ? "block" : "none";

  var primaryCatForModal = currentPrimaryItem ? currentPrimaryItem.category : null;
  var isTile = isTileCategory(primaryCatForModal);
  var moldingsSection = document.getElementById("moldings-section");
  if (moldingsSection) moldingsSection.style.display = (isCarpetMode || isTile) ? "none" : "";
  var carpetDirSection = document.getElementById("carpet-direction-section");
  if (carpetDirSection) carpetDirSection.classList.toggle("show", isCarpetMode);
  var stairSection = document.getElementById("stair-section");
  if (stairSection) stairSection.classList.toggle("show", isCarpetMode || isHardSurfaceStairMode);

  var stairDemoPrompt = document.getElementById("stair-demo-prompt");
  if (stairDemoPrompt) stairDemoPrompt.style.display = "none";

  var stairNoseSection = document.getElementById("stair-nose-section");
  if (stairNoseSection) stairNoseSection.style.display = (isHardSurfaceStairMode && !isCarpetMode && !isTile) ? "" : "none";

  var stairLandingHint = document.getElementById("stair-landing-hint");
  if (stairLandingHint) stairLandingHint.style.display = (isCarpetMode || isHardSurfaceStairMode) ? "" : "none";
  updateStairDemoPrompt();
  // -- Room diagram with door/window markers + seam lines ----------------
  var roomDiagramSection = document.getElementById("room-diagram-section");
  if (roomDiagramSection) {
    if (isCarpetMode) {
      roomDiagramSection.classList.add("show");
      closeWallPicker();
      renderRoomDiagram();
    } else {
      roomDiagramSection.classList.remove("show");
    }
  }
 }

/** Calculate seam positions in feet from left edge (lengthwise) or top edge (widthwise). */
function calculateRoomSeamPositions() {
  if (!isCarpetMode) return [];
  var w = toNum((currentDimensionRows[0] && currentDimensionRows[0].width) || 0);
  var l = toNum((currentDimensionRows[0] && currentDimensionRows[0].length) || 0);
  if (w <= 0 || l <= 0) return [];
  var widthToCover = (currentCarpetDirection === "lengthwise") ? w : l;
  var strips = Math.ceil(widthToCover / carpetWidth);
  var seams = [];
  for (var s = 1; s < strips; s++) {
    var pos = s * carpetWidth + seamOffset;
    if (pos > 0 && pos < widthToCover) {
      seams.push({ positionFt: pos, seamNumber: s });
    }
  }
  return seams;
}

/** Check for conflicts between seam positions and door positions. */
function checkSeamDoorConflicts(seams) {
  var conflicts = [];
  if (!seams || seams.length === 0 || currentDoorMarkers.length === 0) return conflicts;
  var w = toNum((currentDimensionRows[0] && currentDimensionRows[0].width) || 0);
  var l = toNum((currentDimensionRows[0] && currentDimensionRows[0].length) || 0);
  if (w <= 0 || l <= 0) return conflicts;
  // Lengthwise: seams are vertical &#8594; conflict with doors on top/bottom
  // Widthwise: seams are horizontal &#8594; conflict with doors on left/right
  var conflictWalls = (currentCarpetDirection === "lengthwise") ? ["top", "bottom"] : ["left", "right"];
  currentDoorMarkers.forEach(function(door, di) {
    if (conflictWalls.indexOf(door.wall) === -1) return;
    var doorFt = door.positionFt;
    seams.forEach(function(seam) {
      if (Math.abs(seam.positionFt - doorFt) <= DOOR_SEAM_BUFFER_FT) {
        conflicts.push({ doorIndex: di, doorWall: door.wall, doorFt: doorFt, seamNumber: seam.seamNumber, seamFt: seam.positionFt });
      }
    });
  });
  return conflicts;
}

/** Update the seam conflict warning message below the diagram. */
function updateSeamConflictWarning() {
  var warningEl = document.getElementById("seam-conflict-warning");
  if (!warningEl) return;
  if (!isCarpetMode || currentDoorMarkers.length === 0) { warningEl.classList.remove("show"); return; }
  var seams = calculateRoomSeamPositions();
  if (seams.length === 0) { warningEl.classList.remove("show"); return; }
  var conflicts = checkSeamDoorConflicts(seams);
  if (conflicts.length > 0) {
    var html = "";
    conflicts.forEach(function(c) {
      html += "\u26a0\ufe0f Seam at " + c.seamFt.toFixed(1) + "' is within " + DOOR_SEAM_BUFFER_FT + "' of door on " + c.doorWall + " wall (" + c.doorFt.toFixed(1) + "')<br>";
    });
    var otherDir = (currentCarpetDirection === "lengthwise") ? "widthwise" : "lengthwise";
    html += '<div class="seam-conflict-suggest">Try switching carpet direction to avoid: <button type="button" onclick="switchDirectionFromWarning(\'' + otherDir + '\')">Switch to ' + otherDir + '</button></div>';
    warningEl.innerHTML = html;
    warningEl.className = "seam-conflict-warning show warning";
  } else {
    warningEl.innerHTML = "\u2705 No seam-door conflicts \u2014 seam placement looks good.";
    warningEl.className = "seam-conflict-warning show ok";
  }
}

/** Switch carpet direction from the conflict warning button. */
function switchDirectionFromWarning(dir) {
  currentCarpetDirection = dir;
  document.querySelectorAll(".carpet-direction-btn").forEach(function(btn) {
    btn.classList.toggle("selected", btn.dataset.direction === dir);
  });
  if (isCarpetMode) { updateCarpetCalcPreview(); updateStairsCalc(); }
  renderRoomDiagram();
}

/** Render SVG room diagram with walls, door/window markers, and seam lines. */
/** Render SVG room diagram with walls, door/window markers, and seam lines. */
function renderRoomDiagram() {
  var svg = document.getElementById("room-diagram-svg");
  if (!svg) return;

  // Collect all valid dimension rows
  var validRows = [];
  currentDimensionRows.forEach(function(row, idx) {
    var w = toNum(row.width);
    var l = toNum(row.length);
    if (w > 0 && l > 0) validRows.push({ w: w, l: l, idx: idx });
  });

  if (validRows.length === 0) {
    svg.setAttribute("viewBox", "0 0 320 220");
    svg.innerHTML = '<text x="160" y="110" text-anchor="middle" fill="#999" font-size="14">Enter dimensions to see room diagram</text>';
    updateSeamConflictWarning();
    updateSeamControls();
    return;
  }

  // Layout constants
  var SVG_WIDTH = 320;
  var FIRST_AREA_HEIGHT = 220;
  var EXTRA_AREA_HEIGHT = 140;
  var AREA_GAP = 15;
  var SUMMARY_HEIGHT = 40;

  // Calculate total SVG height
  var totalHeight = FIRST_AREA_HEIGHT;
  if (validRows.length > 1) {
    totalHeight += (validRows.length - 1) * (EXTRA_AREA_HEIGHT + AREA_GAP);
    totalHeight += SUMMARY_HEIGHT;
  }
  svg.setAttribute("viewBox", "0 0 " + SVG_WIDTH + " " + totalHeight);

  var html = '';
  var w = validRows[0].w;
  var l = validRows[0].l;

  // &#9472;&#9472; Area 1 label &#9472;&#9472;
  if (validRows.length > 1) {
    var sf1 = (w * l).toFixed(0);
    html += '<text x="' + (SVG_WIDTH / 2) + '" y="14" text-anchor="middle" fill="#6b7280" font-size="11" font-weight="600">Area 1: ' + w.toFixed(1) + "\'  " + l.toFixed(1) + "\' = " + sf1 + ' SF</text>';
  }

  // &#9472;&#9472; Area 1 rectangle &#9472;&#9472;
  var maxW = 270, maxH = 170;
  var scale = Math.min(maxW / w, maxH / l);
  var rw = w * scale, rh = l * scale;
  var rx = (SVG_WIDTH - rw) / 2, ry = (FIRST_AREA_HEIGHT - rh) / 2;

  html += '<rect x="' + rx + '" y="' + ry + '" width="' + rw + '" height="' + rh + '" fill="#f0f4ff" stroke="#2c5282" stroke-width="2" rx="2"/>';

  // Dimension labels
  html += '<text x="' + (rx + rw / 2) + '" y="' + (ry - 8) + '" text-anchor="middle" fill="#2c5282" font-size="11">' + w.toFixed(1) + '\'</text>';
  html += '<text x="' + (rx + rw / 2) + '" y="' + (ry + rh + 16) + '" text-anchor="middle" fill="#2c5282" font-size="11">' + w.toFixed(1) + '\'</text>';
  html += '<text x="' + (rx - 8) + '" y="' + (ry + rh / 2) + '" text-anchor="middle" fill="#2c5282" font-size="11" transform="rotate(-90,' + (rx - 8) + ',' + (ry + rh / 2) + ')">' + l.toFixed(1) + '\'</text>';
  html += '<text x="' + (rx + rw + 8) + '" y="' + (ry + rh / 2) + '" text-anchor="middle" fill="#2c5282" font-size="11" transform="rotate(90,' + (rx + rw + 8) + ',' + (ry + rh / 2) + ')">' + l.toFixed(1) + '\'</text>';

  // &#9472;&#9472; Seam Lines (carpet mode only) &#9472;&#9472;
  if (isCarpetMode) {
    var seams = calculateRoomSeamPositions();
    var conflicts = checkSeamDoorConflicts(seams);
    var conflictSeamNums = {};
    conflicts.forEach(function(c) { conflictSeamNums[c.seamNumber] = true; });
    seams.forEach(function(seam) {
      var hasConflict = !!conflictSeamNums[seam.seamNumber];
      var color = hasConflict ? "#ef4444" : "#22c55e";
      if (currentCarpetDirection === "lengthwise") {
        var sx = rx + (seam.positionFt / w) * rw;
        html += '<line x1="' + sx + '" y1="' + ry + '" x2="' + sx + '" y2="' + (ry + rh) + '" stroke="' + color + '" stroke-width="2" stroke-dasharray="6,4" opacity="0.8"/>';
        html += '<text x="' + sx + '" y="' + (ry + rh + 28) + '" text-anchor="middle" fill="' + color + '" font-size="8" font-weight="600">' + seam.positionFt.toFixed(1) + '\'</text>';
      } else {
        var sy = ry + (seam.positionFt / l) * rh;
        html += '<line x1="' + rx + '" y1="' + sy + '" x2="' + (rx + rw) + '" y2="' + sy + '" stroke="' + color + '" stroke-width="2" stroke-dasharray="6,4" opacity="0.8"/>';
        html += '<text x="' + (rx + rw + 22) + '" y="' + (sy + 3) + '" text-anchor="middle" fill="' + color + '" font-size="8" font-weight="600">' + seam.positionFt.toFixed(1) + '\'</text>';
      }
    });
  }

  // &#9472;&#9472; Door Markers (red "D" with distance label) &#9472;&#9472;
  currentDoorMarkers.forEach(function(door, di) {
    var dx, dy, lbX, lbY;
    if (door.wall === "top") { dx = rx + (door.positionFt / w) * rw; dy = ry; lbX = dx; lbY = ry - 18; }
    else if (door.wall === "bottom") { dx = rx + (door.positionFt / w) * rw; dy = ry + rh; lbX = dx; lbY = ry + rh + 28; }
    else if (door.wall === "left") { dx = rx; dy = ry + (door.positionFt / l) * rh; lbX = rx - 20; lbY = dy + 4; }
    else { dx = rx + rw; dy = ry + (door.positionFt / l) * rh; lbX = rx + rw + 20; lbY = dy + 4; }
    html += '<g class="door-marker" data-door-idx="' + di + '" style="cursor:pointer">';
    var isDoorSelected = (selectedMarkerType === "door" && selectedMarkerIdx === di);
    if (isDoorSelected) { html += '<circle cx="' + dx + '" cy="' + dy + '" r="15" fill="none" stroke="#e53e3e" stroke-width="2" stroke-dasharray="3,2" opacity="0.7"/>'; }
    html += '<circle cx="' + dx + '" cy="' + dy + '" r="10" fill="' + (isDoorSelected ? '#b91c1c' : '#e53e3e') + '" stroke="#fff" stroke-width="2"/>';
    html += '<text x="' + dx + '" y="' + (dy + 4) + '" text-anchor="middle" fill="#fff" font-size="10" font-weight="700">D</text>';
    html += '<text x="' + lbX + '" y="' + lbY + '" text-anchor="middle" fill="#e53e3e" font-size="8">' + door.positionFt.toFixed(1) + '\'</text>';
    html += '</g>';
  });

  // &#9472;&#9472; Window Markers (blue "W" with distance label) &#9472;&#9472;
  currentWindowMarkers.forEach(function(win, wi) {
    var wx, wy, wlX, wlY;
    if (win.wall === "top") { wx = rx + (win.positionFt / w) * rw; wy = ry; wlX = wx; wlY = ry - 18; }
    else if (win.wall === "bottom") { wx = rx + (win.positionFt / w) * rw; wy = ry + rh; wlX = wx; wlY = ry + rh + 28; }
    else if (win.wall === "left") { wx = rx; wy = ry + (win.positionFt / l) * rh; wlX = rx - 20; wlY = wy + 4; }
    else { wx = rx + rw; wy = ry + (win.positionFt / l) * rh; wlX = rx + rw + 20; wlY = wy + 4; }
    html += '<g class="window-marker" data-window-idx="' + wi + '" style="cursor:pointer">';
    var isWinSelected = (selectedMarkerType === "window" && selectedMarkerIdx === wi);
    if (isWinSelected) { html += '<circle cx="' + wx + '" cy="' + wy + '" r="15" fill="none" stroke="#2563eb" stroke-width="2" stroke-dasharray="3,2" opacity="0.7"/>'; }
    html += '<circle cx="' + wx + '" cy="' + wy + '" r="10" fill="' + (isWinSelected ? '#1d4ed8' : '#2563eb') + '" stroke="#fff" stroke-width="2"/>';
    html += '<text x="' + wx + '" y="' + (wy + 4) + '" text-anchor="middle" fill="#fff" font-size="10" font-weight="700">W</text>';
    html += '<text x="' + wlX + '" y="' + wlY + '" text-anchor="middle" fill="#2563eb" font-size="8">' + win.positionFt.toFixed(1) + '\'</text>';
    html += '</g>';
  });

  // &#9472;&#9472; Additional Areas (Area 2, 3, etc.) &#9472;&#9472;
  if (validRows.length > 1) {
    var currentY = FIRST_AREA_HEIGHT + AREA_GAP;
    var totalSF = w * l;
    var areaColors = ['#16a34a', '#0891b2', '#9333ea', '#dc2626', '#ea580c'];

    for (var i = 1; i < validRows.length; i++) {
      var aw = validRows[i].w;
      var al = validRows[i].l;
      var asf = aw * al;
      totalSF += asf;
      var aColor = areaColors[(i - 1) % areaColors.length];

      // Separator line
      html += '<line x1="40" y1="' + (currentY - 5) + '" x2="' + (SVG_WIDTH - 40) + '" y2="' + (currentY - 5) + '" stroke="#e5e7eb" stroke-width="1"/>';

      // Area label
      html += '<text x="' + (SVG_WIDTH / 2) + '" y="' + (currentY + 14) + '" text-anchor="middle" fill="' + aColor + '" font-size="11" font-weight="600">Area ' + (i + 1) + ': ' + aw.toFixed(1) + "\'  " + al.toFixed(1) + "\' = " + asf.toFixed(0) + ' SF</text>';

      // Scaled rectangle
      var aMaxW = 200, aMaxH = 80;
      var aScale = Math.min(aMaxW / aw, aMaxH / al);
      var arw = aw * aScale, arh = al * aScale;
      var arx = (SVG_WIDTH - arw) / 2;
      var ary = currentY + 24;

      html += '<rect x="' + arx + '" y="' + ary + '" width="' + arw + '" height="' + arh + '" fill="' + aColor + '" fill-opacity="0.08" stroke="' + aColor + '" stroke-width="1.5" rx="2"/>';

      // Width label (top)
      html += '<text x="' + (arx + arw / 2) + '" y="' + (ary - 5) + '" text-anchor="middle" fill="' + aColor + '" font-size="10">' + aw.toFixed(1) + '\'</text>';

      // Length label (left)
      html += '<text x="' + (arx - 6) + '" y="' + (ary + arh / 2) + '" text-anchor="middle" fill="' + aColor + '" font-size="10" transform="rotate(-90,' + (arx - 6) + ',' + (ary + arh / 2) + ')">' + al.toFixed(1) + '\'</text>';

      currentY += EXTRA_AREA_HEIGHT + AREA_GAP;
    }

    // Combined total
    html += '<rect x="60" y="' + (currentY - 8) + '" width="' + (SVG_WIDTH - 120) + '" height="28" fill="#166534" fill-opacity="0.1" rx="6"/>';
    html += '<text x="' + (SVG_WIDTH / 2) + '" y="' + (currentY + 12) + '" text-anchor="middle" fill="#166534" font-size="13" font-weight="700">Combined: ' + totalSF.toFixed(0) + ' SF</text>';
  }

  svg.innerHTML = html;

  // Click to remove markers
  svg.querySelectorAll(".door-marker").forEach(function(marker) {
    marker.addEventListener("click", function() {
      var idx = parseInt(marker.dataset.doorIdx);
      if (selectedMarkerType === "door" && selectedMarkerIdx === idx) { deselectMarker(); }
      else { selectMarker("door", idx); }
    });
  });
  svg.querySelectorAll(".window-marker").forEach(function(marker) {
    marker.addEventListener("click", function() {
      var idx = parseInt(marker.dataset.windowIdx);
      if (selectedMarkerType === "window" && selectedMarkerIdx === idx) { deselectMarker(); }
      else { selectMarker("window", idx); }
    });
  });
  updateSeamConflictWarning();
  updateSeamControls();
}

function addDoorAtDistance(wall, distanceFt) { currentDoorMarkers.push({ wall: wall, positionFt: distanceFt }); renderRoomDiagram(); }
function addWindowAtDistance(wall, distanceFt) { currentWindowMarkers.push({ wall: wall, positionFt: distanceFt }); renderRoomDiagram(); }
function removeDoorMarker(idx) { currentDoorMarkers.splice(idx, 1); renderRoomDiagram(); }
function removeWindowMarker(idx) { currentWindowMarkers.splice(idx, 1); renderRoomDiagram(); }
/** Select a door or window marker for nudging. */
function selectMarker(type, idx) {
  clearTimeout(diagramIdleScrollTimer);
  selectedMarkerType = type;
  selectedMarkerIdx = idx;
  renderRoomDiagram();
  updateMarkerNudgeControls();
}

/** Deselect the current marker and show seam controls again. */
function deselectMarker() {
  selectedMarkerType = null;
  selectedMarkerIdx = -1;
  renderRoomDiagram();
  updateMarkerNudgeControls();
}

/** Get the currently selected marker object, or null. */
function getSelectedMarker() {
  if (selectedMarkerType === "door" && selectedMarkerIdx >= 0 && selectedMarkerIdx < currentDoorMarkers.length) {
    return currentDoorMarkers[selectedMarkerIdx];
  }
  if (selectedMarkerType === "window" && selectedMarkerIdx >= 0 && selectedMarkerIdx < currentWindowMarkers.length) {
    return currentWindowMarkers[selectedMarkerIdx];
  }
  return null;
}

/** Nudge the selected marker by 0.5 ft along its wall. */
function nudgeMarker(direction) {
  clearTimeout(diagramIdleScrollTimer);
  var marker = getSelectedMarker();
  if (!marker) return;
  var step = 0.5;
  var w = toNum((currentDimensionRows[0] && currentDimensionRows[0].width) || 0);
  var l = toNum((currentDimensionRows[0] && currentDimensionRows[0].length) || 0);
  var maxDist = (marker.wall === "top" || marker.wall === "bottom") ? w : l;
  var newPos = marker.positionFt + (direction === "back" ? -step : step);
  newPos = Math.round(newPos * 10) / 10;
  newPos = Math.max(0.5, Math.min(newPos, maxDist - 0.5));
  marker.positionFt = newPos;
  renderRoomDiagram();
  updateMarkerNudgeControls();
}

/** Set the selected marker to an exact position. */
function setMarkerPosition(value) {
  var marker = getSelectedMarker();
  if (!marker) return;
  var w = toNum((currentDimensionRows[0] && currentDimensionRows[0].width) || 0);
  var l = toNum((currentDimensionRows[0] && currentDimensionRows[0].length) || 0);
  var maxDist = (marker.wall === "top" || marker.wall === "bottom") ? w : l;
  var newPos = Math.round(toNum(value) * 10) / 10;
  newPos = Math.max(0, Math.min(newPos, maxDist));
  marker.positionFt = newPos;
  renderRoomDiagram();
  updateMarkerNudgeControls();
}

/** Remove the currently selected marker. */
function removeSelectedMarker() {
  if (selectedMarkerType === "door" && selectedMarkerIdx >= 0) {
    currentDoorMarkers.splice(selectedMarkerIdx, 1);
  } else if (selectedMarkerType === "window" && selectedMarkerIdx >= 0) {
    currentWindowMarkers.splice(selectedMarkerIdx, 1);
  }
  deselectMarker();
}

/** Show/hide marker nudge controls and update display. */
function updateMarkerNudgeControls() {
  var controls = document.getElementById("marker-nudge-controls");
  var seamBtn = document.getElementById("seam-select-btn");
  if (!controls) return;

  var marker = getSelectedMarker();
  controls.classList.remove("show-door", "show-window");

  if (marker) {
    var isDoor = selectedMarkerType === "door";
    controls.classList.add(isDoor ? "show-door" : "show-window");

    var label = document.getElementById("marker-nudge-label");
    var posInput = document.getElementById("marker-position-input");
    var markerNum = selectedMarkerIdx + 1;
    var edgeLabel = (marker.wall === "top" || marker.wall === "bottom") ? "from left" : "from top";

    if (label) label.textContent = (isDoor ? "Door " : "Window ") + markerNum + " (" + marker.wall + ")  " + edgeLabel;
    if (posInput) posInput.value = marker.positionFt.toFixed(1);

    if (seamBtn) seamBtn.classList.add("show");
    updateSeamControls();
  } else {
    var hasMarkers = currentDoorMarkers.length > 0 || currentWindowMarkers.length > 0;
    if (seamBtn) seamBtn.classList.toggle("show", isCarpetMode && hasMarkers);
    updateSeamControls();
  }
}
/** Nudge all seams left or right by 0.5 ft. */
function nudgeSeam(direction) {
  clearTimeout(diagramIdleScrollTimer);
  var step = 0.5;
  seamOffset += (direction === "left") ? -step : step;
  seamOffset = Math.round(seamOffset * 10) / 10;
  updateSeamControls();
  renderRoomDiagram();
  updateCarpetCalcPreview();
}

/** Set seam offset from direct input. */
function setSeamOffset(value) {
  seamOffset = Math.round(toNum(value) * 10) / 10;
  updateSeamControls();
  renderRoomDiagram();
  updateCarpetCalcPreview();
}

/** Show/hide seam controls and update the offset display. */
function updateSeamControls() {
  var controls = document.getElementById("seam-controls");
  if (!controls) return;
  // Hide seam controls when a door/window marker is selected
  if (selectedMarkerType) {
    controls.classList.remove("show");
    return;
  }
  var seams = calculateRoomSeamPositions();
  var hasSeams = isCarpetMode && seams.length > 0;
  var showControls = isCarpetMode && (hasSeams || seamOffset !== 0);
  controls.classList.toggle("show", showControls);
  var input = document.getElementById("seam-offset-input");
  if (input) input.value = seamOffset.toFixed(1);
}

/** Open the wall picker UI for placing a door or window. */
function openWallPicker(target) {
  wallPickerTarget = target;
  wallPickerWall = null;
  var picker = document.getElementById("wall-picker");
  var label = document.getElementById("wall-picker-label");
  var distRow = document.getElementById("wall-dist-row");
  if (picker) picker.classList.add("show");
  if (label) label.textContent = "Place " + target + " \u2014 select wall:";
  if (distRow) distRow.classList.remove("show");
  document.querySelectorAll(".wall-picker-btn").forEach(function(b) { b.classList.remove("selected"); });
  var distInput = document.getElementById("wall-dist-input");
  if (distInput) distInput.value = "";
}

function closeWallPicker() {
  wallPickerTarget = null;
  wallPickerWall = null;
  var picker = document.getElementById("wall-picker");
  if (picker) picker.classList.remove("show");
  var doorBtn = document.getElementById("door-add-btn");
  var windowBtn = document.getElementById("window-add-btn");
  if (doorBtn) doorBtn.classList.remove("active");
  if (windowBtn) windowBtn.classList.remove("active");
}

function onWallSelected(wall) {
  var w = toNum((currentDimensionRows[0] && currentDimensionRows[0].width) || 0);
  var l = toNum((currentDimensionRows[0] && currentDimensionRows[0].length) || 0);
  var centerPos = (wall === "top" || wall === "bottom") ? w / 2 : l / 2;
  centerPos = Math.round(centerPos * 10) / 10;

  var newIdx;
  if (wallPickerTarget === "door") {
    currentDoorMarkers.push({ wall: wall, positionFt: centerPos });
    newIdx = currentDoorMarkers.length - 1;
  } else {
    currentWindowMarkers.push({ wall: wall, positionFt: centerPos });
    newIdx = currentWindowMarkers.length - 1;
  }

  var markerType = wallPickerTarget;
  closeWallPicker();
  renderRoomDiagram();
  selectMarker(markerType, newIdx);

  var diagramEl = document.getElementById("room-diagram-container");
  if (diagramEl) {
    setTimeout(function() {
      diagramEl.scrollIntoView({ behavior: "smooth", block: "center" });
    }, 150);
  }
}

function confirmWallPlacement() {
  var distInput = document.getElementById("wall-dist-input");
  var distFt = toNum(distInput ? distInput.value : 0);
  if (distFt <= 0) { toast("Enter a distance greater than 0", "error"); return; }
  var w = toNum((currentDimensionRows[0] && currentDimensionRows[0].width) || 0);
  var l = toNum((currentDimensionRows[0] && currentDimensionRows[0].length) || 0);
  var maxDist = (wallPickerWall === "top" || wallPickerWall === "bottom") ? w : l;
  if (distFt > maxDist) { toast("Distance can't exceed wall length (" + maxDist.toFixed(1) + "')", "error"); return; }
  if (wallPickerTarget === "door") { addDoorAtDistance(wallPickerWall, distFt); }
  else { addWindowAtDistance(wallPickerWall, distFt); }
  closeWallPicker();
  var diagramEl = document.getElementById("room-diagram-container");
  if (diagramEl) {
    setTimeout(function() {
      diagramEl.scrollIntoView({ behavior: "smooth", block: "center" });
    }, 150);
  }
}


// -- Dimension Grid ----------------------------------------------------------

/** Render all dimension rows (width  length = SF) in the modal. */
function renderDimensionRows() {
  var container = document.getElementById("dimension-grid");
  if (!container) return;

  var html = "";
  currentDimensionRows.forEach(function(row, idx) {
    var w = toNum(row.width);
    var l = toNum(row.length);
    var sf = w * l;
    var hasValue = w > 0 && l > 0;

    html += '<div class="dimension-row' + (hasValue ? " has-value" : "")
      + '" data-row-idx="' + idx + '">';
    html += '<div class="dimension-input-wrap"><input type="number" class="dimension-input dim-width" placeholder="W"'
      + ' value="' + (row.width || "") + '" inputmode="decimal" step="0.1" min="0">'
      + '<button type="button" class="input-clear-btn" data-clear="width">&times;</button></div>';
    html += '<span class="dimension-x">&times;</span>';
    html += '<div class="dimension-input-wrap"><input type="number" class="dimension-input dim-length" placeholder="L"'
      + ' value="' + (row.length || "") + '" inputmode="decimal" step="0.1" min="0">'
      + '<button type="button" class="input-clear-btn" data-clear="length">&times;</button></div>';
    html += '<span class="dimension-equals">=</span>';
    html += '<span class="dimension-total">' + (hasValue ? sf.toFixed(0) + " SF" : "0 SF") + '</span>';
    if (currentDimensionRows.length > 1) {
      html += '<button type="button" class="dimension-remove" data-row-idx="' + idx + '">&times;</button>';
    }
    html += '</div>';
  });

  container.innerHTML = html;
  bindDimensionRowEvents(container);
}

/**
 * Attach input/focus/remove event listeners to all dimension rows.
 * Includes auto-advance: after typing a value, focus automatically moves
 * to the next field after a brief delay.
 */
function bindDimensionRowEvents(container) {
  container.querySelectorAll(".dimension-row").forEach(function(row) {
    var idx = parseInt(row.dataset.rowIdx);
    var widthInput = row.querySelector(".dim-width");
    var lengthInput = row.querySelector(".dim-length");
    var removeBtn = row.querySelector(".dimension-remove");

    if (widthInput) {
      widthInput.addEventListener("input", function() {
        currentDimensionRows[idx].width = widthInput.value;
        updateDimensionRowTotal(row);
        updateGrandTotal();
        if (isCarpetMode) {
          updateCarpetCalcPreview();
          updateStairsCalc();
        }

	renderRoomDiagram();
        // Auto-advance to length after delay

        clearTimeout(dimensionAutoAdvanceTimer);
        if (widthInput.value !== "") {
          dimensionAutoAdvanceTimer = setTimeout(function() {
            if (lengthInput) { lengthInput.focus(); lengthInput.select(); }
          }, DIMENSION_AUTO_ADVANCE_MS);
        }
      });
      widthInput.addEventListener("focus", function() { clearTimeout(dimensionAutoAdvanceTimer); });
    }

    if (lengthInput) {
      lengthInput.addEventListener("input", function() {
        currentDimensionRows[idx].length = lengthInput.value;
        updateDimensionRowTotal(row);
        updateGrandTotal();
        if (isCarpetMode) {
          updateCarpetCalcPreview();
          updateStairsCalc();
        }
        renderRoomDiagram();
        // If both W and L filled: after 3 seconds scroll to room diagram
        // If next row exists, advance to it instead
        clearTimeout(dimensionAutoAdvanceTimer);
        if (lengthInput.value !== "") {
          var allRows = document.querySelectorAll("#dimension-grid .dimension-row");
          var nextRow = allRows[idx + 1];
          if (nextRow) {
            dimensionAutoAdvanceTimer = setTimeout(function() {
              var nextWidth = nextRow.querySelector(".dim-width");
              if (nextWidth) { nextWidth.focus(); nextWidth.select(); }
            }, DIMENSION_AUTO_ADVANCE_MS);
          } else {
            dimensionAutoAdvanceTimer = setTimeout(function() {
              lengthInput.blur();
              var diagramEl = document.getElementById("room-diagram-section");
              if (diagramEl) {
                diagramEl.scrollIntoView({ behavior: "smooth", block: "start" });
              }
              // After 3 more seconds of no interaction, scroll past diagram
              clearTimeout(diagramIdleScrollTimer);
              diagramIdleScrollTimer = setTimeout(function() {
                var target = document.getElementById("stair-section");
                if (!target || !target.classList.contains("show")) {
                  target = document.getElementById("demo-keywords");
                }
                if (target) {
                  target.scrollIntoView({ behavior: "smooth", block: "start" });
                }
              }, 3000);
            }, 3000);
          }
        }
      });
      lengthInput.addEventListener("focus", function() { clearTimeout(dimensionAutoAdvanceTimer); });
    }

    if (removeBtn) {
      removeBtn.addEventListener("click", function() {
        currentDimensionRows.splice(idx, 1);
        renderDimensionRows();
        updateGrandTotal();
        if (isCarpetMode) {
          updateCarpetCalcPreview();
          updateStairsCalc();
        }
        renderRoomDiagram();
      });
    }

    // Clear buttons
    row.querySelectorAll(".input-clear-btn").forEach(function(clearBtn) {
      clearBtn.addEventListener("click", function(e) {
        e.preventDefault();
        e.stopPropagation();
        var field = clearBtn.dataset.clear;
        if (field === "width" && widthInput) {
          widthInput.value = "";
          currentDimensionRows[idx].width = "";
        } else if (field === "length" && lengthInput) {
          lengthInput.value = "";
          currentDimensionRows[idx].length = "";
        }
        updateDimensionRowTotal(row);
        updateGrandTotal();
        if (isCarpetMode) {
          updateCarpetCalcPreview();
          updateStairsCalc();
        }
	renderRoomDiagram();
      });
    });
  });
}

/**
 * Update the SF total display for a single dimension row.
 * @param {HTMLElement} rowEl
 */
function updateDimensionRowTotal(rowEl) {
  var wEl = rowEl.querySelector(".dim-width");
  var lEl = rowEl.querySelector(".dim-length");
  var w = toNum(wEl ? wEl.value : 0);
  var l = toNum(lEl ? lEl.value : 0);
  var sf = w * l;
  var hasValue = w > 0 && l > 0;

  rowEl.classList.toggle("has-value", hasValue);
  var totalEl = rowEl.querySelector(".dimension-total");
  if (totalEl) totalEl.textContent = hasValue ? sf.toFixed(0) + " SF" : "0 SF";

  // Toggle "has dimensions" class on product reminder for visual feedback
  var reminder = document.getElementById("measure-product-reminder");
  if (reminder) reminder.classList.toggle("has-dimensions", hasValue);
}

/** Recalculate and display the grand total SF for all dimension rows. */
function updateGrandTotal() {
  var total = 0;
  currentDimensionRows.forEach(function(row) {
    var w = toNum(row.width);
    var l = toNum(row.length);
    if (w > 0 && l > 0) total += w * l;
  });

  var el = document.getElementById("grand-total-sf");
  if (el) el.textContent = Math.round(total) + " SF";
}

/** Add a new empty dimension row and focus its width input. */
function addDimensionRow() {
  currentDimensionRows.push({ width: "", length: "" });
  renderDimensionRows();

  var container = document.getElementById("dimension-grid");
  if (container) {
    var rows = container.querySelectorAll(".dimension-row");
    if (rows.length > 0) {
      var lastWidth = rows[rows.length - 1].querySelector(".dim-width");
      if (lastWidth) lastWidth.focus();
    }
  }
}

// -- Photo Thumbnails --------------------------------------------------------

/** Render photo thumbnails inside the measurement modal. */
function renderPhotoThumbnails() {
  var container = document.getElementById("photo-thumbnails");
  var captureBtn = document.getElementById("photo-capture-btn");
  if (!container) return;

  var html = "";
  currentRoomPhotos.forEach(function(photo, idx) {
    html += '<div class="photo-thumbnail" data-photo-idx="' + idx + '">';
    html += '<img src="' + photo.data + '" alt="Photo ' + (idx + 1) + '">';
    html += '<button type="button" class="photo-thumbnail-remove" data-photo-idx="'
      + idx + '">&times;</button>';
    html += '</div>';
  });
  container.innerHTML = html;

  if (captureBtn) captureBtn.disabled = currentRoomPhotos.length >= MAX_PHOTOS_PER_ROOM;

  container.querySelectorAll(".photo-thumbnail-remove").forEach(function(btn) {
    btn.addEventListener("click", function(e) {
      e.preventDefault();
      e.stopPropagation();
      currentRoomPhotos.splice(parseInt(btn.dataset.photoIdx), 1);
      renderPhotoThumbnails();
    });
  });
}

// -- Save Measurements -------------------------------------------------------

/**
 * Save all current modal data into `roomMeasurements` for the active room,
 * then close the modal and update the UI.
 */
function saveMeasurements() {
  if (!currentMeasureRoom) return;

  // Validate demo type is selected (required)
  var demoEl = document.getElementById("demo-keywords");
  if (demoEl && demoEl.parentElement.style.display !== "none"
      && !demoEl.querySelector(".demo-keyword.selected")) {
    demoEl.classList.add("highlight-required");
    demoEl.scrollIntoView({ behavior: "smooth", block: "center" });
    setTimeout(function() { demoEl.classList.remove("highlight-required"); }, 2000);
    toast("Please select an existing floor type", "error");
    return;
  }

  var savedId = currentMeasureRoom.id;
  var savedLabel = currentMeasureRoom.label;

  // Calculate total SF from all dimension rows
  var totalSF = 0;
  currentDimensionRows.forEach(function(row) {
    var w = toNum(row.width);
    var l = toNum(row.length);
    if (w > 0 && l > 0) totalSF += w * l;
  });

  // Read demo type selection
  var demoKeywords = document.getElementById("demo-keywords");
  var selectedDemo = null;
  if (demoKeywords) {
    var selected = demoKeywords.querySelector(".demo-keyword.selected");
    if (selected) selectedDemo = selected.dataset.demo;
  }

  // Read molding counts
  var moldings = {};
  document.querySelectorAll(".molding-item").forEach(function(item) {
    var type = item.dataset.molding;
    var valEl = item.querySelector(".molding-value");
    var count = toNum(valEl ? valEl.textContent : 0);
    if (count > 0) moldings[type] = count;
  });

  // Read fixture counts
  var fixtures = {};
  document.querySelectorAll(".counter-row").forEach(function(row) {
    var type = row.dataset.counter;
    var valEl = row.querySelector(".counter-value");
    var count = toNum(valEl ? valEl.textContent : 0);
    if (count > 0) fixtures[type] = count;
  });

  // Notes
  var notesInput = document.getElementById("room-notes-input");
  var notes = notesInput ? notesInput.value.trim() : "";
  
  // Door markers
  var doors = currentDoorMarkers.slice();
  var windows = currentWindowMarkers.slice();

  // Carpet and stair calculations
  var carpetCalc = isCarpetMode ? updateCarpetCalcPreview() : null;
  var stairsCalc = (isCarpetMode || isHardSurfaceStairMode) ? updateStairsCalc() : null;

  var stairsQty = 0;
  var stairsSF = 0;
  currentStairEntries.forEach(function(e) {
    var count = toNum(e.count);
    stairsQty += count;
    if (isHardSurfaceStairMode && count > 0) {
      var widthFt = (toNum(e.width) || DEFAULT_STAIR.WIDTH_IN) / 12;
      var treadFt = (toNum(e.tread) || DEFAULT_STAIR.TREAD_IN) / 12;
      var riserFt = (toNum(e.riser) || DEFAULT_STAIR.RISER_IN) / 12;
      stairsSF += count * widthFt * (treadFt + riserFt);
    }
  });

  // Calculate landing SF
  var landingSF = 0;
  currentLandingEntries.forEach(function(entry) {
    var w = toNum(entry.width);
    var l = toNum(entry.length);
    if (w > 0 && l > 0) landingSF += w * l;
  });

  // Persist to state
  roomMeasurements[savedId] = {
    totalSF: totalSF,
    dimensions: JSON.parse(JSON.stringify(currentDimensionRows)),
    demoType: selectedDemo,
    moldings: moldings,
    fixtures: fixtures,
    notes: notes,
    photos: JSON.parse(JSON.stringify(currentRoomPhotos)),
    carpetDirection: currentCarpetDirection,
    carpetCalc: carpetCalc,
    stairEntries: JSON.parse(JSON.stringify(currentStairEntries)),
    landingEntries: JSON.parse(JSON.stringify(currentLandingEntries)),
    stairsCalc: stairsCalc,
    stairsQty: stairsQty,
    stairsSF: stairsSF + landingSF,
    stairDemoType: currentStairDemoType,
    doors: doors,
    windows: windows,
    seamOffset: seamOffset
  };

  closeMeasureModal();
  updatePillStates();
  renderSelectedAreas();
  updateMeasureSummary();
  toast("Measurements saved for " + savedLabel, "success");
  
  // Update carpet diagram if in carpet mode and have multiple rooms
  if (isCarpetMode && selectedAreas.length >= 1) {
    showCarpetDiagram();
  }
}

/** Close the measurement modal and reset temporary state. */
function closeMeasureModal() {
  var modal = document.getElementById("measure-modal");
  if (modal) modal.classList.remove("show");
  currentMeasureRoom = null;
}

  
/* =============================================================================
 * 9. CARPET CALCULATIONS
 * =============================================================================
 * Carpet-specific logic: yardage, strips, pattern matching, pad quantity.
 * ========================================================================== */

/**
 * Update carpet mode state based on the current primary item.
 * Enables/disables carpet UI elements and sets carpet parameters.
 */
function updateCarpetMode() {
  if (currentPrimaryItem && isCarpetCategory(currentPrimaryItem.category)) {
    isCarpetMode = true;
    carpetWidth = toNum(currentPrimaryItem.carpetWidth) || DEFAULT_CARPET_WIDTH_FT;
    patternMatchWidth = toNum(currentPrimaryItem.patternMatchWidth) || 0;
    patternMatchLength = toNum(currentPrimaryItem.patternMatchLength) || 0;

    var carpetInfoCard = document.getElementById("carpet-info-card");
    if (carpetInfoCard) carpetInfoCard.classList.add("show");

    // Sync input fields
    var widthFtInput = document.getElementById("carpet-width-ft-input");
    var widthInInput = document.getElementById("carpet-width-in-input");
    var pmWidthInput = document.getElementById("carpet-pm-width-input");
    var pmLengthInput = document.getElementById("carpet-pm-length-input");
    // Split decimal feet into feet and inches for display
    var wholeFt = Math.floor(carpetWidth);
    var remainIn = Math.round((carpetWidth - wholeFt) * 12);
    if (widthFtInput) widthFtInput.value = wholeFt;
    if (widthInInput) widthInInput.value = remainIn;
    if (pmWidthInput) pmWidthInput.value = patternMatchWidth;
    if (pmLengthInput) pmLengthInput.value = patternMatchLength;
    var seamInput = document.getElementById("carpet-seam-allowance-input");
    if (seamInput) seamInput.value = SEAM_ALLOWANCE_IN;  } else {
    isCarpetMode = false;
    carpetWidth = DEFAULT_CARPET_WIDTH_FT;
    patternMatchWidth = 0;
    patternMatchLength = 0;

    var carpetInfoCard2 = document.getElementById("carpet-info-card");
    if (carpetInfoCard2) carpetInfoCard2.classList.remove("show");
  }

  // Toggle SY stat visibility
  var syStat = document.getElementById("total-sy-stat");
  if (syStat) syStat.style.display = isCarpetMode ? "block" : "none";
}

/**
 * Calculate carpet yardage for a single room.
 *
 * The calculation determines how many carpet strips are needed to cover
 * the room, accounting for carpet roll width and pattern match requirements.
 *
 * @param {number} roomWidth - Room width in feet
 * @param {number} roomLength - Room length in feet
 * @param {"lengthwise"|"widthwise"} direction - Carpet roll orientation
 * @returns {{ strips, cutLength, linearFeet, squareFeet, squareYards, formula }}
 */

  function removeDoorMarker(index) {
    if (doorPlacementMode) return;
    currentDoorMarkers.splice(index, 1);
    renderRoomDiagram();
    showToast('Door removed');
  }

function calculateCarpetYardage(roomWidth, roomLength, direction) {
  if (!direction) direction = "lengthwise";
  if (!roomWidth || !roomLength || roomWidth <= 0 || roomLength <= 0) {
    return { strips: 0, cutLength: 0, linearFeet: 0, squareFeet: 0, squareYards: 0, formula: "" };
  }

  var pmLengthFeet = patternMatchLength / 12; // Convert pattern match from inches to feet

  // Determine which room dimension the carpet rolls span vs. run along
  var widthToCover, lengthOfCut;
  if (direction === "lengthwise") {
    widthToCover = roomWidth;
    lengthOfCut = roomLength;
  } else {
    widthToCover = roomLength;
    lengthOfCut = roomWidth;
  }

  // Number of strips needed to cover the width
  var strips = Math.ceil(widthToCover / carpetWidth);

  // First strip is just the cut length; subsequent strips add pattern match
  var firstStripLength = lengthOfCut;
  var subsequentStripLength = lengthOfCut + pmLengthFeet;
  var subsequentStrips = Math.max(0, strips - 1);

  var linearFeet = firstStripLength + (subsequentStrips * subsequentStripLength);
  var squareFeet = linearFeet * carpetWidth;
  var squareYards = squareFeet / 9;

  // Build human-readable formula
  var formula = "";
  if (strips === 1) {
    formula = "1 strip @ " + lengthOfCut.toFixed(1) + "' cut";
  } else if (pmLengthFeet > 0) {
    formula = strips + " strips: 1 @ " + lengthOfCut.toFixed(1)
      + "' + " + subsequentStrips + " @ " + subsequentStripLength.toFixed(1)
      + "' (incl " + pmLengthFeet.toFixed(1) + "' PM)";
  } else {
    formula = strips + " strips @ " + lengthOfCut.toFixed(1) + "' cut";
  }
  formula += " @ " + toNum(carpetWidth).toFixed(3) + "' wide = " + linearFeet.toFixed(1)
    + " LF = " + squareYards.toFixed(2) + " SY";

  return { strips: strips, cutLength: subsequentStripLength, linearFeet: linearFeet, squareFeet: squareFeet, squareYards: squareYards, formula: formula };
}

/**
 * Calculate total carpet yardage across all selected/measured rooms.
 * @returns {{ totalStrips, totalLinearFeet, totalSquareYards, totalStairsSquareYards, grandTotalSquareYards }}
 */
function calculateTotalCarpetYardage() {
  var totalStrips = 0, totalLinearFeet = 0, totalSquareYards = 0, totalStairsSquareYards = 0;

  selectedAreas.forEach(function(area) {
    var m = roomMeasurements[area.id];
    if (!m) return;
    if (m.carpetCalc) {
      totalStrips += m.carpetCalc.strips || 0;
      totalLinearFeet += m.carpetCalc.linearFeet || 0;
      totalSquareYards += m.carpetCalc.squareYards || 0;
    }
    if (m.stairsCalc && m.stairsCalc.squareYards > 0) {
      totalStairsSquareYards += m.stairsCalc.squareYards;
    }
  });

  return {
    totalStrips: totalStrips,
    totalLinearFeet: totalLinearFeet,
    totalSquareYards: totalSquareYards,
    totalStairsSquareYards: totalStairsSquareYards,
    grandTotalSquareYards: totalSquareYards + totalStairsSquareYards
  };
}

/* =============================================================================
 * 9b. CARPET CUTTING OPTIMIZER
 * =============================================================================
 * Optimizes carpet cuts across multiple rooms, utilizing waste and tracking
 * pattern match alignment.
 * ========================================================================== */

/**
 * Main optimizer function - calculates optimal cutting plan for all rooms.
 * @param {string} [forceDirection] - Optional direction override for all rooms
 * @returns {Object} Complete cutting plan with cuts, leftovers, and totals
 */
function optimizeCarpetCutting(forceDirection) {
  if (!isCarpetMode || selectedAreas.length === 0) return null;

  var seamAllowanceFt = SEAM_ALLOWANCE_IN / 12;
  var pmLengthFt = patternMatchLength / 12;
  
  // Gather all room requirements
  var requirements = [];
  selectedAreas.forEach(function(area) {
    var m = roomMeasurements[area.id];
    if (!m || !m.dimensions) return;
    
    // Find max dimensions for this room
    var maxWidth = 0, maxLength = 0;
    m.dimensions.forEach(function(d) {
      var w = toNum(d.width);
      var l = toNum(d.length);
      if (w > maxWidth) maxWidth = w;
      if (l > maxLength) maxLength = l;
    });
    
    if (maxWidth > 0 && maxLength > 0) {
      var dir = forceDirection || m.carpetDirection || "lengthwise";
      requirements.push({
        roomId: area.id,
        roomName: area.closetLabel ? area.label + " " + area.closetLabel : area.label,
        width: maxWidth,
        length: maxLength,
        direction: dir,
        totalSF: m.totalSF || (maxWidth * maxLength),
        isStair: false
      });
    }
    
    // Add stair requirements
    if (m.stairEntries) {
      m.stairEntries.forEach(function(se, idx) {
        var count = toNum(se.count);
        if (count > 0) {
          var widthIn = toNum(se.width) || DEFAULT_STAIR.WIDTH_IN;
          var treadIn = toNum(se.tread) || DEFAULT_STAIR.TREAD_IN;
          var riserIn = toNum(se.riser) || DEFAULT_STAIR.RISER_IN;
          requirements.push({
            roomId: area.id + "_stairs_" + idx,
            roomName: area.label + " Stairs",
            stairCount: count,
            stairWidthIn: widthIn,
            stairTreadIn: treadIn,
            stairRiserIn: riserIn,
            stairPieceFt: (treadIn + riserIn) / 12,
            stairWidthFt: widthIn / 12,
            isStair: true
          });
        }
      });
    }
  });
  
  if (requirements.length === 0) return null;
  
  // Try different room orderings and pick best
  var bestPlan = null;
  var bestWaste = Infinity;
  
  // Sorting strategies to try
  var strategies = [
    { name: "Largest First", sort: function(a, b) { return (b.totalSF || 0) - (a.totalSF || 0); } },
    { name: "Smallest First", sort: function(a, b) { return (a.totalSF || 0) - (b.totalSF || 0); } },
    { name: "Widest First", sort: function(a, b) { return (b.width || 0) - (a.width || 0); } },
    { name: "Longest First", sort: function(a, b) { return (b.length || 0) - (a.length || 0); } },
    { name: "Rooms then Stairs", sort: function(a, b) { return (a.isStair ? 1 : 0) - (b.isStair ? 1 : 0); } },
    { name: "Generate then Reuse", sort: function(a, b) {
      // Large rooms first (generate leftovers from multi-strip cuts)
      // Small rooms/closets next (fit inside leftovers)
      // Stairs last (fit in smallest scraps)
      var aGroup = a.isStair ? 2 : ((a.width || 0) <= carpetWidth && (a.length || 0) <= carpetWidth ? 1 : 0);
      var bGroup = b.isStair ? 2 : ((b.width || 0) <= carpetWidth && (b.length || 0) <= carpetWidth ? 1 : 0);
      if (aGroup !== bGroup) return aGroup - bGroup;
      return (b.totalSF || 0) - (a.totalSF || 0);
    }}
  ];
  
  strategies.forEach(function(strategy) {
    var sortedReqs = requirements.slice().sort(strategy.sort);
    var plan = calculateCuttingPlan(sortedReqs, seamAllowanceFt, pmLengthFt);
    plan.strategyName = strategy.name;
    
    if (plan.totalLinearFt < bestWaste) {
      bestWaste = plan.totalLinearFt;
      bestPlan = plan;
    }
  });
  
  carpetCuttingPlan = bestPlan;
  return bestPlan;
}

/**
 * Calculate a cutting plan for a specific room ordering.
 * @param {Array} requirements - Ordered array of room requirements
 * @param {number} seamAllowanceFt - Seam allowance in feet
 * @param {number} pmLengthFt - Pattern match length in feet
 * @returns {Object} Cutting plan
 */
function calculateCuttingPlan(requirements, seamAllowanceFt, pmLengthFt) {
  var plan = {
    cuts: [],
    leftovers: [],
    totalLinearFt: 0,
    totalSY: 0,
    totalWasteSY: 0,
    usedFromLeftovers: 0,
    roomDetails: {}
  };
  
  var leftovers = []; // { width, length, patternPos, source }
  var runningLF = 0;
  var patternPos = 0; // Track pattern position along the roll
  
  requirements.forEach(function(req) {
    if (req.isStair) {
      // Handle stair cuts
      var stairResult = cutStairsFromInventory(req, leftovers, seamAllowanceFt, pmLengthFt, patternPos);
      plan.cuts = plan.cuts.concat(stairResult.cuts);
      leftovers = stairResult.remainingLeftovers;
      runningLF += stairResult.newLinearFt;
      patternPos = stairResult.patternPos;
      plan.usedFromLeftovers += stairResult.usedFromLeftover;
      
      plan.roomDetails[req.roomId] = {
        roomName: req.roomName,
        isStair: true,
        stairCount: req.stairCount,
        cuts: stairResult.cuts,
        fromLeftover: stairResult.usedFromLeftover,
        newCarpetLF: stairResult.newLinearFt,
        totalSY: stairResult.totalSY
      };
    } else {
      // Handle room cuts
      var roomResult = cutRoomFromInventory(req, leftovers, seamAllowanceFt, pmLengthFt, patternPos);
      plan.cuts = plan.cuts.concat(roomResult.cuts);
      leftovers = roomResult.remainingLeftovers;
      runningLF += roomResult.newLinearFt;
      patternPos = roomResult.patternPos;
      plan.usedFromLeftovers += roomResult.usedFromLeftover;
      
      plan.roomDetails[req.roomId] = {
        roomName: req.roomName,
        isStair: false,
        width: req.width,
        length: req.length,
        direction: req.direction,
        strips: roomResult.cuts.length,
        cuts: roomResult.cuts,
        fromLeftover: roomResult.usedFromLeftover,
        newCarpetLF: roomResult.newLinearFt,
        totalSY: roomResult.totalSY
      };
    }
  });
  
  plan.totalLinearFt = runningLF;
  plan.totalSY = (runningLF * carpetWidth) / 9;
  plan.leftovers = leftovers.filter(function(l) {
    return l.width >= MIN_LEFTOVER_DIM_FT && l.length >= MIN_LEFTOVER_DIM_FT;
  });
  
  // Calculate waste (leftover pieces too small to use)
  var usableLeftoverSF = 0;
  plan.leftovers.forEach(function(l) { usableLeftoverSF += l.width * l.length; });
  
  var totalCutSF = runningLF * carpetWidth;
  var totalNeededSF = 0;
  requirements.forEach(function(r) {
    if (r.isStair) {
      totalNeededSF += r.stairCount * r.stairWidthFt * r.stairPieceFt;
    } else {
      totalNeededSF += r.totalSF || (r.width * r.length);
    }
  });
  
  plan.totalWasteSY = Math.max(0, (totalCutSF - totalNeededSF - usableLeftoverSF)) / 9;
  plan.usableLeftoverSY = usableLeftoverSF / 9;
  
  return plan;
}

/**
 * Cut room strips, utilizing leftovers when possible.
 */
function cutRoomFromInventory(req, leftovers, seamAllowanceFt, pmLengthFt, patternPos) {
  var result = {
    cuts: [],
    remainingLeftovers: leftovers.slice(),
    newLinearFt: 0,
    usedFromLeftover: 0,
    totalSY: 0,
    patternPos: patternPos
  };
  
  var widthToCover, cutLength;
  if (req.direction === "lengthwise") {
    widthToCover = req.width;
    cutLength = req.length;
  } else {
    widthToCover = req.length;
    cutLength = req.width;
  }
  
  var stripsNeeded = Math.ceil(widthToCover / carpetWidth);
  var leftoverWidthFromStrips = (stripsNeeded * carpetWidth) - widthToCover;
  
  // &#9472;&#9472; Check if entire room fits inside a leftover piece &#9472;&#9472;
  // Small rooms and closets can often be cut from leftover strips
  // generated by larger rooms, avoiding new roll consumption.
  // Uses best-fit selection to preserve larger leftovers for bigger rooms.
  var cutLengthBase = cutLength + seamAllowanceFt;
  var usedLeftoverForWholeRoom = false;
  
  var bestFitIdx = -1;
  var bestFitArea = Infinity;
  
  for (var li = 0; li < result.remainingLeftovers.length; li++) {
    var lo = result.remainingLeftovers[li];
    // Leftover must be wide enough for room AND long enough for cut
    if (lo.width >= widthToCover && lo.length >= cutLengthBase) {
      // Check pattern alignment for patterned carpet
      var patternOK = true;
      if (pmLengthFt > 0) {
        var patternOffset = (result.patternPos - lo.patternPos) % pmLengthFt;
        patternOK = patternOffset < 0.1 || (pmLengthFt - patternOffset) < 0.1;
      }
      if (!patternOK) continue;
      
      // Track smallest sufficient leftover (best fit to minimize waste)
      var loArea = lo.width * lo.length;
      if (loArea < bestFitArea) {
        bestFitArea = loArea;
        bestFitIdx = li;
      }
    }
  }
  
  if (bestFitIdx >= 0) {
    var bestLo = result.remainingLeftovers[bestFitIdx];
    
    var leftoverCut = {
      roomId: req.roomId,
      roomName: req.roomName,
      stripNumber: 1,
      cutLength: cutLengthBase,
      cutWidth: widthToCover,
      seamAllowance: seamAllowanceFt,
      patternMatch: 0,
      fromLeftover: true,
      leftoverSource: bestLo.source
    };
    result.cuts.push(leftoverCut);
    result.usedFromLeftover++;
    
    // Split remaining leftover into up to 2 usable sub-pieces
    var remLength = bestLo.length - cutLengthBase;
    var remWidth = bestLo.width - widthToCover;
    var savedPatternPos = bestLo.patternPos;
    var savedSource = bestLo.source;
    var savedLoWidth = bestLo.width;
    result.remainingLeftovers.splice(bestFitIdx, 1);
    
    // Sub-piece A: below the room (full leftover width  remaining length)
    if (remLength >= MIN_LEFTOVER_DIM_FT && savedLoWidth >= MIN_LEFTOVER_DIM_FT) {
      result.remainingLeftovers.push({
        width: savedLoWidth,
        length: remLength,
        patternPos: savedPatternPos + cutLengthBase,
        source: savedSource + " (after " + req.roomName + ")"
      });
    }
    // Sub-piece B: beside the room (remaining width  room cut length)
    if (remWidth >= MIN_LEFTOVER_DIM_FT && cutLengthBase >= MIN_LEFTOVER_DIM_FT) {
      result.remainingLeftovers.push({
        width: remWidth,
        length: cutLengthBase,
        patternPos: savedPatternPos,
        source: savedSource + " (beside " + req.roomName + ")"
      });
    }
    
    usedLeftoverForWholeRoom = true;
  }
  
  // If room was fully cut from leftover, skip the strip loop
  if (usedLeftoverForWholeRoom) {
    result.totalSY = 0; // No new carpet consumed
    return result;
  }
  
  for (var s = 0; s < stripsNeeded; s++) {
    var isFirstStrip = (s === 0);
    var stripLength = cutLength + seamAllowanceFt;
    if (!isFirstStrip && pmLengthFt > 0) {
      stripLength += pmLengthFt; // Add pattern match for subsequent strips
    }
    
    // Check if any leftover can satisfy this strip
    var usedLeftover = null;
    var leftoverIdx = -1;
    
    for (var li = 0; li < result.remainingLeftovers.length; li++) {
      var lo = result.remainingLeftovers[li];
      // Check if leftover is big enough and pattern aligns
      if (lo.width >= carpetWidth && lo.length >= stripLength) {
        var patternOK = true;
        if (pmLengthFt > 0 && !isFirstStrip) {
          // Check pattern alignment
          var patternOffset = (result.patternPos - lo.patternPos) % pmLengthFt;
          patternOK = patternOffset < 0.1 || (pmLengthFt - patternOffset) < 0.1;
        }
        if (patternOK) {
          usedLeftover = lo;
          leftoverIdx = li;
          break;
        }
      }
    }
    
    // Determine this strip's actual coverage width
    var isLastStrip = (s === stripsNeeded - 1);
    var stripCoverWidth = isLastStrip ? (widthToCover - (s * carpetWidth)) : carpetWidth;
    var isFillStrip = stripCoverWidth < carpetWidth;
    
    var cut = {
      roomId: req.roomId,
      roomName: req.roomName,
      stripNumber: s + 1,
      cutLength: stripLength,
      cutWidth: carpetWidth,
      coverWidth: stripCoverWidth,
      seamAllowance: seamAllowanceFt,
      patternMatch: (!isFirstStrip && pmLengthFt > 0) ? pmLengthFt : 0,
      fromLeftover: !!usedLeftover,
      leftoverSource: usedLeftover ? usedLeftover.source : null,
      isFillStrip: isFillStrip,
      // Tier 1: Fill strip always at far wall (away from entrance)
      placement: isFillStrip ? "far wall" : "from entrance",
      distanceFromEntrance: isFillStrip
        ? (widthToCover - stripCoverWidth)
        : (s * carpetWidth)
    };
    
    if (usedLeftover) {
      // Use from leftover
      result.usedFromLeftover++;
      
      // Update or remove the leftover
      var remainingLength = usedLeftover.length - stripLength;
      if (remainingLength >= MIN_LEFTOVER_DIM_FT) {
        result.remainingLeftovers[leftoverIdx].length = remainingLength;
      } else {
        result.remainingLeftovers.splice(leftoverIdx, 1);
      }
    } else {
      // Cut from new roll
      result.newLinearFt += stripLength;
      result.patternPos += stripLength;
      
      // Generate leftover from width if this is the last strip
      if (s === stripsNeeded - 1 && leftoverWidthFromStrips >= MIN_LEFTOVER_DIM_FT) {
        result.remainingLeftovers.push({
          width: leftoverWidthFromStrips,
          length: stripLength,
          patternPos: result.patternPos - stripLength,
          source: req.roomName + " Strip " + (s + 1)
        });
      }
    }
    
    result.cuts.push(cut);
  }
  
  result.totalSY = (result.newLinearFt * carpetWidth) / 9;
  
  // &#9472;&#9472; Door-seam conflict detection &#9472;&#9472;
  result.doorConflicts = [];
  var roomDoors = (roomMeasurements[req.roomId] && roomMeasurements[req.roomId].doors) || [];
  if (roomDoors.length > 0) {
    var conflictWalls = (req.direction === "lengthwise") ? ["top", "bottom"] : ["left", "right"];
    for (var di = 0; di < roomDoors.length; di++) {
      var door = roomDoors[di];
      if (conflictWalls.indexOf(door.wall) === -1) continue;
      var doorFt = door.positionFt;
      for (var sb = 1; sb < stripsNeeded; sb++) {
        var seamFt = sb * carpetWidth;
        if (Math.abs(seamFt - doorFt) <= DOOR_SEAM_BUFFER_FT) {
          result.doorConflicts.push({ doorWall: door.wall, doorPositionFt: doorFt, seamNumber: sb, seamPositionFt: seamFt });
        }
      }
    }
  }
  
  return result;
}
  
/**
 * Cut stairs from inventory, utilizing leftovers first.
 */
function cutStairsFromInventory(req, leftovers, seamAllowanceFt, pmLengthFt, patternPos) {
  var result = {
    cuts: [],
    remainingLeftovers: leftovers.slice(),
    newLinearFt: 0,
    usedFromLeftover: 0,
    totalSY: 0,
    patternPos: patternPos
  };
  
  var stairWidthFt = req.stairWidthFt;
  var stairPieceFt = req.stairPieceFt + (seamAllowanceFt / 2); // Half seam allowance per piece
  var remainingStairs = req.stairCount;
  
  // First, try to use leftovers
  for (var li = result.remainingLeftovers.length - 1; li >= 0 && remainingStairs > 0; li--) {
    var lo = result.remainingLeftovers[li];
    
    // How many stairs fit in this leftover?
    var stairsAcross = Math.floor(lo.width / stairWidthFt);
    var stairsDeep = Math.floor(lo.length / stairPieceFt);
    var stairsFit = stairsAcross * stairsDeep;
    
    if (stairsFit > 0) {
      var stairsToUse = Math.min(stairsFit, remainingStairs);
      
      result.cuts.push({
        roomId: req.roomId,
        roomName: req.roomName,
        isStair: true,
        stairCount: stairsToUse,
        fromLeftover: true,
        leftoverSource: lo.source,
        layout: stairsAcross + " across x " + Math.ceil(stairsToUse / stairsAcross) + " deep",
        stairWidthIn: req.stairWidthIn,
        stairTreadIn: req.stairTreadIn,
        stairRiserIn: req.stairRiserIn
      });
      
      result.usedFromLeftover += stairsToUse;
      remainingStairs -= stairsToUse;
      
      // Update leftover
      var rowsUsed = Math.ceil(stairsToUse / stairsAcross);
      var lengthUsed = rowsUsed * stairPieceFt;
      lo.length -= lengthUsed;
      
      if (lo.length < MIN_LEFTOVER_DIM_FT || lo.width < MIN_LEFTOVER_DIM_FT) {
        result.remainingLeftovers.splice(li, 1);
      }
    }
  }
  
  // Cut remaining stairs from new carpet
  if (remainingStairs > 0) {
    var stairsPerRow = Math.floor(carpetWidth / stairWidthFt);
    if (stairsPerRow < 1) stairsPerRow = 1;
    var rowsNeeded = Math.ceil(remainingStairs / stairsPerRow);
    var newLF = rowsNeeded * stairPieceFt;
    
    result.cuts.push({
      roomId: req.roomId,
      roomName: req.roomName,
      isStair: true,
      stairCount: remainingStairs,
      fromLeftover: false,
      cutLength: newLF,
      cutWidth: carpetWidth,
      layout: stairsPerRow + " across x " + rowsNeeded + " rows",
      stairWidthIn: req.stairWidthIn,
      stairTreadIn: req.stairTreadIn,
      stairRiserIn: req.stairRiserIn
    });
    
    result.newLinearFt += newLF;
    result.patternPos += newLF;
    
    // Generate leftover from unused width
    var usedWidth = stairsPerRow * stairWidthFt;
    var leftoverWidth = carpetWidth - usedWidth;
    if (leftoverWidth >= MIN_LEFTOVER_DIM_FT) {
      result.remainingLeftovers.push({
        width: leftoverWidth,
        length: newLF,
        patternPos: result.patternPos - newLF,
        source: req.roomName
      });
    }
  }
  
  result.totalSY = (result.newLinearFt * carpetWidth) / 9;
  return result;
}

/**
 * Recalculate the cutting plan (called when user clicks refresh).
 * @param {string} [forceDirection] - Optional direction override
 */
function recalculateCarpetPlan(forceDirection) {
  var plan = optimizeCarpetCutting(forceDirection);
  if (plan) {
    currentOptimizedPlan = plan;
    renderCarpetCuttingDiagram(plan);
    updateCarpetPlanSummary(plan);
    
    // &#9472;&#9472; Push optimized quantities to bid items &#9472;&#9472;
    var primaryQtyEl = document.getElementById("primary-qty");
    var gridQtyEl = document.getElementById("primary-item-qty-grid");
    var qtySourceEl = document.getElementById("qty-source");
    
    // Update primary quantity with optimized SY
    if (primaryQtyEl) primaryQtyEl.value = plan.totalSY.toFixed(2);
    if (gridQtyEl) gridQtyEl.value = plan.totalSY.toFixed(2);
    
    // Update source description with optimized numbers
    var measuredCount = 0;
    selectedAreas.forEach(function(area) {
      var m = roomMeasurements[area.id];
      if (m && m.totalSF > 0) measuredCount++;
    });
    if (qtySourceEl) {
      qtySourceEl.textContent = "From " + measuredCount + " measured room"
        + (measuredCount !== 1 ? "s" : "") + " ("
        + plan.cuts.length + " cuts, "
        + plan.totalLinearFt.toFixed(0) + " LF)";
    }
    
    // Update carpet summary row in Step 2 header
    var syEl = document.getElementById("carpet-total-sy");
    var cutsEl = document.getElementById("carpet-total-cuts");
    var lfEl = document.getElementById("carpet-total-lf");
    var totalSyEl = document.getElementById("total-carpet-sy");
    if (syEl) syEl.textContent = plan.totalSY.toFixed(2);
    if (cutsEl) cutsEl.textContent = plan.cuts.length;
    if (lfEl) lfEl.textContent = plan.totalLinearFt.toFixed(0);
    if (totalSyEl) totalSyEl.textContent = plan.totalSY.toFixed(2);
  }
  return plan;
}

/* =============================================================================
 * 9c. CARPET CUTTING DIAGRAM
 * =============================================================================
 * Visual SVG diagram showing the cutting layout.
 * ========================================================================== */

/**
 * Render the carpet cutting diagram as an SVG.
 * @param {Object} plan - The cutting plan from the optimizer
 */
function renderCarpetCuttingDiagram(plan) {
  var container = document.getElementById("carpet-diagram-container");
  if (!container) return;
  
  if (!plan || !plan.cuts || plan.cuts.length === 0) {
    container.innerHTML = '<div class="empty-state">No cuts to display</div>';
    return;
  }
  
  var SCALE = 10; // pixels per foot
  var PADDING = 20;
  var ROW_GAP = 16;
  var LABEL_HEIGHT = 22;
  var MIN_WIDTH = 340;
  
  var rollWidthPx = carpetWidth * SCALE;
  var svgWidth = Math.max(MIN_WIDTH, rollWidthPx + PADDING * 2 + 90);
  
  // Group cuts by type for visualization
  var roomCuts = [];
  var stairCuts = [];
  plan.cuts.forEach(function(cut) {
    if (cut.isStair) {
      stairCuts.push(cut);
    } else {
      roomCuts.push(cut);
    }
  });
  
  // Calculate total height needed
  var totalHeight = PADDING + 70; // Header + roll width indicator
  
  roomCuts.forEach(function(cut) {
    var heightPx = Math.max(cut.cutLength * SCALE, 50); // Minimum height for visibility
    totalHeight += heightPx + ROW_GAP;
  });
  
  // Add space for stairs section
  if (stairCuts.length > 0) {
    var stairHeight = 80; // Base height for stairs section
    stairCuts.forEach(function(cut) {
      if (!cut.fromLeftover && cut.cutLength) {
        stairHeight += Math.max(cut.cutLength * SCALE, 40) + 10;
      }
    });
    totalHeight += stairHeight + 30; // Extra for label
  }
  
  totalHeight += 50; // Legend space
  
  var svgHeight = totalHeight;
  
  // Room colors
  var roomColors = [
    '#818cf8', '#a78bfa', '#c084fc', '#e879f9', '#f472b6',
    '#fb7185', '#f87171', '#fb923c', '#fbbf24', '#a3e635',
    '#4ade80', '#34d399', '#2dd4bf', '#22d3ee', '#38bdf8'
  ];
  var roomColorMap = {};
  var colorIdx = 0;
  
  // Build SVG
  var svg = '<svg width="' + svgWidth + '" height="' + svgHeight + '" xmlns="http://www.w3.org/2000/svg" style="font-family: system-ui, sans-serif;">';
  
  // Background
  svg += '<rect x="0" y="0" width="' + svgWidth + '" height="' + svgHeight + '" fill="#f9fafb"/>';
  
  // Title
  svg += '<text x="' + PADDING + '" y="24" font-size="15" font-weight="bold" fill="#374151">';
  svg += 'CARPET CUTTING DIAGRAM - ' + toFtInStr(carpetWidth) + ' Wide Roll</text>';
  
  // Roll width indicator
  var rollStartX = PADDING;
  var rollStartY = 35;
  svg += '<rect x="' + rollStartX + '" y="' + rollStartY + '" width="' + rollWidthPx + '" height="25" fill="#e5e7eb" stroke="#9ca3af" stroke-width="1" rx="3"/>';
  svg += '<text x="' + (rollStartX + rollWidthPx / 2) + '" y="' + (rollStartY + 17) + '" text-anchor="middle" font-size="13" fill="#6b7280">';
  svg += '&#8592; ' + toFtInStr(carpetWidth) + ' Roll Width &#8594;</text>';
  
  var currentY = rollStartY + 35;
  
  // Draw room cuts
  roomCuts.forEach(function(cut, idx) {
    if (!roomColorMap[cut.roomId]) {
      roomColorMap[cut.roomId] = roomColors[colorIdx % roomColors.length];
      colorIdx++;
    }
    var color = roomColorMap[cut.roomId];
    var heightPx = Math.max(cut.cutLength * SCALE, 50);
    
    // Main cut rectangle
    svg += '<rect x="' + rollStartX + '" y="' + currentY + '" width="' + rollWidthPx + '" height="' + heightPx + '" ';
    svg += 'fill="' + color + '" fill-opacity="0.3" stroke="' + color + '" stroke-width="2" rx="3"/>';
    
    // Room label
    svg += '<text x="' + (rollStartX + 8) + '" y="' + (currentY + 18) + '" font-size="13" font-weight="600" fill="' + color + '">';
    svg += escHtml(cut.roomName) + ' - Strip ' + cut.stripNumber + '</text>';
    
    // Dimensions
    svg += '<text x="' + (rollStartX + 8) + '" y="' + (currentY + 34) + '" font-size="11" fill="#6b7280">';
    svg += cut.cutLength.toFixed(1) + '\' x ' + toFtInStr(carpetWidth);
    if (cut.fromLeftover) svg += ' (from leftover)';
    svg += '</text>';

    // Check if this strip generates leftover that fits stairs
    if (!cut.fromLeftover && stairCuts.length > 0) {
      var cutWidthToCover = 0;
      roomCuts.forEach(function(rc) {
        if (rc.roomId === cut.roomId) {
          var req = null;
          requirements_loop:
          for (var ri = 0; ri < selectedAreas.length; ri++) {
            var rm = roomMeasurements[selectedAreas[ri].id];
            if (rm && selectedAreas[ri].id === cut.roomId) { req = rm; break requirements_loop; }
          }
          if (req) {
            var dir = req.carpetDirection || "lengthwise";
            cutWidthToCover = (dir === "lengthwise") ? toNum((req.dimensions[0] && req.dimensions[0].width) || 0) : toNum((req.dimensions[0] && req.dimensions[0].length) || 0);
          }
        }
      });
      // Only the last strip of a room has leftover
      var isLastStrip = true;
      roomCuts.forEach(function(rc) {
        if (rc.roomId === cut.roomId && rc.stripNumber > cut.stripNumber) isLastStrip = false;
      });
      if (isLastStrip && cutWidthToCover > 0) {
        var strips = Math.ceil(cutWidthToCover / carpetWidth);
        var leftoverW = (strips * carpetWidth) - cutWidthToCover;
        if (leftoverW >= 2) {
          var refStair = stairCuts[0];
          var stairW = (refStair.stairWidthIn || DEFAULT_STAIR.WIDTH_IN) / 12;
          var stairPiece = ((refStair.stairTreadIn || DEFAULT_STAIR.TREAD_IN) + (refStair.stairRiserIn || DEFAULT_STAIR.RISER_IN)) / 12;
          var across = Math.floor(leftoverW / stairW);
          var deep = Math.floor(cut.cutLength / stairPiece);
          var fitsCount = across * deep;
          if (fitsCount > 0) {
            var totalStairsNeeded = 0;
            stairCuts.forEach(function(sc) { totalStairsNeeded += (sc.stairCount || 0); });
            var yieldsCount = Math.min(fitsCount, totalStairsNeeded);
            svg += '<text x="' + (rollStartX + rollWidthPx + 8) + '" y="' + (currentY + heightPx / 2 + 18) + '" font-size="10" font-weight="600" fill="#16a34a">';
            svg += '&#9654; yields ' + yieldsCount + ' steps</text>';
          }
        }
      }
    }
    
    // Pattern match indicator
    if (cut.patternMatch > 0) {
      var pmHeight = Math.min(cut.patternMatch * SCALE, heightPx * 0.3);
      svg += '<rect x="' + rollStartX + '" y="' + (currentY + heightPx - pmHeight) + '" width="' + rollWidthPx + '" height="' + pmHeight + '" ';
      svg += 'fill="#fbbf24" fill-opacity="0.5" stroke="#f59e0b" stroke-width="1" stroke-dasharray="3,2" rx="0 0 3 3"/>';
      svg += '<text x="' + (rollStartX + rollWidthPx - 5) + '" y="' + (currentY + heightPx - pmHeight + 12) + '" text-anchor="end" font-size="8" fill="#92400e">';
      svg += '+' + (cut.patternMatch * 12).toFixed(0) + '" PM</text>';
    }
    
    // Seam allowance indicator (top edge)
    if (cut.seamAllowance > 0) {
      var seamHeight = Math.max(cut.seamAllowance * SCALE, 4);
      svg += '<rect x="' + rollStartX + '" y="' + currentY + '" width="' + rollWidthPx + '" height="' + seamHeight + '" ';
      svg += 'fill="#ef4444" fill-opacity="0.4" rx="3"/>';
    }
    
    // Length label on right
    svg += '<text x="' + (rollStartX + rollWidthPx + 8) + '" y="' + (currentY + heightPx / 2 + 4) + '" font-size="12" font-weight="600" fill="#374151">';
    svg += cut.cutLength.toFixed(1) + '\'</text>';
    
    currentY += heightPx + ROW_GAP;
  });
  
  // Draw stair cuts section
  if (stairCuts.length > 0) {
    currentY += 5;
    
    // Stairs header
    svg += '<text x="' + rollStartX + '" y="' + (currentY + 14) + '" font-size="12" font-weight="700" fill="#15803d">STAIRS</text>';
    currentY += 25;
    
    stairCuts.forEach(function(cut) {
      var color = '#22c55e';
      
     if (cut.fromLeftover) {
        // Show stairs from leftover as a highlighted box
        var boxHeight = 55;
        svg += '<rect x="' + rollStartX + '" y="' + currentY + '" width="' + (rollWidthPx * 0.7) + '" height="' + boxHeight + '" ';
        svg += 'fill="' + color + '" fill-opacity="0.2" stroke="' + color + '" stroke-width="2" stroke-dasharray="5,3" rx="4"/>';
        
        // Stair icon pattern inside
        var stairIconSize = 15;
        var iconsPerRow = Math.floor((rollWidthPx * 0.7 - 20) / (stairIconSize + 5));
        var stairsToShow = Math.min(cut.stairCount, iconsPerRow * 2);
        for (var si = 0; si < stairsToShow; si++) {
          var row = Math.floor(si / iconsPerRow);
          var col = si % iconsPerRow;
          var sx = rollStartX + 10 + col * (stairIconSize + 5);
          var sy = currentY + 8 + row * (stairIconSize + 3);
          svg += '<rect x="' + sx + '" y="' + sy + '" width="' + stairIconSize + '" height="' + stairIconSize + '" fill="' + color + '" fill-opacity="0.4" stroke="' + color + '" rx="2"/>';
        }
        
        // Get stair dimensions from the cut or from current entries
        var stairDimText = '';
        if (cut.stairWidthIn && cut.stairTreadIn && cut.stairRiserIn) {
          stairDimText = cut.stairWidthIn + '"W x ' + (cut.stairTreadIn + cut.stairRiserIn) + '" (' + cut.stairTreadIn + '"T+' + cut.stairRiserIn + '"R)';
        }
        
        // Labels
        svg += '<text x="' + (rollStartX + rollWidthPx * 0.7 + 8) + '" y="' + (currentY + 14) + '" font-size="10" fill="#166534" font-weight="600">';
        svg += cut.stairCount + ' stairs</text>';
        svg += '<text x="' + (rollStartX + rollWidthPx * 0.7 + 8) + '" y="' + (currentY + 28) + '" font-size="9" fill="#166534">';
        svg += 'from leftover</text>';
        if (stairDimText) {
          svg += '<text x="' + (rollStartX + 8) + '" y="' + (currentY + boxHeight - 6) + '" font-size="8" fill="#166534">';
          svg += stairDimText + '</text>';
        }
        
        currentY += boxHeight + 10;
        
      } else if (cut.cutLength) {
        // Stairs cut from new carpet
        var heightPx = Math.max(cut.cutLength * SCALE, 40);
        
        svg += '<rect x="' + rollStartX + '" y="' + currentY + '" width="' + rollWidthPx + '" height="' + heightPx + '" ';
        svg += 'fill="' + color + '" fill-opacity="0.25" stroke="' + color + '" stroke-width="2" rx="3"/>';
        
        // Draw stair grid pattern
        var stairWidthPx = (cut.stairCount > 0 && stairCuts[0]) ? 
          ((stairCuts[0].stairWidthIn || DEFAULT_STAIR.WIDTH_IN) / 12) * SCALE : 20;
        var stairPiecePx = heightPx / Math.ceil(cut.stairCount / Math.floor(rollWidthPx / stairWidthPx));
        
        // Stair dimensions text
        var newStairDimText = '';
        if (cut.stairWidthIn && cut.stairTreadIn && cut.stairRiserIn) {
          newStairDimText = cut.stairWidthIn + '"W x ' + (cut.stairTreadIn + cut.stairRiserIn) + '" (' + cut.stairTreadIn + '"T+' + cut.stairRiserIn + '"R)';
        }
        
        // Simplified stair visualization
        svg += '<text x="' + (rollStartX + 8) + '" y="' + (currentY + 16) + '" font-size="10" font-weight="600" fill="#166534">';
        svg += cut.stairCount + ' stairs (' + cut.layout + ')</text>';
        svg += '<text x="' + (rollStartX + 8) + '" y="' + (currentY + 30) + '" font-size="9" fill="#166534">';
        svg += cut.cutLength.toFixed(1) + '\' LF from new roll</text>';
        if (newStairDimText) {
          svg += '<text x="' + (rollStartX + 8) + '" y="' + (currentY + 44) + '" font-size="8" fill="#166534">';
          svg += newStairDimText + '</text>';
        }
        
        // Length label
        svg += '<text x="' + (rollStartX + rollWidthPx + 8) + '" y="' + (currentY + heightPx / 2 + 4) + '" font-size="10" fill="#374151">';
        svg += cut.cutLength.toFixed(1) + '\'</text>';
        
        currentY += heightPx + 10;
      }
    });
  }
  
  // Legend
  currentY += 15;
  var legendY = currentY;
  
  svg += '<text x="' + rollStartX + '" y="' + legendY + '" font-size="10" font-weight="600" fill="#6b7280">Legend:</text>';
  legendY += 15;
  
  svg += '<rect x="' + rollStartX + '" y="' + (legendY - 10) + '" width="14" height="14" fill="#fbbf24" fill-opacity="0.5" stroke="#f59e0b" rx="2"/>';
  svg += '<text x="' + (rollStartX + 20) + '" y="' + legendY + '" font-size="9" fill="#6b7280">Pattern Match</text>';
  
  svg += '<rect x="' + (rollStartX + 100) + '" y="' + (legendY - 10) + '" width="14" height="14" fill="#ef4444" fill-opacity="0.4" rx="2"/>';
  svg += '<text x="' + (rollStartX + 120) + '" y="' + legendY + '" font-size="9" fill="#6b7280">Seam (' + SEAM_ALLOWANCE_IN + '")</text>';
  
  svg += '<rect x="' + (rollStartX + 200) + '" y="' + (legendY - 10) + '" width="14" height="14" fill="#22c55e" fill-opacity="0.3" stroke="#22c55e" stroke-dasharray="3,2" rx="2"/>';
  svg += '<text x="' + (rollStartX + 220) + '" y="' + legendY + '" font-size="9" fill="#6b7280">From Leftover</text>';
  
  svg += '</svg>';
  
  container.innerHTML = svg;
}

/**
 * Update the carpet plan summary display.
 * @param {Object} plan - The cutting plan
 */
function updateCarpetPlanSummary(plan) {
  var summaryEl = document.getElementById("carpet-plan-summary");
  if (!summaryEl) return;
  
  var html = '<div class="carpet-plan-stats">';
  html += '<div class="plan-stat"><span class="plan-stat-value">' + plan.totalLinearFt.toFixed(1) + '</span><span class="plan-stat-label">Linear Feet</span></div>';
  html += '<div class="plan-stat"><span class="plan-stat-value">' + plan.totalSY.toFixed(2) + '</span><span class="plan-stat-label">Square Yards</span></div>';
  html += '<div class="plan-stat"><span class="plan-stat-value">' + plan.cuts.length + '</span><span class="plan-stat-label">Total Cuts</span></div>';
  html += '<div class="plan-stat highlight"><span class="plan-stat-value">' + plan.usedFromLeftovers + '</span><span class="plan-stat-label">From Leftovers</span></div>';
  html += '</div>';
  
  // Waste summary
  html += '<div class="carpet-plan-waste">';
  html += '<div class="waste-item"><span class="waste-label">Est. Waste:</span><span class="waste-value">' + plan.totalWasteSY.toFixed(2) + ' SY</span></div>';
  html += '<div class="waste-item"><span class="waste-label">Usable Leftovers:</span><span class="waste-value">' + plan.usableLeftoverSY.toFixed(2) + ' SY</span></div>';
  html += '<div class="waste-item"><span class="waste-label">Strategy:</span><span class="waste-value">' + plan.strategyName + '</span></div>';
  html += '</div>';
  
  // Room breakdown
  html += '<div class="carpet-plan-rooms"><div class="plan-rooms-title">Room Breakdown:</div>';
  Object.keys(plan.roomDetails).forEach(function(roomId) {
    var room = plan.roomDetails[roomId];
    html += '<div class="plan-room-row">';
    html += '<span class="plan-room-name">' + escHtml(room.roomName) + '</span>';
    if (room.isStair) {
      html += '<span class="plan-room-detail">' + room.stairCount + ' stairs';
    } else {
      html += '<span class="plan-room-detail">' + room.strips + ' strips, ' + room.newCarpetLF.toFixed(1) + ' LF';
    }
    if (room.fromLeftover > 0) {
      html += ' <span class="from-leftover">(' + room.fromLeftover + ' from leftover)</span>';
    }
    html += '</span></div>';
  });
  html += '</div>';
  
  summaryEl.innerHTML = html;
}

// -- END OF ROOM DIAGRAM VISUALIZER ------------------------

/**
 * Update the carpet calculation preview inside the measurement modal.
 * Shows strip count, cut lengths, LF, and SY for the current room.
 * @returns {Object|null} Carpet calc result or null
 */
function updateCarpetCalcPreview() {
  var calcPreview = document.getElementById("carpet-calc-preview");
  var yardageRow = document.getElementById("carpet-yardage-row");

  if (!isCarpetMode) {
    if (calcPreview) calcPreview.classList.remove("show");
    if (yardageRow) yardageRow.classList.remove("show");
    return null;
  }

  // Find the maximum width and length from all dimension rows
  var maxWidth = 0, maxLength = 0;
  currentDimensionRows.forEach(function(row) {
    var w = toNum(row.width);
    var l = toNum(row.length);
    if (w > maxWidth) maxWidth = w;
    if (l > maxLength) maxLength = l;
  });

  var calc = calculateCarpetYardage(maxWidth, maxLength, currentCarpetDirection);

  if (calcPreview) calcPreview.classList.add("show");
  if (yardageRow) yardageRow.classList.add("show");

  // Update all preview elements
  var el = function(id) { return document.getElementById(id); };
  if (el("calc-strips")) el("calc-strips").textContent = calc.strips;
  if (el("calc-cut-length")) el("calc-cut-length").textContent = calc.cutLength.toFixed(1) + "'";
  if (el("calc-linear-ft")) el("calc-linear-ft").textContent = calc.linearFeet.toFixed(1);
  if (el("calc-sq-yds")) el("calc-sq-yds").textContent = calc.squareYards.toFixed(2);
  if (el("carpet-calc-formula")) el("carpet-calc-formula").textContent = calc.formula || "--";

  // Calculate stair SY contribution with leftover optimization
  var stairsSY = 0;
  var totalStairs = 0;
  var totalStairSF = 0;
  
  currentStairEntries.forEach(function(entry) {
    var count = toNum(entry.count);
    var width = toNum(entry.width) || DEFAULT_STAIR.WIDTH_IN;
    var tread = toNum(entry.tread || entry.length) || DEFAULT_STAIR.TREAD_IN;
    var riser = toNum(entry.riser) || DEFAULT_STAIR.RISER_IN;
    if (count > 0) {
      var widthFt = width / 12;
      var stairSF = widthFt * ((tread / 12) + (riser / 12)) * count;
      totalStairSF += stairSF;
      totalStairs += count;
    }
  });

  // Check if stairs fit in leftover from room cuts
  if (totalStairs > 0 && calc.strips > 0 && maxWidth > 0 && maxLength > 0) {
    var widthToCover, cutLength;
    if (currentCarpetDirection === 'lengthwise') {
      widthToCover = maxWidth;
      cutLength = maxLength;
    } else {
      widthToCover = maxLength;
      cutLength = maxWidth;
    }
    var leftoverWidth = (calc.strips * carpetWidth) - widthToCover;
    var leftoverLength = cutLength;

    if (leftoverWidth > 0 && leftoverLength > 0) {
      var refEntry = currentStairEntries[0];
      var refWidthFt = (toNum(refEntry.width) || DEFAULT_STAIR.WIDTH_IN) / 12;
      var refTreadFt = (toNum(refEntry.tread || refEntry.length) || DEFAULT_STAIR.TREAD_IN) / 12;
      var refRiserFt = (toNum(refEntry.riser) || DEFAULT_STAIR.RISER_IN) / 12;
      var stairPieceFt = refTreadFt + refRiserFt;

      var stairsAcross = Math.floor(leftoverWidth / refWidthFt);
      var stairsDeep = Math.floor(leftoverLength / stairPieceFt);
      var leftoverStairsFit = stairsAcross * stairsDeep;

      var stairsFromLeftover = Math.min(totalStairs, leftoverStairsFit);
      var stairsNeedingNewCarpet = totalStairs - stairsFromLeftover;

      if (stairsNeedingNewCarpet > 0) {
        var tempLeftover = stairsFromLeftover;
        currentStairEntries.forEach(function(entry) {
          var count = toNum(entry.count);
          if (count <= 0) return;
          var widthFt = (toNum(entry.width) || DEFAULT_STAIR.WIDTH_IN) / 12;
          var treadFt = (toNum(entry.tread || entry.length) || DEFAULT_STAIR.TREAD_IN) / 12;
          var riserFt = (toNum(entry.riser) || DEFAULT_STAIR.RISER_IN) / 12;
          var stairPieceFt2 = treadFt + riserFt;
          var fromThis = Math.min(count, tempLeftover);
          tempLeftover -= fromThis;
          var remaining = count - fromThis;
          if (remaining > 0) {
            // Calculate how stairs are cut from carpet roll
            var stairsPerRow = Math.floor(carpetWidth / widthFt);
            if (stairsPerRow < 1) stairsPerRow = 1;
            var rowsNeeded = Math.ceil(remaining / stairsPerRow);
            var linearFeet = rowsNeeded * stairPieceFt2;
            stairsSY += (linearFeet * carpetWidth) / 9;
          }
        });
      }
      // else stairsSY stays 0 - all stairs fit in leftover
    } else {
      stairsSY = totalStairSF / 9;
    }
  } else if (totalStairs > 0) {
    stairsSY = totalStairSF / 9;
  }

  var grandTotalSY = calc.squareYards + stairsSY;

  // Update yardage details and total
  if (el("carpet-yardage-details")) {
    var details = calc.strips + " strips @ " + calc.cutLength.toFixed(1) + "' = " + calc.linearFeet.toFixed(1) + " LF";
    if (stairsSY > 0) details += " + " + stairsSY.toFixed(2) + " SY stairs";
    el("carpet-yardage-details").textContent = details;
  }
  if (el("carpet-total-sy-modal")) {
    el("carpet-total-sy-modal").textContent = grandTotalSY.toFixed(2) + " SY";
  }

  return calc;
}

/** Update the carpet summary totals shown in the Step 2 header area. */
function updateCarpetSummaryTotals() {
  var summaryRow = document.getElementById("carpet-summary-row");
  if (!isCarpetMode) {
    if (summaryRow) summaryRow.style.display = "none";
    return;
  }
  if (summaryRow) summaryRow.style.display = "flex";

  var totals = calculateTotalCarpetYardage();
  var el = function(id) { return document.getElementById(id); };
  if (currentOptimizedPlan) {
    if (el("carpet-total-sy")) el("carpet-total-sy").textContent = currentOptimizedPlan.totalSY.toFixed(2);
    if (el("carpet-total-cuts")) el("carpet-total-cuts").textContent = currentOptimizedPlan.cuts.length;
    if (el("carpet-total-lf")) el("carpet-total-lf").textContent = currentOptimizedPlan.totalLinearFt.toFixed(0);
    if (el("total-carpet-sy")) el("total-carpet-sy").textContent = currentOptimizedPlan.totalSY.toFixed(2);
  } else {
    if (el("carpet-total-sy")) el("carpet-total-sy").textContent = totals.grandTotalSquareYards.toFixed(2);
    if (el("carpet-total-cuts")) el("carpet-total-cuts").textContent = totals.totalStrips;
    if (el("carpet-total-lf")) el("carpet-total-lf").textContent = totals.totalLinearFeet.toFixed(0);
    if (el("total-carpet-sy")) el("total-carpet-sy").textContent = totals.grandTotalSquareYards.toFixed(2);
  }
}

/**
 * Calculate carpet pad quantity (in SY, with 5% waste).
 * @returns {number} Rounded-up SY needed
 */
function calculateCarpetPadQty() {
  var totalSF = 0;
  selectedAreas.forEach(function(area) {
    if (roomMeasurements[area.id]) {
      totalSF += roomMeasurements[area.id].totalSF || 0;
    }
  });
  if (totalSF <= 0) return 0;
  return Math.ceil((totalSF * CARPET_PAD_WASTE_FACTOR) / 9);
}


/* =============================================================================
 * 10. STAIR CALCULATIONS
 * =============================================================================
 * Stair entry rendering and SF/SY calculation for both carpet and hard surface.
 * ========================================================================== */

/** Render stair measurement entry rows inside the modal. */
function renderStairEntries() {
  var container = document.getElementById("stair-entries");
  if (!container) return;
  var html = "";
  currentStairEntries.forEach(function(entry, idx) {
    var count = toNum(entry.count);
    var hasValue = count > 0;
    html += '<div class="stair-entry' + (hasValue ? ' has-value' : '') + '" data-stair-idx="' + idx + '">';
    html += '<div class="stair-input-group"><div class="stair-input-label">Count</div>';
    html += '<div class="stair-input-wrap"><input type="number" class="stair-input stair-count-input" placeholder="0" min="0" value="' + (entry.count || "") + '">';
    html += '<button type="button" class="input-clear-btn" data-clear="count">&times;</button></div></div>';
    html += '<div class="stair-input-group"><div class="stair-input-label">Width (in)</div>';
    html += '<div class="stair-input-wrap"><input type="number" class="stair-input stair-width-input" placeholder="' + DEFAULT_STAIR.WIDTH_IN + '" min="0" value="' + (entry.width || DEFAULT_STAIR.WIDTH_IN) + '">';
    html += '<button type="button" class="input-clear-btn" data-clear="width">&times;</button></div></div>';
    html += '<div class="stair-input-group"><div class="stair-input-label">Tread (in)</div>';
    html += '<div class="stair-input-wrap"><input type="number" class="stair-input stair-tread-input" placeholder="' + DEFAULT_STAIR.TREAD_IN + '" min="0" value="' + (entry.tread || DEFAULT_STAIR.TREAD_IN) + '">';
    html += '<button type="button" class="input-clear-btn" data-clear="tread">&times;</button></div></div>';
    html += '<div class="stair-input-group"><div class="stair-input-label">Riser (in)</div>';
    html += '<div class="stair-input-wrap"><input type="number" class="stair-input stair-riser-input" placeholder="' + DEFAULT_STAIR.RISER_IN + '" min="0" value="' + (entry.riser || DEFAULT_STAIR.RISER_IN) + '">';
    html += '<button type="button" class="input-clear-btn" data-clear="riser">&times;</button></div></div>';
    html += '<button type="button" class="stair-remove" data-stair-idx="' + idx + '">x</button>';
    html += '</div>';
  });
  container.innerHTML = html;

  container.querySelectorAll(".stair-entry").forEach(function(entryEl) {
    var idx = parseInt(entryEl.dataset.stairIdx);
    var inputs = {
      count: entryEl.querySelector(".stair-count-input"),
      width: entryEl.querySelector(".stair-width-input"),
      tread: entryEl.querySelector(".stair-tread-input"),
      riser: entryEl.querySelector(".stair-riser-input")
    };
    var removeBtn = entryEl.querySelector(".stair-remove");

    var updateEntry = function() {
      currentStairEntries[idx].count = inputs.count ? inputs.count.value : "";
      currentStairEntries[idx].width = inputs.width ? inputs.width.value : String(DEFAULT_STAIR.WIDTH_IN);
      currentStairEntries[idx].tread = inputs.tread ? inputs.tread.value : String(DEFAULT_STAIR.TREAD_IN);
      currentStairEntries[idx].riser = inputs.riser ? inputs.riser.value : String(DEFAULT_STAIR.RISER_IN);
      entryEl.classList.toggle("has-value", toNum(currentStairEntries[idx].count) > 0);
      updateStairsCalc();
      updateStairNoseCalc();
    };

    // Auto-advance fields: count &#8594; width &#8594; tread &#8594; riser &#8594; stair nose length
    var fieldOrder = [inputs.count, inputs.width, inputs.tread, inputs.riser];
    var stairAutoTimer = null;

    fieldOrder.forEach(function(field, fi) {
      if (!field) return;
      field.addEventListener("input", function() {
        updateEntry();
        clearTimeout(stairAutoTimer);
        if (field.value !== "") {
          stairAutoTimer = setTimeout(function() {
            if (fi < fieldOrder.length - 1) {
              // Move to next field in this entry
              var nextField = fieldOrder[fi + 1];
              nextField.focus();
              nextField.select();
              // If next field already has a value, auto-advance again
              if (nextField.value !== "") {
                clearTimeout(stairAutoTimer);
                stairAutoTimer = setTimeout(function() {
                  nextField.dispatchEvent(new Event("input", { bubbles: true }));
                }, 1500);
              }
            } else if (isHardSurfaceStairMode) {
              // After riser, move to stair nose length
              var noseInput = document.getElementById("stair-nose-length-input");
              if (noseInput) {
                noseInput.focus();
                noseInput.select();
              }
            } else {
              // After riser, blur and scroll to Existing Floor (Demo)
              field.blur();
              var demoSection = document.getElementById("demo-keywords");
              if (demoSection) {
                setTimeout(function() {
                  demoSection.scrollIntoView({ behavior: "smooth", block: "start" });
                }, 150);
              }
            }
          }, 1500);
        }
      });
      field.addEventListener("focus", function() {
        clearTimeout(stairAutoTimer);
        if (fi === 0) {
          var stairEntry = field.closest('.stair-entry');
          if (stairEntry) {
            setTimeout(function() {
              stairEntry.scrollIntoView({ behavior: "smooth", block: "start" });
            }, 150);
          }
        }
      });
    });

    if (removeBtn) {
      removeBtn.addEventListener("click", function(e) {
        e.preventDefault();
        e.stopPropagation();
        if (currentStairEntries.length > 1) {
          currentStairEntries.splice(idx, 1);
        } else {
          currentStairEntries[idx] = {
            count: "",
            width: String(DEFAULT_STAIR.WIDTH_IN),
            tread: String(DEFAULT_STAIR.TREAD_IN),
            riser: String(DEFAULT_STAIR.RISER_IN)
          };
        }
        renderStairEntries();
        updateStairsCalc();
        updateStairNoseCalc();
        updateStairDemoPrompt();
      });
    }

    // Clear buttons for stair inputs
    entryEl.querySelectorAll(".input-clear-btn").forEach(function(clearBtn) {
      clearBtn.addEventListener("click", function(e) {
        e.preventDefault();
        e.stopPropagation();
        var field = clearBtn.dataset.clear;
        if (field === "count" && inputs.count) {
          inputs.count.value = "";
          currentStairEntries[idx].count = "";
        } else if (field === "width" && inputs.width) {
          inputs.width.value = "";
          currentStairEntries[idx].width = "";
        } else if (field === "tread" && inputs.tread) {
          inputs.tread.value = "";
          currentStairEntries[idx].tread = "";
        } else if (field === "riser" && inputs.riser) {
          inputs.riser.value = "";
          currentStairEntries[idx].riser = "";
        }
        entryEl.classList.toggle("has-value", toNum(currentStairEntries[idx].count) > 0);
        updateStairsCalc();
        updateStairNoseCalc();
        updateStairDemoPrompt();
      });
    });
  });
}

/** Render mid landing entry rows. */
function renderLandingEntries() {
  var container = document.getElementById("stair-landing-entries");
  if (!container) return;
  
  if (currentLandingEntries.length === 0) {
    container.style.display = "none";
    return;
  }
  
  container.style.display = "block";
  var html = '<div class="measure-section-title" style="font-size:13px;margin-bottom:8px;"><span class="icon">&#128195;</span> Mid Landings</div>';
  
  currentLandingEntries.forEach(function(entry, idx) {
    var w = toNum(entry.width);
    var l = toNum(entry.length);
    var sf = w * l;
    var hasValue = w > 0 && l > 0;
    
    html += '<div class="dimension-row' + (hasValue ? ' has-value' : '') + '" data-landing-idx="' + idx + '" style="background:var(--amber-50);border-color:var(--amber-300);">';
    html += '<div class="dimension-input-wrap"><input type="number" class="dimension-input landing-width" placeholder="W" value="' + (entry.width || '') + '" inputmode="decimal" step="0.1" min="0"></div>';
    html += '<span class="dimension-x">&times;</span>';
    html += '<div class="dimension-input-wrap"><input type="number" class="dimension-input landing-length" placeholder="L" value="' + (entry.length || '') + '" inputmode="decimal" step="0.1" min="0"></div>';
    html += '<span class="dimension-equals">=</span>';
    html += '<span class="dimension-total" style="background:var(--amber-100);color:#92400e;">' + (hasValue ? sf.toFixed(0) + ' SF' : '0 SF') + '</span>';
    html += '<button type="button" class="dimension-remove" data-landing-idx="' + idx + '">&times;</button>';
    html += '</div>';
  });
  
  container.innerHTML = html;
  bindLandingEntryEvents(container);
}

/** Bind events to landing entry inputs. */
function bindLandingEntryEvents(container) {
  container.querySelectorAll(".dimension-row").forEach(function(row) {
    var idx = parseInt(row.dataset.landingIdx);
    var widthInput = row.querySelector(".landing-width");
    var lengthInput = row.querySelector(".landing-length");
    var removeBtn = row.querySelector(".dimension-remove");
    
    if (widthInput) {
      widthInput.addEventListener("input", function() {
        currentLandingEntries[idx].width = widthInput.value;
        updateLandingRowTotal(row);
        updateStairsCalc();
        
        clearTimeout(landingAutoAdvanceTimer);
        if (widthInput.value !== "") {
          landingAutoAdvanceTimer = setTimeout(function() {
            if (lengthInput) { lengthInput.focus(); lengthInput.select(); }
          }, DIMENSION_AUTO_ADVANCE_MS);
        }
      });
      widthInput.addEventListener("focus", function() { clearTimeout(landingAutoAdvanceTimer); });
    }
    
    if (lengthInput) {
      lengthInput.addEventListener("input", function() {
        currentLandingEntries[idx].length = lengthInput.value;
        updateLandingRowTotal(row);
        updateStairsCalc();
        
        clearTimeout(landingAutoAdvanceTimer);
        if (lengthInput.value !== "") {
          landingAutoAdvanceTimer = setTimeout(function() {
            var allRows = container.querySelectorAll(".dimension-row");
            var nextRow = allRows[idx + 1];
            if (nextRow) {
              var nextWidth = nextRow.querySelector(".landing-width");
              if (nextWidth) { nextWidth.focus(); nextWidth.select(); }
            } else {
              addLandingEntry();
            }
          }, DIMENSION_AUTO_ADVANCE_MS);
        }
      });
      lengthInput.addEventListener("focus", function() { clearTimeout(landingAutoAdvanceTimer); });
    }
    
    if (removeBtn) {
      removeBtn.addEventListener("click", function() {
        currentLandingEntries.splice(idx, 1);
        renderLandingEntries();
        updateStairsCalc();
      });
    }
  });
}

/** Update a single landing row's SF total. */
function updateLandingRowTotal(rowEl) {
  var wEl = rowEl.querySelector(".landing-width");
  var lEl = rowEl.querySelector(".landing-length");
  var w = toNum(wEl ? wEl.value : 0);
  var l = toNum(lEl ? lEl.value : 0);
  var sf = w * l;
  var hasValue = w > 0 && l > 0;
  
  rowEl.classList.toggle("has-value", hasValue);
  var totalEl = rowEl.querySelector(".dimension-total");
  if (totalEl) totalEl.textContent = hasValue ? sf.toFixed(0) + " SF" : "0 SF";
}

/** Add a new mid landing entry. */
function addLandingEntry() {
  currentLandingEntries.push({ width: "", length: "" });
  renderLandingEntries();
  
  // Focus the new width input
  setTimeout(function() {
    var container = document.getElementById("stair-landing-entries");
    if (container) {
      var rows = container.querySelectorAll(".dimension-row");
      if (rows.length > 0) {
        var lastWidth = rows[rows.length - 1].querySelector(".landing-width");
        if (lastWidth) lastWidth.focus();
      }
    }
  }, 50);
}

/** Add a new stair entry row with default values. */
function addStairEntry() {
  currentStairEntries.push({ 
    count: "", 
    width: String(DEFAULT_STAIR.WIDTH_IN), 
    tread: String(DEFAULT_STAIR.TREAD_IN), 
    riser: String(DEFAULT_STAIR.RISER_IN) 
  });
  renderStairEntries();
}

/**
 * Calculate stair nose piece count for hard surface mode.
 * Determines how many stair nosing pieces are needed based on stair width
 * vs. available nose piece length.
 */
function updateStairNoseCalc() {
  var stairNoseSection = document.getElementById("stair-nose-section");
  
  // Get total stair count
  var totalStairCount = 0;
  currentStairEntries.forEach(function(entry) {
    totalStairCount += toNum(entry.count);
  });
  
  // Hide stair nose for carpet, tile, or when no stairs
  var primaryCatNose = currentPrimaryItem ? currentPrimaryItem.category : null;
  var isTileNose = isTileCategory(primaryCatNose);
  if (totalStairCount === 0 || isCarpetMode || isTileNose) {
    if (stairNoseSection) stairNoseSection.style.display = "none";
    return;
  } else {
    if (stairNoseSection) stairNoseSection.style.display = "";
  }
  var noseLengthInput = document.getElementById("stair-nose-length-input");
  var noseCountEl = document.getElementById("stair-nose-count");
  var noseLength = toNum(noseLengthInput ? noseLengthInput.value : 0) || STAIR_NOSE_DEFAULTS.OTHER;
  var totalNosePieces = 0;
  currentStairEntries.forEach(function(entry) {
    var count = toNum(entry.count);
    var stairWidth = toNum(entry.width) || DEFAULT_STAIR.WIDTH_IN;
    if (count > 0 && stairWidth > 0) {
      var stepsPerNose = Math.max(1, Math.floor(noseLength / stairWidth));
      totalNosePieces += Math.ceil(count / stepsPerNose);
    }
  });
  if (noseCountEl) noseCountEl.textContent = totalNosePieces + " pcs";
  // Also update the stair-nose molding counter if present
  var stairNoseMolding = document.querySelector('.molding-item[data-molding="stair-nose"]');
  if (stairNoseMolding) {
    var valueEl = stairNoseMolding.querySelector(".molding-value");
    if (valueEl) {
      valueEl.textContent = totalNosePieces;
      stairNoseMolding.classList.toggle("has-value", totalNosePieces > 0);
    }
  }
}

/**
 * Calculate stair area (SY for carpet, SF for hard surface) and update the
 * stair calc display in the modal.
 * @returns {Object|null} Calculation result or null
 */

function updateStairDemoPrompt() {
  var prompt = document.getElementById("stair-demo-prompt");
  if (!prompt) return;
  
  // Get current room demo selection
  var selectedDemoBtn = document.querySelector("#demo-keywords .demo-keyword.selected");
  var roomHasDemo = selectedDemoBtn && selectedDemoBtn.dataset.demo;
  
  // Check if stairs have count > 0
  var hasStairs = false;
  currentStairEntries.forEach(function(e) {
    if (toNum(e.count) > 0) hasStairs = true;
  });
  
  // Show prompt only if both conditions met
  var showPrompt = hasStairs && roomHasDemo;
  prompt.style.display = showPrompt ? "block" : "none";
  
  // Update button selection state
  document.querySelectorAll(".stair-demo-btn").forEach(function(btn) {
    btn.classList.toggle("selected", btn.dataset.stairDemo === currentStairDemoType);
  });
}

function updateStairsCalc() {
  var stairCalcResult = document.getElementById("stair-calc-result");
  var stairSyResult = document.getElementById("stair-sy-result");
  var stairCalcLabel = document.getElementById("stair-calc-label");
  var primaryCat = currentPrimaryItem ? currentPrimaryItem.category : null;

  // -- Carpet stairs: calculate SY ---------------------------------------
  // ---- Carpet stairs: calculate SY with leftover optimization -----------
  if (isCarpetMode) {
    var totalSY = 0, totalStairs = 0, totalStairSF = 0;
    currentStairEntries.forEach(function(entry) {
      var count = toNum(entry.count);
      var width = toNum(entry.width) || DEFAULT_STAIR.WIDTH_IN;
      var tread = toNum(entry.tread || entry.length) || DEFAULT_STAIR.TREAD_IN;
      var riser = toNum(entry.riser) || DEFAULT_STAIR.RISER_IN;
      if (count > 0) {
        var widthFt = width / 12;
        var stairSF = widthFt * ((tread / 12) + (riser / 12)) * count;
        totalStairSF += stairSF;
        totalStairs += count;
      }
    });

    // Calculate leftover from room cuts
    var leftoverStairsFit = 0;
    var leftoverWidth = 0;
    var leftoverLength = 0;
    var stairsNeedingNewCarpet = totalStairs;
    var stairsAcross = 0;
    var actualRowsNeeded = 0;
    var remainingLength = 0;

    if (totalStairs > 0) {
      var maxRoomWidth = 0, maxRoomLength = 0;
      currentDimensionRows.forEach(function(row) {
        var w = toNum(row.width);
        var l = toNum(row.length);
        if (w > maxRoomWidth) maxRoomWidth = w;
        if (l > maxRoomLength) maxRoomLength = l;
      });

      if (maxRoomWidth > 0 && maxRoomLength > 0) {
        var widthToCover, cutLength;
        if (currentCarpetDirection === 'lengthwise') {
          widthToCover = maxRoomWidth;
          cutLength = maxRoomLength;
        } else {
          widthToCover = maxRoomLength;
          cutLength = maxRoomWidth;
        }
        var strips = Math.ceil(widthToCover / carpetWidth);
        leftoverWidth = (strips * carpetWidth) - widthToCover;
        leftoverLength = cutLength;

        if (leftoverWidth > 0 && leftoverLength > 0) {
          var refEntry = currentStairEntries[0];
          var refWidthFt = (toNum(refEntry.width) || DEFAULT_STAIR.WIDTH_IN) / 12;
          var refTreadFt = (toNum(refEntry.tread || refEntry.length) || DEFAULT_STAIR.TREAD_IN) / 12;
          var refRiserFt = (toNum(refEntry.riser) || DEFAULT_STAIR.RISER_IN) / 12;
          var stairPieceFt = refTreadFt + refRiserFt;

          stairsAcross = Math.floor(leftoverWidth / refWidthFt);
          var stairsDeep = Math.floor(leftoverLength / stairPieceFt);
          leftoverStairsFit = stairsAcross * stairsDeep;

          actualRowsNeeded = stairsAcross > 0 ? Math.ceil(totalStairs / stairsAcross) : 0;
          var actualLengthUsed = actualRowsNeeded * stairPieceFt;
          remainingLength = leftoverLength - actualLengthUsed;
        }
      }
    }

    // Determine additional SY needed beyond leftover
    var stairsFromLeftover = Math.min(totalStairs, leftoverStairsFit);
    stairsNeedingNewCarpet = totalStairs - stairsFromLeftover;
    var additionalSY = 0;
    var tempLeftover = stairsFromLeftover;

    if (stairsNeedingNewCarpet > 0) {
      currentStairEntries.forEach(function(entry) {
        var count = toNum(entry.count);
        if (count <= 0) return;
        var widthFt = (toNum(entry.width) || DEFAULT_STAIR.WIDTH_IN) / 12;
        var treadFt = (toNum(entry.tread || entry.length) || DEFAULT_STAIR.TREAD_IN) / 12;
        var riserFt = (toNum(entry.riser) || DEFAULT_STAIR.RISER_IN) / 12;
        var stairPieceFt = treadFt + riserFt;

        var fromThis = Math.min(count, tempLeftover);
        tempLeftover -= fromThis;
        var remaining = count - fromThis;
        if (remaining > 0) {
          // Calculate how stairs are cut from carpet roll
          var stairsPerRow = Math.floor(carpetWidth / widthFt);
          if (stairsPerRow < 1) stairsPerRow = 1;
          var rowsNeeded = Math.ceil(remaining / stairsPerRow);
          var linearFeet = rowsNeeded * stairPieceFt;
          additionalSY += (linearFeet * carpetWidth) / 9;
        }
      });
    }

    totalSY = additionalSY;
    var grossStairSY = totalStairSF / 9;

    if (totalStairs > 0) {
      if (stairCalcResult) stairCalcResult.style.display = "block";
      if (grossStairSY > 0 && totalSY < grossStairSY) {
        var saved = grossStairSY - totalSY;
        if (stairSyResult) {
          if (totalSY === 0) {
            stairSyResult.innerHTML = '<span style="color:#15803d;">0 SY</span> <span style="font-size:14px;color:#166534;">(all from leftover!)</span>';
          } else {
            stairSyResult.innerHTML = totalSY.toFixed(2) + ' SY <span style="font-size:14px;color:#166534;">(saved ' + saved.toFixed(2) + ' SY from leftover)</span>';
          }
        }
        var stairsFromLeftoverCount = totalStairs - stairsNeedingNewCarpet;
        var layoutDesc = "";
        if (stairsFromLeftoverCount > 0) {
          layoutDesc = stairsFromLeftoverCount + " stairs from " + leftoverWidth.toFixed(1) + "' x " + leftoverLength.toFixed(1) + "' leftover (" + stairsAcross + " across x " + actualRowsNeeded + " rows)";
        }
        if (stairsNeedingNewCarpet > 0) {
          // Calculate how the additional stairs are cut
          var refWidthFt = (toNum(currentStairEntries[0].width) || DEFAULT_STAIR.WIDTH_IN) / 12;
          var refTreadFt = (toNum(currentStairEntries[0].tread || currentStairEntries[0].length) || DEFAULT_STAIR.TREAD_IN) / 12;
          var refRiserFt = (toNum(currentStairEntries[0].riser) || DEFAULT_STAIR.RISER_IN) / 12;
          var stairPieceFt = refTreadFt + refRiserFt;
          var newStairsPerRow = Math.floor(carpetWidth / refWidthFt);
          if (newStairsPerRow < 1) newStairsPerRow = 1;
          var newRowsNeeded = Math.ceil(stairsNeedingNewCarpet / newStairsPerRow);
          var newLinearFt = newRowsNeeded * stairPieceFt;
          if (layoutDesc) layoutDesc += " + ";
          layoutDesc += stairsNeedingNewCarpet + " stairs from new roll (" + newStairsPerRow + " across x " + newRowsNeeded + " rows = " + newLinearFt.toFixed(1) + "' LF)";
        }
        if (remainingLength > 0.5 && stairsFromLeftoverCount > 0) {
          layoutDesc += ", " + remainingLength.toFixed(1) + "' leftover remaining";
        }
        if (stairCalcLabel) stairCalcLabel.textContent = layoutDesc;
      } else {
        if (stairSyResult) stairSyResult.textContent = totalSY.toFixed(2) + " SY";
        if (stairCalcLabel) stairCalcLabel.textContent = "Stairs Carpet Total";
      }

      // Update grand total in footer directly
      var maxRoomWidth = 0, maxRoomLength = 0;
      currentDimensionRows.forEach(function(row) {
        var w = toNum(row.width);
        var l = toNum(row.length);
        if (w > maxRoomWidth) maxRoomWidth = w;
        if (l > maxRoomLength) maxRoomLength = l;
      });
      var roomCalc = calculateCarpetYardage(maxRoomWidth, maxRoomLength, currentCarpetDirection);
      var grandTotalSY = roomCalc.squareYards + totalSY;
      var footerEl = document.getElementById("carpet-total-sy-modal");
      if (footerEl) {
        footerEl.textContent = grandTotalSY.toFixed(2) + " SY";
      }
      var detailsEl = document.getElementById("carpet-yardage-details");
      if (detailsEl) {
        var details = roomCalc.strips + " strips @ " + roomCalc.cutLength.toFixed(1) + "' = " + roomCalc.linearFeet.toFixed(1) + " LF";
        if (totalSY > 0) details += " + " + totalSY.toFixed(2) + " SY stairs";
        detailsEl.textContent = details;
      }

      updateCarpetCalcPreview();
      updateStairDemoPrompt();
      return { squareYards: totalSY, totalStairs: totalStairs, grossSquareYards: grossStairSY, stairsFromLeftover: totalStairs - stairsNeedingNewCarpet };
    }
    if (stairCalcResult) stairCalcResult.style.display = "none";
    updateCarpetCalcPreview();
    updateStairDemoPrompt();
    return null;
  }

  //  Hard surface stairs: calculate SF 
  if (isHardSurfaceStairMode) {
    var totalSF_HS = 0, totalStairs_HS = 0;
    var stairDetails = [];
    currentStairEntries.forEach(function(entry) {
      var count = toNum(entry.count);
      var widthIn = toNum(entry.width) || DEFAULT_STAIR.WIDTH_IN;
      var treadIn = toNum(entry.tread) || DEFAULT_STAIR.TREAD_IN;
      var riserIn = toNum(entry.riser) || DEFAULT_STAIR.RISER_IN;
      if (count > 0) {
        var widthFt = widthIn / 12;
        var treadFt = treadIn / 12;
        var riserFt = riserIn / 12;
        var entrySF = count * widthFt * (treadFt + riserFt);
        totalSF_HS += entrySF;
        totalStairs_HS += count;
        stairDetails.push({
          count: count,
          widthIn: widthIn,
          treadIn: treadIn,
          riserIn: riserIn,
          sf: entrySF
        });
      }
    });
    
    // Calculate landing SF
    var landingSF = 0;
    var landingDetails = [];
    currentLandingEntries.forEach(function(entry) {
      var w = toNum(entry.width);
      var l = toNum(entry.length);
      if (w > 0 && l > 0) {
        var sf = w * l;
        landingSF += sf;
        landingDetails.push({ width: w, length: l, sf: sf });
      }
    });
    
    var grandTotalSF = totalSF_HS + landingSF;
    
    if (grandTotalSF > 0) {
      if (stairCalcResult) stairCalcResult.style.display = "block";
      if (stairSyResult) {
        stairSyResult.innerHTML = '<span style="color:#15803d;">' + grandTotalSF.toFixed(1) + ' SF</span>';
      }
      // Build detailed breakdown
      var detailParts = [];
      stairDetails.forEach(function(d) {
        var pieceSize = d.widthIn + '" x ' + (d.treadIn + d.riserIn) + '"';
        detailParts.push(d.count + ' @ ' + pieceSize + ' = ' + d.sf.toFixed(1) + ' SF');
      });
      var stairDetailText = detailParts.length > 0 ? totalStairs_HS + ' stairs: ' + detailParts.join(' + ') : '';
      
      // Add landing details
      var landingDetailParts = [];
      landingDetails.forEach(function(ld) {
        landingDetailParts.push(ld.width + "' x " + ld.length + "' = " + ld.sf.toFixed(1) + ' SF');
      });
      var landingDetailText = landingDetailParts.length > 0 ? 'Landings: ' + landingDetailParts.join(' + ') : '';
      
      if (stairCalcLabel) {
        var fullDetail = stairDetailText;
        if (landingDetailText) {
          fullDetail += (fullDetail ? '<br>' : '') + landingDetailText;
        }
        stairCalcLabel.innerHTML = fullDetail;
      }
      updateStairNoseCalc();
      updateStairDemoPrompt();
      return { squareFeet: grandTotalSF, totalStairs: totalStairs_HS, landingSF: landingSF };
    }
    if (stairCalcResult) stairCalcResult.style.display = "none";
    updateStairNoseCalc();
    updateStairDemoPrompt();
    return null;
  }

  // No special stair mode - just hide the result
  if (stairCalcResult) stairCalcResult.style.display = "none";
  return null;
}


/* =============================================================================
 * 11. ASSEMBLY & GRID (Step 3)
 * =============================================================================
 * Assembly selection, group item grid rendering, and quantity management.
 * ========================================================================== */

/**
 * Render the assembly grid showing all group items and their detail items.
 * Items marked as defaults are pre-selected. Measurement data is applied
 * to auto-fill quantities.
 */
async function renderAssemblyGrid() {
  var container = document.getElementById("grid-container");
  if (!container) return;

  if (!assemblyGroupItems || assemblyGroupItems.length === 0) {
    container.innerHTML = '<div class="empty-state">Select an assembly to see items</div>';
    return;
  }

  applyMeasurementDataToAssembly();

  var primaryCategory = currentPrimaryItem ? (currentPrimaryItem.category || "").toLowerCase() : "";
  var html = "";

  // -- Primary item card -------------------------------------------------
  if (currentPrimaryItem) {
    var primaryQtyEl = document.getElementById("primary-qty");
    html += '<div class="primary-item-card">';
    html += '<div class="primary-item-header">';
    html += '<div class="primary-item-checkbox">&#10003;</div>';
    html += '<div class="primary-item-info">';
    html += '<div class="primary-item-name">' + escHtml(currentPrimaryItem.desc) + '</div>';
    html += '<div class="primary-item-sku">SKU: ' + escHtml(currentPrimaryItem.sku) + '</div>';
    html += '<div class="primary-item-badge">' + escHtml(currentPrimaryItem.category || "Primary Item") + '</div>';
    html += '</div></div>';
    html += '<div class="primary-item-qty-row">';
    html += '<label>Quantity:</label>';
    html += '<div style="position:relative;display:inline-flex;align-items:center;">';
    var currentQtyVal = primaryQtyEl ? primaryQtyEl.value : "";
    var gridQtyElExisting = document.getElementById("primary-item-qty-grid");
    if (!currentQtyVal && gridQtyElExisting) currentQtyVal = gridQtyElExisting.value;
    if (!currentQtyVal || toNum(currentQtyVal) <= 0) {
      var totalSF = 0;
      selectedAreas.forEach(function(area) {
        var m = roomMeasurements[area.id];
        if (m && m.totalSF > 0) totalSF += m.totalSF;
        if (!isCarpetMode && m && m.stairsCalc && m.stairsCalc.squareFeet) totalSF += m.stairsCalc.squareFeet;
      });
      if (isCarpetMode) {
        var totals = calculateTotalCarpetYardage();
        if (currentOptimizedPlan) {
          currentQtyVal = currentOptimizedPlan.totalSY > 0 ? currentOptimizedPlan.totalSY.toFixed(2) : "";
        } else {
          currentQtyVal = totals.grandTotalSquareYards > 0 ? totals.grandTotalSquareYards.toFixed(2) : "";
        }
      } else {
        currentQtyVal = totalSF > 0 ? totalSF.toFixed(2) : "";
      }
    }
    html += '<input type="number" class="primary-item-qty-input" id="primary-item-qty-grid"'
      + ' value="' + currentQtyVal
      + '" inputmode="decimal" step="0.01" min="0" style="padding-right:36px;">';
    html += '<span style="position:absolute;right:10px;font-size:13px;font-weight:600;color:#15803d;pointer-events:none;">' + escHtml(isCarpetMode ? "SY" : "SF") + '</span>';
    html += '</div>';
    html += '<label class="show-options-toggle">';
    html += '<input type="checkbox" id="show-all-options" ' + (showAllOptions ? "checked" : "") + '>';
    html += '<span class="show-options-box"></span>';
    html += '<span class="show-options-label">Show Options</span>';
    html += '</label></div></div>';
  }

  // -- Group item sections -----------------------------------------------
  assemblyGroupItems.forEach(function(gi, giIdx) {
    var giCategory = (gi.category || "").toLowerCase();
    var categoryMatch = primaryCategory && giCategory
      && (giCategory.indexOf(primaryCategory) !== -1 || primaryCategory.indexOf(giCategory) !== -1);

    var sectionClass = "group-item-section";
    if (gi.selected) sectionClass += " selected";
    if (categoryMatch) sectionClass += " category-match";

    html += '<div class="' + sectionClass + '" data-gi-idx="' + giIdx + '">';

    // Group item header with name, checkbox, qty
    html += '<div class="gi-header">';
    html += '<div class="gi-checkbox">' + (gi.selected ? "&#10003;" : "") + '</div>';
    html += '<div class="gi-info">';
    html += '<div class="gi-name">' + escHtml(gi.name) + '</div>';
    html += '<div class="gi-meta">' + escHtml(gi.category || "")
      + (gi.uom ? " | " + gi.uom : "") + '</div></div>';
    var giQty = gi.currentQty !== null ? gi.currentQty : "";
    html += '<input type="number" class="gi-qty-input" value="' + giQty
      + '" placeholder="Qty" inputmode="decimal" step="0.01" min="0">';
    html += '</div>';

    // Group detail items (child items)
    html += '<div class="gd-container">';
    gi.groupDetails.forEach(function(gd, gdIdx) {
      var gdClass = "gd-item";
      if (gd.selected) gdClass += " selected";

      html += '<div class="' + gdClass + '" data-gi-idx="' + giIdx + '" data-gd-idx="' + gdIdx + '">';
      html += '<div class="gd-checkbox">' + (gd.selected ? "&#10003;" : "") + '</div>';
      html += '<div class="gd-info">';
      html += '<div class="gd-name">' + escHtml(gd.desc || gd.itemSku) + '</div>';
      html += '<div class="gd-sku">SKU: ' + escHtml(gd.itemSku) + '</div></div>';
      html += '<div class="gd-qty-section"><span class="gd-qty-label">Qty:</span>';
      var gdQty = gd.currentQty !== null ? gd.currentQty : "";
      html += '<input type="number" class="gd-qty-input" value="' + gdQty
        + '" placeholder="0" inputmode="decimal" step="0.01" min="0">';
      html += '</div></div>';
    });
    html += '</div></div>';
  });

  container.innerHTML = html;
  updateGridSummary();

  // -- Toggle collapsed state --------------------------------------------
  container.classList.toggle("grid-collapsed", !showAllOptions);
  var showAllCheckbox = document.getElementById("show-all-options");
  if (showAllCheckbox) {
    showAllCheckbox.addEventListener("change", function() {
      showAllOptions = showAllCheckbox.checked;
      container.classList.toggle("grid-collapsed", !showAllOptions);
    });
  }

  // -- Sync primary qty between grid and main input ----------------------
  var primaryQtyGridInput = document.getElementById("primary-item-qty-grid");
  if (primaryQtyGridInput) {
    primaryQtyGridInput.addEventListener("input", function() {
      var primaryQtyMainEl = document.getElementById("primary-qty");
      if (primaryQtyMainEl) primaryQtyMainEl.value = primaryQtyGridInput.value;
    });
  }

  // -- Bind grid interaction events --------------------------------------
  bindAssemblyGridEvents(container);
}

/**
 * Bind click/input events for assembly grid toggle and quantity editing.
 * @param {HTMLElement} container
 */
function bindAssemblyGridEvents(container) {
  container.querySelectorAll(".group-item-section").forEach(function(section) {
    var giIdx = parseInt(section.dataset.giIdx);
    var header = section.querySelector(".gi-header");
    var qtyInput = section.querySelector(".gi-qty-input");

    // Toggle group item selection on header click
    if (header) {
      header.addEventListener("click", function(e) {
        if (e.target.classList.contains("gi-qty-input")) return; // Don't toggle on qty click
        var gi = assemblyGroupItems[giIdx];
        gi.selected = !gi.selected;
        section.classList.toggle("selected", gi.selected);
        var checkbox = section.querySelector(".gi-checkbox");
        if (checkbox) checkbox.innerHTML = gi.selected ? "&#10003;" : "";

        // When activated, calculate qty from generateQty (FID 204)
        if (gi.selected && (gi.currentQty === null || gi.currentQty === 0)) {
          var primaryQtyEl = document.getElementById("primary-item-qty-grid") || document.getElementById("primary-qty");
          var pQty = toNum(primaryQtyEl ? primaryQtyEl.value : 0);

          if (gi.generateQty === 1) {
            gi.currentQty = 1;
          } else if (gi.generateQty > 0 && gi.generateQty < 1) {
            gi.currentQty = Math.round((pQty * gi.generateQty) * 100) / 100;
          } else {
            gi.currentQty = pQty;
          }

          // Update GI qty input in the UI
          if (qtyInput) qtyInput.value = gi.currentQty;

          // Push GI qty down to all default-selected detail items using FID 20 rules
          var giQty = gi.currentQty;
          gi.groupDetails.forEach(function(gd, gdIdx) {
            if (gd.isDefault) {
              gd.selected = true;
              if (gd.qty === 1) {
                gd.currentQty = 1;
              } else if (gd.qty > 0 && gd.qty < 1) {
                gd.currentQty = Math.round((giQty * gd.qty) * 100) / 100;
              } else {
                gd.currentQty = giQty;
              }
            }
          });

          // Re-render detail items to reflect new qty and selection
          section.querySelectorAll(".gd-item").forEach(function(gdItem) {
            var gdIdx = parseInt(gdItem.dataset.gdIdx);
            var gd = gi.groupDetails[gdIdx];
            gdItem.classList.toggle("selected", gd.selected);
            var gdCheckbox = gdItem.querySelector(".gd-checkbox");
            if (gdCheckbox) gdCheckbox.innerHTML = gd.selected ? "&#10003;" : "";
            var gdQtyInput = gdItem.querySelector(".gd-qty-input");
            if (gdQtyInput && gd.currentQty !== null) gdQtyInput.value = gd.currentQty;
          });
        }

        updateGridSummary();
      });
    }
    // Group item qty input
    if (qtyInput) {
      qtyInput.addEventListener("click", function(e) { e.stopPropagation(); });
      qtyInput.addEventListener("input", function() {
        assemblyGroupItems[giIdx].currentQty = toNum(qtyInput.value);
      });
    }

    // Detail item toggle and qty
    section.querySelectorAll(".gd-item").forEach(function(gdItem) {
      var gdIdx = parseInt(gdItem.dataset.gdIdx);
      var gdCheckbox = gdItem.querySelector(".gd-checkbox");
      var gdQtyInput = gdItem.querySelector(".gd-qty-input");

      gdItem.addEventListener("click", function(e) {
        if (e.target.classList.contains("gd-qty-input")) return;
        assemblyGroupItems[giIdx].groupDetails[gdIdx].selected =
          !assemblyGroupItems[giIdx].groupDetails[gdIdx].selected;
        gdItem.classList.toggle("selected", assemblyGroupItems[giIdx].groupDetails[gdIdx].selected);
        if (gdCheckbox) {
          gdCheckbox.innerHTML = assemblyGroupItems[giIdx].groupDetails[gdIdx].selected
            ? "&#10003;" : "";
        }
        updateGridSummary();

        // If a riser item was toggled, adjust primary qty
        var toggledName = (assemblyGroupItems[giIdx].groupDetails[gdIdx].desc || assemblyGroupItems[giIdx].groupDetails[gdIdx].itemSku || "").toLowerCase();
        if (toggledName.indexOf("riser") !== -1) {
          adjustPrimaryQtyForRiser();
        }
      });

      if (gdQtyInput) {
        gdQtyInput.addEventListener("click", function(e) { e.stopPropagation(); });
        gdQtyInput.addEventListener("input", function() {
          assemblyGroupItems[giIdx].groupDetails[gdIdx].currentQty = toNum(gdQtyInput.value);
        });
      }
    });
  });
}

/** Update the "X items selected" summary text below the grid. */
function updateGridSummary() {
  var summaryEl = document.getElementById("grid-summary");
  if (!summaryEl) return;

  var selectedCount = 0;
  assemblyGroupItems.forEach(function(gi) {
    if (gi.selected) {
      gi.groupDetails.forEach(function(gd) { if (gd.selected) selectedCount++; });
    }
  });

  summaryEl.textContent = selectedCount + " item" + (selectedCount !== 1 ? "s" : "") + " selected";
}

// -- Grid Quick Actions ------------------------------------------------------

/** Reset all assembly items to their default selection/qty state. */
function useDefaults() {
  assemblyGroupItems.forEach(function(gi) {
    gi.selected = gi.loadDefault;
    gi.currentQty = null;
    gi.groupDetails.forEach(function(gd) {
      gd.selected = gd.isDefault;
      gd.currentQty = null;
    });
  });
  applyMeasurementDataToAssembly();
  renderAssemblyGrid();
}

/** Select all group items and all their detail items. */
function selectAll() {
  assemblyGroupItems.forEach(function(gi) {
    gi.selected = true;
    gi.groupDetails.forEach(function(gd) { gd.selected = true; });
  });
  renderAssemblyGrid();
}

/** Deselect all group items and clear quantities. */
function clearAll() {
  assemblyGroupItems.forEach(function(gi) {
    gi.selected = false;
    gi.currentQty = null;
    gi.groupDetails.forEach(function(gd) {
      gd.selected = false;
      gd.currentQty = null;
    });
  });
  renderAssemblyGrid();
}


/* =============================================================================
 * 12. MEASUREMENT AGGREGATION
 * =============================================================================
 * Combines measurement data from all rooms and applies it to assembly items.
 * This is the bridge between Step 2 measurements and Step 3 assembly quantities.
 * ========================================================================== */

/**
 * Aggregate all room measurement data into a single summary object.
 * Used for auto-populating assembly item quantities and displaying summaries.
 *
 * @returns {Object} Aggregated data including totalSF, demoTypes, moldings, fixtures, etc.
 */
function aggregateMeasurementData() {
  var data = {
    totalSF: 0,
    totalCarpetSY: 0,
    totalCarpetCuts: 0,
    totalCarpetLF: 0,
    totalStairsSY: 0,
    totalStairsSF: 0,
    totalStairsQty: 0,
    demoTypes: {},          // { demoType: totalSF }
    moldings: {},           // { moldingType: rawCount }
    moldingsRounded: {},    // { moldingType: roundedCount }
    moldingInstallCount: 0,
    fixtures: {}            // { fixtureType: count }
  };

  selectedAreas.forEach(function(area) {
    var m = roomMeasurements[area.id];
    if (!m) return;

    data.totalSF += m.totalSF || 0;

    if (m.carpetCalc) {
      data.totalCarpetSY += m.carpetCalc.squareYards || 0;
      data.totalCarpetCuts += m.carpetCalc.strips || 0;
      data.totalCarpetLF += m.carpetCalc.linearFeet || 0;
    }

    if (m.stairsCalc) {
      data.totalStairsSY += m.stairsCalc.squareYards || 0;
    }
    data.totalStairsQty += m.stairsQty || 0;
    data.totalStairsSF += m.stairsSF || 0;

    // Stair demo type aggregation
    if (m.stairDemoType && m.stairDemoType !== "none" && (m.stairsSF > 0 || (m.stairsCalc && m.stairsCalc.squareYards > 0))) {
      var stairDemoKey = m.stairDemoType === "same" ? m.demoType : m.stairDemoType;
      if (stairDemoKey && stairDemoKey !== "none") {
        var stairDemoSF = m.stairsSF || 0;
        if (!stairDemoSF && m.stairsCalc && m.stairsCalc.squareYards) {
          stairDemoSF = m.stairsCalc.squareYards * 9;
        }
        if (stairDemoSF > 0) {
          if (!data.demoTypes[stairDemoKey]) data.demoTypes[stairDemoKey] = 0;
          data.demoTypes[stairDemoKey] += stairDemoSF;
        }
      }
    }

    // Demo types: aggregate SF by demo type
    if (m.demoType && m.demoType !== "none") {
      if (!data.demoTypes[m.demoType]) data.demoTypes[m.demoType] = 0;
      var demoSF = m.totalSF || 0;
      // Only add stair SF to room demo when stair demo is "same", "none", or unset
      if (m.stairsCalc && (!m.stairDemoType || m.stairDemoType === "none" || m.stairDemoType === "same")) {
        demoSF += m.stairsCalc.squareFeet || (m.stairsCalc.squareYards || 0) * 9;
      }
      data.demoTypes[m.demoType] += demoSF;
    }

    // Moldings: sum raw counts
    if (m.moldings) {
      Object.entries(m.moldings).forEach(function(pair) {
        var type = pair[0], count = pair[1];
        if (!data.moldings[type]) data.moldings[type] = 0;
        data.moldings[type] += count;
      });
    }

    // Fixtures: sum counts
    if (m.fixtures) {
      Object.entries(m.fixtures).forEach(function(pair) {
        var type = pair[0], count = pair[1];
        if (!data.fixtures[type]) data.fixtures[type] = 0;
        data.fixtures[type] += count;
      });
    }

    // Track stair nose separately
    if (m.moldings && m.moldings["stair-nose"]) {
      if (!data.stairNoseCount) data.stairNoseCount = 0;
      data.stairNoseCount += m.moldings["stair-nose"];
    }
  });

  // Round molding counts up (you can't install half a molding piece)
  Object.entries(data.moldings).forEach(function(pair) {
    var type = pair[0], count = pair[1];
    var rounded = Math.ceil(count);
    data.moldingsRounded[type] = rounded;
    data.moldingInstallCount += rounded;
  });

  // Calculate trim/transition molding install count (excludes shoe/quarter/base)
  data.trimMoldingInstallCount = 0;
  Object.entries(data.moldingsRounded).forEach(function(pair) {
    var type = pair[0], count = pair[1];
    var typeLower = type.toLowerCase();
    var isTrimMolding = (typeLower.indexOf("t-molding") !== -1 || typeLower.indexOf("transition") !== -1
      || typeLower.indexOf("reducer") !== -1 || typeLower.indexOf("threshold") !== -1)
      && typeLower.indexOf("shoe") === -1 && typeLower.indexOf("quarter") === -1
      && typeLower.indexOf("base") === -1;
    if (isTrimMolding) data.trimMoldingInstallCount += count;
  });

  return data;
}

/**
 * Apply aggregated measurement data to assembly group items.
 *
 * This function is the "smart auto-fill" engine that:
 * - Sets carpet pad quantities
 * - Matches demo types to demo group items
 * - Matches molding counts to molding group items
 * - Matches fixture counts to fixture group items
 * - Sets stair nose quantities for hard surface stairs
 * - Applies default quantities using the primary quantity and generateQty multipliers
 */
function applyMeasurementDataToAssembly() {
  var data = aggregateMeasurementData();
  var carpetStairsSelected = false;
  var carpetStairsPending = null;
  var primaryCat = currentPrimaryItem ? currentPrimaryItem.category : null;

  assemblyGroupItems.forEach(function(gi) {
    var nameLower = (gi.name || "").toLowerCase();

    // -- Carpet pad auto-fill --------------------------------------------
    if (isCarpetMode && isCarpetPadItem(gi.name)) {
      gi.currentQty = calculateCarpetPadQty();
    }

    // Auto-select Carpet Stair Labor group item if stairs are measured (1:1 step count)
    if (isCarpetMode && data.totalStairsQty > 0) {
      var giCatLower = (gi.category || "").toLowerCase();
      var giNameLower = (gi.name || "").toLowerCase();
      // Priority 1: Match "Carpet Stair Labor" by name  qty = exact step count
      if (giNameLower.indexOf("carpet stair labor") !== -1) {
        gi.selected = true;
        gi.currentQty = data.totalStairsQty;
        carpetStairsSelected = true;
      }
      // Priority 2: Fallback to carpet stairs category match
      else if (giCatLower === "carpet stairs" || giCatLower.includes("carpet stair")) {
        if (!carpetStairsSelected && !carpetStairsPending) {
          carpetStairsPending = gi;
        }
      }
    }

    // -- Demo type matching ----------------------------------------------
    Object.entries(data.demoTypes).forEach(function(pair) {
      var demoType = pair[0], sf = pair[1];
      if (sf > 0 && nameLower.indexOf("demo") !== -1 && nameLower.indexOf(demoType.toLowerCase()) !== -1) {
        gi.selected = true;
        gi.currentQty = sf;
      }
    });

    // -- Trim/transition molding install matching ------------------------
    if (data.trimMoldingInstallCount === 0) {
      if (nameLower.includes("transition") || (nameLower.includes("molding") && !nameLower.includes("shoe") && !nameLower.includes("quarter") && !nameLower.includes("base"))) {
        gi.selected = false;
        gi.currentQty = null;
        gi.groupDetails.forEach(function(gd) { gd.selected = false; gd.currentQty = null; });
      }
    }
    if (data.trimMoldingInstallCount > 0) {
      var isTransitionItem = (nameLower.indexOf("transition") !== -1
        || (nameLower.indexOf("molding") !== -1 && nameLower.indexOf("shoe") === -1 && nameLower.indexOf("quarter") === -1))
        && nameLower.indexOf("install") === -1 && nameLower.indexOf("labor") === -1;

      if (isTransitionItem) {
        gi.selected = true;
        gi.currentQty = data.trimMoldingInstallCount;
        // Select first group detail with molding sum, and install labor details
        var firstDetailSet = false;
        gi.groupDetails.forEach(function(gd) {
          var gdName = (gd.desc || gd.itemSku || "").toLowerCase();
          if (gdName.indexOf("install") !== -1 && (gdName.indexOf("molding") !== -1 || gdName.indexOf("trim") !== -1)) {
            gd.selected = true;
            gd.currentQty = data.trimMoldingInstallCount;
          } else if (!firstDetailSet) {
            gd.selected = true;
            gd.currentQty = data.trimMoldingInstallCount;
            firstDetailSet = true;
          }
        });
      }

      // Match standalone install/labor items for moldings
      var isInstallItem = (nameLower.indexOf("molding") !== -1 || nameLower.indexOf("transition") !== -1)
        && (nameLower.indexOf("install") !== -1 || nameLower.indexOf("labor") !== -1)
        && nameLower.indexOf("shoe") === -1 && nameLower.indexOf("quarter") === -1;
      if (isInstallItem) {
        gi.selected = true;
        gi.currentQty = data.trimMoldingInstallCount;
      }
    }

    // -- Individual molding type matching ---------------------------------
    Object.entries(data.moldingsRounded).forEach(function(pair) {
      var moldingType = pair[0], count = pair[1];
      if (count <= 0) return;
      var moldingName = moldingType.replace(/-/g, " ").replace(/_/g, " ");
      var matches = (nameLower.indexOf(moldingName) !== -1 || nameLower.indexOf(moldingType) !== -1)
        && nameLower.indexOf("install") === -1 && nameLower.indexOf("labor") === -1;
      if (matches) {
        gi.selected = true;
        gi.currentQty = count;
      }
    });

    // -- Match moldings and fixtures at the group detail level ------------
    gi.groupDetails.forEach(function(gd) {
      var gdName = (gd.desc || gd.itemSku || "").toLowerCase();

      // Molding detail matching
      Object.entries(data.moldingsRounded).forEach(function(pair) {
        var moldingType = pair[0], count = pair[1];
        if (count <= 0) return;
        var moldingName = moldingType.replace(/-/g, " ").replace(/_/g, " ");
        if ((gdName.indexOf(moldingName) !== -1 || gdName.indexOf(moldingType) !== -1)
            && gdName.indexOf("install") === -1 && gdName.indexOf("labor") === -1) {
          gd.selected = true;
          gd.currentQty = count;
          gi.selected = true;
        }
      });

      // Fixture detail matching
      Object.entries(data.fixtures).forEach(function(pair) {
        var fixtureType = pair[0], count = pair[1];
        if (count <= 0) return;
        var matched = matchFixtureName(gdName, fixtureType);
        if (matched) {
          gd.selected = true;
          gd.currentQty = count;
          gi.selected = true;
        }
      });
    });

    // -- Fixture group item matching -------------------------------------
    Object.entries(data.fixtures).forEach(function(pair) {
      var fixtureType = pair[0], count = pair[1];
      if (count > 0 && matchFixtureName(nameLower, fixtureType)) {
        gi.selected = true;
        gi.currentQty = count;
      }
    });

   //  Stair nose and labor for hard surface flooring 
    var roundedStairNose = Math.ceil(data.stairNoseCount || 0);
    var actualStairCount = data.totalStairsQty || 0;
    
    if (isHardSurfaceFlooringCategory(primaryCat) && (roundedStairNose > 0 || actualStairCount > 0)) {
      // Match stair-related group items
      if (nameLower.indexOf("stair") !== -1 || nameLower.indexOf("step") !== -1 || nameLower.indexOf("nose") !== -1) {
        gi.selected = true;
        // Group item qty = actual stair count (for labor-driven items)
        gi.currentQty = actualStairCount;
        
        gi.groupDetails.forEach(function(gd) {
          var gdName = (gd.desc || gd.itemSku || "").toLowerCase();
          
          // Labor items get actual stair count
          if (gdName.indexOf("labor") !== -1 || gdName.indexOf("install") !== -1) {
            gd.selected = true;
            gd.currentQty = actualStairCount;
          }
          // Stair nose/molding items get calculated stair nose count
          else if (gdName.indexOf("nose") !== -1 || gdName.indexOf("molding") !== -1 || gdName.indexOf("trim") !== -1) {
            gd.selected = true;
            gd.currentQty = roundedStairNose;
          }
          // Riser items (e.g., Primed White Riser) are optional - pre-fill qty but don't auto-select
          else if (gdName.indexOf("riser") !== -1) {
            gd.selected = false;
            gd.currentQty = roundedStairNose;
          }
          // Other stair items (treads, steps, etc.) get actual stair count
          else if (gdName.indexOf("stair") !== -1 || gdName.indexOf("tread") !== -1 || gdName.indexOf("step") !== -1) {
            gd.selected = true;
            gd.currentQty = actualStairCount;
          }
        });
      }
    }
  });

  // If no "Half Set" found, use whatever carpet stair option was found
  if (!carpetStairsSelected && carpetStairsPending && data.totalStairsQty > 0) {
    carpetStairsPending.selected = true;
    carpetStairsPending.currentQty = data.totalStairsQty;
  }

  // -- Apply default quantities to selected items without explicit qty ---
  var primaryQtyEl = document.getElementById("primary-qty");
  var gridQtyEl = document.getElementById("primary-item-qty-grid");
  var baseSF = data.totalSF;
  // Add stair SF for hard surface flooring
  if (isHardSurfaceFlooringCategory(currentPrimaryItem ? currentPrimaryItem.category : null)) {
    baseSF += data.totalStairsSF || 0;
  }
  var primaryQty = toNum(gridQtyEl ? gridQtyEl.value : 0)
    || toNum(primaryQtyEl ? primaryQtyEl.value : 0)
    || baseSF;
  if (isCarpetMode && primaryQty <= 0) {
    var carpetTotals = calculateTotalCarpetYardage();
    primaryQty = carpetTotals.grandTotalSquareYards;
  }

  assemblyGroupItems.forEach(function(gi) {
    if (gi.selected && (gi.currentQty === null || gi.currentQty === 0)) {
      if (gi.generateQty === 1) {
        gi.currentQty = 1;
      } else if (gi.generateQty > 0 && gi.generateQty < 1) {
        // Fractional generateQty = percentage of primary qty
        gi.currentQty = Math.round((primaryQty * gi.generateQty) * 100) / 100;
      } else {
        // generateQty is null, 0, or > 1: pass through primaryQty
        gi.currentQty = primaryQty;
      }
    }

    // Group Details qty based on GD FID 20 (gd.qty):
    //   null/0: inherit GI qty directly
    //   1: literal value of 1
    //   < 1: multiply GI qty  gd.qty
    var giQty = (gi.currentQty !== null && gi.currentQty > 0) ? gi.currentQty : primaryQty;
    gi.groupDetails.forEach(function(gd) {
      if (gd.selected && (gd.currentQty === null || gd.currentQty === 0)) {
        if (gd.qty === 1) {
          gd.currentQty = 1;
        } else if (gd.qty > 0 && gd.qty < 1) {
          gd.currentQty = Math.round((giQty * gd.qty) * 100) / 100;
        } else {
          gd.currentQty = giQty;
        }
      }
    });
  });
}

/**
 * Check if a name string matches a fixture type.
 * @param {string} name - Lowercase name to check
 * @param {string} fixtureType - Fixture type key (e.g. "toilet", "pedestal", "appliances")
 * @returns {boolean}
 */

/**
 * Calculate total riser SF across all rooms.
 * Riser area = count  (stairWidth / 12)  (riserHeight / 12) per entry.
 * @returns {number} Total riser square feet
 */
function calculateRiserSF() {
  var riserSF = 0;
  selectedAreas.forEach(function(area) {
    var m = roomMeasurements[area.id];
    if (!m || !m.stairEntries) return;
    m.stairEntries.forEach(function(entry) {
      var count = toNum(entry.count);
      var widthIn = toNum(entry.width) || DEFAULT_STAIR.WIDTH_IN;
      var riserIn = toNum(entry.riser) || DEFAULT_STAIR.RISER_IN;
      if (count > 0) {
        riserSF += count * (widthIn / 12) * (riserIn / 12);
      }
    });
  });
  return riserSF;
}

/**
 * Check if any riser detail item is currently selected in the assembly grid.
 * @returns {boolean}
 */
function isRiserSelectedInGrid() {
  for (var i = 0; i < assemblyGroupItems.length; i++) {
    var gi = assemblyGroupItems[i];
    for (var j = 0; j < gi.groupDetails.length; j++) {
      var gd = gi.groupDetails[j];
      var gdName = (gd.desc || gd.itemSku || "").toLowerCase();
      if (gdName.indexOf("riser") !== -1 && gd.selected) return true;
    }
  }
  return false;
}

/**
 * Adjust the primary item quantity when a riser item is toggled.
 * If riser is selected, subtract riser SF from the stair contribution.
 * If riser is deselected, restore full stair SF.
 */
function adjustPrimaryQtyForRiser() {
  if (!isHardSurfaceFlooringCategory(currentPrimaryItem ? currentPrimaryItem.category : null)) return;

  var data = aggregateMeasurementData();
  var baseSF = data.totalSF + (data.totalStairsSF || 0);

  if (isRiserSelectedInGrid()) {
    baseSF -= calculateRiserSF();
  }

  if (baseSF < 0) baseSF = 0;

  var primaryQtyEl = document.getElementById("primary-qty");
  var gridQtyInput = document.getElementById("primary-item-qty-grid");
  if (primaryQtyEl) primaryQtyEl.value = baseSF.toFixed(2);
  if (gridQtyInput) gridQtyInput.value = baseSF.toFixed(2);
}

function matchFixtureName(name, fixtureType) {
  if (fixtureType === "toilet") return name.indexOf("toilet") !== -1 || name.indexOf("wc") !== -1;
  if (fixtureType === "pedestal") return name.indexOf("pedestal") !== -1 || name.indexOf("ped sink") !== -1;
  if (fixtureType === "appliances") return name.indexOf("appliance") !== -1 || name.indexOf("appliances") !== -1;
  return false;
}


/* =============================================================================
 * 13. REVIEW & SAVE (Step 4)
 * =============================================================================
 * Populate the review summary and save everything to QuickBase.
 * ========================================================================== */

/** Populate the Step 4 review panel with a summary of all selections. */
function populateReview() {
  var el = function(id) { return document.getElementById(id); };

  // Primary item
  if (el("review-primary") && currentPrimaryItem) {
    el("review-primary").textContent = currentPrimaryItem.desc + " (" + currentPrimaryItem.sku + ")";
  }

  // Quantity
  var primaryQtyEl = el("primary-qty");
  var qtyUomEl = el("qty-uom-display");
  if (el("review-qty") && primaryQtyEl) {
    el("review-qty").textContent = primaryQtyEl.value + " " + (qtyUomEl ? qtyUomEl.textContent : "SF");
  }

  // Work areas
  if (el("review-areas")) {
    var chips = selectedAreas.map(function(a) {
      var label = a.label;
      if (a.closetLabel) label += " " + a.closetLabel.charAt(0).toLowerCase() + a.closetLabel.slice(1);
      return '<span class="review-chip">' + escHtml(label) + '</span>';
    }).join("");
    el("review-areas").innerHTML = chips || "--";
  }

  // Selected items list
  var reviewItems = el("review-items");
  var reviewItemCount = el("review-item-count");
  if (reviewItems && reviewItemCount) {
    var itemCount = 0;
    var html = "";

    assemblyGroupItems.forEach(function(gi) {
      if (!gi.selected) return;
      gi.groupDetails.forEach(function(gd) {
        if (!gd.selected) return;
        itemCount++;
        var qty = gd.currentQty !== null ? gd.currentQty : gi.currentQty || 0;
        html += '<div class="review-item-row">';
        html += '<span class="review-item-name">' + escHtml(gd.desc || gd.itemSku) + '</span>';
        html += '<span class="review-item-qty">' + qty + " " + (gd.uom || "") + '</span>';
        html += '</div>';
      });
    });

    reviewItems.innerHTML = html || '<div class="review-item-row">'
      + '<span class="review-item-name">No items selected</span></div>';
    reviewItemCount.textContent = itemCount;
  }
}

/**
 * Save the bid item and all estimate details to QuickBase, upload photos,
 * and run post-save helpers.
 */

function cleanRel(v) {
  v = (v == null) ? "" : String(v).trim();
  return (v && v !== "0") ? v : "";
}

async function saveAndContinue() {
  try {
    showLoad("Saving bid items...");

    var primaryQty = toNum(document.getElementById("primary-qty") ? document.getElementById("primary-qty").value : 0);

    // Build work areas text (comma-separated room names with closet info)
    var waText = selectedAreas.map(function(a) {
      if (a.closetLabel) {
        return a.label + " " + a.closetLabel.charAt(0).toLowerCase() + a.closetLabel.slice(1);
      }
      return a.label;
    }).join(", ");

    var custCommentEl = document.getElementById("cust-comment");
    var workCommentEl = document.getElementById("work-comment");
    var custComment = custCommentEl ? custCommentEl.value : "";
    var workComment = workCommentEl ? workCommentEl.value : "";

    // Track all created Bid Item RIDs
    var allBidItemRids = [];
    var primaryBidItemRid = null;
    
    // Get max sequence for estimate details
    globalEstimateDetailSequence = await getMaxEstimateDetailSequence(projectId);
    var seq = globalEstimateDetailSequence;

    // Flag to track if we've processed the first Group Item (which gets the Primary Item)
    var isFirstGroupItem = true;

    // =========================================================================
    // PROCESS EACH SELECTED GROUP ITEM &#8594; BID ITEM
    // =========================================================================
    for (var gi_i = 0; gi_i < assemblyGroupItems.length; gi_i++) {
      var gi = assemblyGroupItems[gi_i];
      if (!gi.selected) continue;

      var giQty = gi.currentQty !== null ? gi.currentQty : primaryQty;

      // -----------------------------------------------------------------------
      // CREATE BID ITEM FOR THIS GROUP ITEM
      // -----------------------------------------------------------------------
      var biFields = {};
      biFields[BI.REL_PROJ] = projectId;
      biFields[BI.REL_GROUP_ITEM] = gi.giRid;  // FID 967
      biFields[BI.WA_ENT] = waText;             // FID 7
      biFields[BI.WA_TXT] = waText;             // FID 608
      
      if (isFirstGroupItem) {
        // First Group Item uses Primary Item's SKU and UOM, but Group Item's Waste
        biFields[BI.ITEM_SKU] = currentPrimaryItem.sku;
        biFields[BI.QTY] = toQBNum(primaryQty);
        biFields[BI.WASTE] = toQBNum(gi.wastePct || 0);  // Use Group Item's waste
        biFields[BI.UOM] = currentPrimaryItem.uom || "SF";
      } else {
        // Subsequent Group Items use first selected Group Detail's info
        var firstDetail = gi.groupDetails.find(function(gd) { return gd.selected; });
        biFields[BI.ITEM_SKU] = firstDetail ? (firstDetail.itemSku || gi.name) : gi.name;
        biFields[BI.QTY] = toQBNum(giQty);
        biFields[BI.WASTE] = toQBNum(gi.wastePct || 0);
        biFields[BI.UOM] = gi.uom || "EA";
      }

      var bidItemRid = await qbAdd(DBID_BID_ITEMS, biFields);
      allBidItemRids.push(bidItemRid);
      
      // Track the first bid item for photo uploads
      if (isFirstGroupItem) {
        primaryBidItemRid = bidItemRid;
      }

      // -----------------------------------------------------------------------
      // CREATE ESTIMATE DETAILS FOR THIS BID ITEM
      // -----------------------------------------------------------------------
      
      // If this is the FIRST Group Item, add Primary Item as first Estimate Detail
      if (isFirstGroupItem) {
        seq++;
        var edPrimary = {};
        edPrimary[ED.REL_PROJ] = projectId;
        edPrimary[ED.REL_BI] = bidItemRid;
        edPrimary[ED.REL_ITEM] = cleanRel(currentPrimaryItem.id);
        edPrimary[ED.DESC] = currentPrimaryItem.desc;
        edPrimary[ED.QTY] = toQBNum(primaryQty);
        edPrimary[ED.COST] = toQBNum(currentPrimaryItem.cost);
        edPrimary[ED.RATE] = toQBNum(currentPrimaryItem.rate);
        edPrimary[ED.QTY_UOM] = currentPrimaryItem.qtyUom || "SF";
        edPrimary[ED.UOM] = currentPrimaryItem.uom || "SF";
        edPrimary[ED.WASTE] = toQBNum(gi.wastePct || 0);  // Use Group Item's waste
        edPrimary[ED.CUST] = custComment;
        edPrimary[ED.WORK] = workComment;
        edPrimary[ED.RES] = currentPrimaryItem.resourceRid || "";
        edPrimary[ED.SEQUENCE] = seq;
        await qbAdd(DBID_EST_DETAILS, edPrimary);
        
        isFirstGroupItem = false;  // Mark that we've processed the first one
      }

      // Add Estimate Details for each selected Group Detail
      for (var gd_i = 0; gd_i < gi.groupDetails.length; gd_i++) {
        var gd = gi.groupDetails[gd_i];
        if (!gd.selected) continue;

        seq++;
        var gdQty = gd.currentQty !== null ? gd.currentQty : giQty;

        var edFields = {};
        edFields[ED.REL_PROJ] = projectId;
        edFields[ED.REL_BI] = bidItemRid;
        edFields[ED.REL_ITEM] = cleanRel(gd.itemRid);
        edFields[ED.DESC] = gd.desc || gd.purchDesc || "";
        edFields[ED.QTY] = toQBNum(gdQty);
        edFields[ED.COST] = toQBNum(gd.cost);
        edFields[ED.RATE] = toQBNum(gd.rate);
        edFields[ED.QTY_UOM] = gd.qtyUom || "EA";
        edFields[ED.UOM] = gd.uom || "EA";
        edFields[ED.WASTE] = toQBNum(gd.wastePct || 0);
        edFields[ED.RES] = currentPrimaryItem.resourceRid || "";
        edFields[ED.SEQUENCE] = seq;
        await qbAdd(DBID_EST_DETAILS, edFields);
      }

      // -----------------------------------------------------------------------
      // POST-SAVE: Copy Related Task from GI_REL_TASK to REL_TASK
      // -----------------------------------------------------------------------
      await runBidItemPostSaveHelpers(bidItemRid, waText);
    }

    // =========================================================================
    // UPLOAD PHOTOS (link to primary/first bid item)
    // =========================================================================
    if (primaryBidItemRid) {
      await uploadPhotosToAttachments(primaryBidItemRid);
    }

    // =========================================================================
    // SAVE MEASURES & MEASURE DETAILS
    // =========================================================================
    try {
      var measureData = aggregateMeasurementData();
      
      // Calculate totals for header
      var totalWidth = 0, totalLength = 0, totalStairWidth = 0;
      selectedAreas.forEach(function(area) {
        var m = roomMeasurements[area.id];
        if (m && m.dimensions) {
          m.dimensions.forEach(function(d) {
            var w = toNum(d.width);
            var l = toNum(d.length);
            if (w > totalWidth) totalWidth = w;
            if (l > totalLength) totalLength = l;
          });
        }
        if (m && m.stairEntries) {
          m.stairEntries.forEach(function(se) {
            var sw = toNum(se.width);
            if (sw > totalStairWidth) totalStairWidth = sw;
          });
        }
      });
      
      var meFields = {};
      meFields[ME.REL_PROJECT] = projectId;
      meFields[ME.REL_ITEM] = currentPrimaryItem.id;
      meFields[ME.ITEM_SKU] = currentPrimaryItem.sku || "";
      meFields[ME.ITEM_DESC] = currentPrimaryItem.desc || "";
      meFields[ME.TYPE] = currentPrimaryItem.category || "";
      meFields[ME.PRIMARY_QTY] = toQBNum(primaryQty);
      meFields[ME.PM_WIDTH] = toQBNum(patternMatchWidth);
      meFields[ME.PM_LENGTH] = toQBNum(patternMatchLength);
      meFields[ME.MEASURED_AREAS] = waText;
      meFields[ME.WIDTH] = toQBNum(totalWidth);
      meFields[ME.LENGTH] = toQBNum(totalLength);
      meFields[ME.DIRECTION] = currentCarpetDirection || "";
      
      if (isCarpetMode) {
        var carpetTotals = calculateTotalCarpetYardage();
        meFields[ME.TOTAL_SY] = toQBNum(carpetTotals.grandTotalSquareYards);
        meFields[ME.TOTAL_LF] = toQBNum(carpetTotals.totalLinearFeet);
        meFields[ME.TOTAL_CUTS] = toQBNum(carpetTotals.totalStrips);
      }
      
      if (measureData.moldingInstallCount > 0) {
        meFields[ME.MEASURED_MOLDINGS] = "1";
        meFields[ME.MOLDING_COUNT] = toQBNum(measureData.moldingInstallCount);
        var totalMoldingLF = 0;
        Object.entries(measureData.moldings).forEach(function(pair) {
          totalMoldingLF += pair[1] * 8;
        });
        meFields[ME.TOTAL_MOLDING_LF] = toQBNum(totalMoldingLF);
      }
      
      meFields[ME.STAIR_QTY] = toQBNum(measureData.totalStairsQty);
      meFields[ME.STAIR_WIDTH] = toQBNum(totalStairWidth);
      var aggregatedNotes = [];
      selectedAreas.forEach(function(area) {
        var rm = roomMeasurements[area.id];
        if (rm && rm.notes && rm.notes.trim()) {
          var roomLabel = area.closetLabel ? area.label + " " + area.closetLabel : area.label;
          aggregatedNotes.push(roomLabel + ": " + rm.notes.trim());
        }
      });
      if (workComment) aggregatedNotes.push("Work: " + workComment);
      meFields[ME.NOTES] = aggregatedNotes.join("\n") || "";

      var measureRid = await qbAdd(DBID_MEASURES, meFields);

      // Upload photos to measures header (up to 3)
      var photoIdx = 0;
      var photoFids = [ME.PICTURE_1, ME.PICTURE_2, ME.PICTURE_3];
      for (var ai = 0; ai < selectedAreas.length && photoIdx < 3; ai++) {
        var areaM = roomMeasurements[selectedAreas[ai].id];
        if (areaM && areaM.photos) {
          for (var pi = 0; pi < areaM.photos.length && photoIdx < 3; pi++) {
            var photo = areaM.photos[pi];
            var fname = selectedAreas[ai].label.replace(/[^a-zA-Z0-9]/g, "_") + "_" + (photo.name || "photo.jpg");
            await qbUploadFile(DBID_MEASURES, measureRid, photoFids[photoIdx], photo.data, fname);
            photoIdx++;
          }
        }
      }

      // Save Measure Details (one per room)
      for (var ri = 0; ri < selectedAreas.length; ri++) {
        var area = selectedAreas[ri];
        var rm = roomMeasurements[area.id];
        if (!rm) continue;

        var mdFields = {};
        mdFields[MD.REL_MEASURE] = measureRid;
        mdFields[MD.ROOM_NAME] = area.closetLabel ? area.label + " " + area.closetLabel : area.label;
        mdFields[MD.TOTAL_SF] = toQBNum(rm.totalSF || 0);
        mdFields[MD.DEMO_TYPE] = rm.demoType || "";
        mdFields[MD.NOTES] = rm.notes || "";
        mdFields[MD.CARPET_DIRECTION] = rm.carpetDirection || "";

        if (rm.dimensions && rm.dimensions.length > 0) {
          mdFields[MD.DIMENSIONS_JSON] = JSON.stringify(rm.dimensions);
          var maxW = 0, maxL = 0;
          rm.dimensions.forEach(function(d) {
            var w = toNum(d.width);
            var l = toNum(d.length);
            if (w > maxW) maxW = w;
            if (l > maxL) maxL = l;
          });
          mdFields[MD.WIDTH] = toQBNum(maxW);
          mdFields[MD.LENGTH] = toQBNum(maxL);
        }
        mdFields[MD.NOTES] = (rm.notes && rm.notes.trim()) ? rm.notes.trim() : "";

        if (rm.carpetCalc) {
          mdFields[MD.CARPET_STRIPS] = toQBNum(rm.carpetCalc.strips || 0);
          mdFields[MD.CARPET_CUT_LENGTH] = toQBNum(rm.carpetCalc.cutLength || 0);
          mdFields[MD.CARPET_LF] = toQBNum(rm.carpetCalc.linearFeet || 0);
          mdFields[MD.CARPET_SY] = toQBNum(rm.carpetCalc.squareYards || 0);
        }

        if (rm.moldings) {
          var totalMoldingQty = 0;
          if (rm.moldings['t-molding']) {
            mdFields[MD.TRANSITION_QTY] = toQBNum(rm.moldings['t-molding']);
            totalMoldingQty += rm.moldings['t-molding'];
          }
          if (rm.moldings['reducer']) {
            mdFields[MD.REDUCER_QTY] = toQBNum(rm.moldings['reducer']);
            totalMoldingQty += rm.moldings['reducer'];
          }
          if (rm.moldings['threshold']) {
            mdFields[MD.THRESHOLD_QTY] = toQBNum(rm.moldings['threshold']);
            totalMoldingQty += rm.moldings['threshold'];
          }
          mdFields[MD.MOLDING_QTY] = toQBNum(totalMoldingQty);
        }

        if (rm.fixtures) {
          if (rm.fixtures['toilet']) mdFields[MD.TOILET_QTY] = toQBNum(rm.fixtures['toilet']);
          if (rm.fixtures['pedestal']) mdFields[MD.PEDESTAL_QTY] = toQBNum(rm.fixtures['pedestal']);
          if (rm.fixtures['appliances']) mdFields[MD.APPLIANCE_QTY] = toQBNum(rm.fixtures['appliances']);
        }

        if (rm.stairsCalc) {
          mdFields[MD.STAIR_SY] = toQBNum(rm.stairsCalc.squareYards || 0);
        }
        if (rm.stairEntries && rm.stairEntries.length > 0) {
          var totalStairQty = 0;
          var maxStairWidth = 0;
          rm.stairEntries.forEach(function(se) {
            totalStairQty += toNum(se.count || se.qty || 0);
            var sw = toNum(se.width || 0);
            if (sw > maxStairWidth) maxStairWidth = sw;
          });
          mdFields[MD.STAIR_QTY] = toQBNum(totalStairQty);
          mdFields[MD.STAIR_WIDTH] = toQBNum(maxStairWidth);
        }

        await qbAdd(DBID_MEASURE_DETAILS, mdFields);
      }
    } catch (measureErr) {
      console.error("Error saving measurements:", measureErr);
    }

    hideLoad();
    toast("Saved " + allBidItemRids.length + " bid item(s) successfully!", "success");

    setTimeout(function() { resetForNextItem(); }, POST_SAVE_RESET_DELAY_MS);
  } catch (err) {
    hideLoad();
    toast("Error saving: " + err.message, "error");
  }
}

// -- Save Helper Functions ---------------------------------------------------

/**
 * Get the highest existing sequence number for estimate details in a project.
 * @param {string} projId
 * @returns {Promise<number>}
 */
async function getMaxEstimateDetailSequence(projId) {
  try {
    var xml = await qbQuery(
      DBID_EST_DETAILS,
      "{'" + ED.REL_PROJ + "'.EX.'" + projId + "'}",
      String(ED.SEQUENCE),
      "slist." + ED.SEQUENCE + ".sortorder-D.num-1"
    );
    var rec = xml.querySelector("record");
    if (rec) {
      var seqNode = rec.querySelector('f[id="' + ED.SEQUENCE + '"]');
      return toNum(seqNode ? seqNode.textContent : "0");
    }
    return 0;
  } catch (e) { return 0; }
}

/**
 * Upload all room photos to the QB Attachments table, linked to the bid item.
 * @param {string} bidItemRid
 */
async function uploadPhotosToAttachments(bidItemRid) {
  var allPhotos = [];
  selectedAreas.forEach(function(area) {
    var m = roomMeasurements[area.id];
    if (m && m.photos && m.photos.length > 0) {
      m.photos.forEach(function(photo) {
        allPhotos.push({
          data: photo.data,
          name: photo.name || ("photo_" + (allPhotos.length + 1) + ".jpg"),
          room: area.label
        });
      });
    }
  });

  if (allPhotos.length === 0) return;

  for (var i = 0; i < allPhotos.length; i++) {
    var photo = allPhotos[i];
    var fileName = photo.room.replace(/[^a-zA-Z0-9]/g, "_") + "_" + photo.name;
    try {
      var attFields = {};
      attFields[ATT.REL_PROJECT] = projectId;
      attFields[ATT.REL_BID_ITEM] = bidItemRid;
      attFields[ATT.TITLE] = photo.room + " - Photo " + (i + 1);
      attFields[ATT.TYPE] = "Room Photo";
      var attRid = await qbAdd(DBID_ATTACHMENTS, attFields);
      await qbUploadFile(DBID_ATTACHMENTS, attRid, ATT.ATTACHMENT_1, photo.data, fileName);
    } catch (e) {
      console.error("Error uploading photo", (i + 1), ":", e);
    }
  }
}

/**
 * Fetch a single field value from a bid item record.
 * @param {string} bidItemRid
 * @param {number} fid
 * @returns {Promise<string>}
 */
async function fetchBidItemFieldValue(bidItemRid, fid) {
  if (!bidItemRid || !fid) return "";
  try {
    var url = "/db/" + DBID_BID_ITEMS
      + "?a=API_DoQuery&useFids=1"
      + "&apptoken=" + encodeURIComponent(APP_TOKEN)
      + "&query=" + encodeURIComponent("{'3'.EX.'" + bidItemRid + "'}")
      + "&clist=" + encodeURIComponent(String(fid))
      + "&options=num-1";
    
    var response = await fetch(url, { credentials: "include" });
    
    // Handle 403 and other error responses gracefully
    if (!response.ok) {
      console.warn("fetchBidItemFieldValue: HTTP " + response.status + " for FID " + fid);
      return "";
    }
    
    var xml = new DOMParser().parseFromString(await response.text(), "text/xml");
    var errNode = xml.querySelector("errcode");
    if (errNode && errNode.textContent !== "0") {
      console.warn("fetchBidItemFieldValue: QB error for FID " + fid);
      return "";
    }
    
    var rec = xml.querySelector("record");
    if (rec) {
      var fieldNode = rec.querySelector('f[id="' + fid + '"]');
      return fieldNode ? fieldNode.textContent : "";
    }
    return "";
  } catch (e) {
    console.warn("fetchBidItemFieldValue: Exception for FID " + fid, e);
    return "";
  }
}

/**
 * Copy the GI_REL_TASK field value into the REL_TASK field on the bid item.
 * This links the bid item to the correct task via the group item relationship.
 */
async function copyGroupItemRelatedTaskIntoRelatedTask(bidItemRid) {
  var val = await fetchBidItemFieldValue(bidItemRid, BI.GI_REL_TASK);
  if (!val) return;
  try {
    var fields = {};
    fields[BI.REL_TASK] = val;
    await qbEdit(DBID_BID_ITEMS, bidItemRid, fields);
  } catch (e) { /* non-critical */ }
}

/**
 * Populate the sales description field on the bid item by polling for the
 * combined text (which is computed server-side and may take a moment).
 * Retries up to 4 times with increasing delays.
 */
async function populateSalesDescriptionFromCombinedText(bidItemRid, workAreas) {
  try {
    // Query all Estimate Details for this Bid Item
    var clist = [ED.DESC, ED.EXCLUDE_FROM_SALES, ED.SEQUENCE].join(".");
    var xml = await qbQuery(
      DBID_EST_DETAILS,
      "{'" + ED.REL_BI + "'.EX.'" + bidItemRid + "'}",
      clist,
      "slist." + ED.SEQUENCE
    );

    var descriptions = [];
    xml.querySelectorAll("record").forEach(function(rec) {
      var excludeNode = rec.querySelector('f[id="' + ED.EXCLUDE_FROM_SALES + '"]');
      var excludeValue = excludeNode ? excludeNode.textContent.trim().toLowerCase() : "";
      
      // Skip if FID 92 is checked (value is "1", "true", or "yes")
      if (excludeValue === "1" || excludeValue === "true" || excludeValue === "yes") {
        return;
      }

      var descNode = rec.querySelector('f[id="' + ED.DESC + '"]');
      var desc = descNode ? descNode.textContent.trim() : "";

      if (desc) {
        descriptions.push(desc);
      }
    });

    // Build final sales description: Work Areas on first line, then descriptions
    var salesDesc = "";
    if (workAreas) {
      salesDesc = workAreas;
    }
    if (descriptions.length > 0) {
      if (salesDesc) salesDesc += "\n";
      salesDesc += descriptions.join("\n");
    }

    if (salesDesc) {
      var fields = {};
      fields[BI.SALES] = salesDesc;
      await qbEdit(DBID_BID_ITEMS, bidItemRid, fields);
    }
  } catch (e) {
    console.warn("populateSalesDescriptionFromCombinedText error:", e);
  }
}

/**
 * Run all post-save operations for a bid item.
 * @param {string} bidItemRid
 * @param {string} workAreas
 */
async function runBidItemPostSaveHelpers(bidItemRid, workAreas) {
  await copyGroupItemRelatedTaskIntoRelatedTask(bidItemRid);
  await populateSalesDescriptionFromCombinedText(bidItemRid, workAreas);
}


/* =============================================================================
 * 14. WIZARD NAVIGATION
 * =============================================================================
 * Step progression, validation, and reset.
 * ========================================================================== */

/** Update the progress bar dots, labels, and step visibility. */
function updateProg() {
  for (var i = 1; i <= TOTAL_STEPS; i++) {
    var dot = document.getElementById("prog-dot-" + i);
    var label = document.getElementById("prog-label-" + i);
    var line = document.getElementById("prog-line-" + i);

    if (!dot || !label) continue;

    dot.classList.remove("active", "completed");
    label.classList.remove("active");
    if (line) line.classList.remove("completed");

    if (i < currentStep) {
      dot.classList.add("completed");
      dot.innerHTML = "&#10003;";
      if (line) line.classList.add("completed");
    } else if (i === currentStep) {
      dot.classList.add("active");
      dot.textContent = i;
      label.classList.add("active");
    } else {
      dot.textContent = i;
    }
  }

  // Show/hide step content panels
  for (var j = 1; j <= TOTAL_STEPS; j++) {
    var stepEl = document.getElementById("step-" + j);
    if (stepEl) stepEl.classList.toggle("active", j === currentStep);
  }

  // Back button visibility
  var btnBack = document.getElementById("btn-back");
  if (btnBack) btnBack.style.display = currentStep > 1 ? "block" : "none";

  // Next button text changes on final step
  var btnNext = document.getElementById("btn-next");
  if (btnNext) {
    if (currentStep === TOTAL_STEPS) {
      btnNext.textContent = "Save & Continue";
      btnNext.className = "btn btn-success";
    } else {
      btnNext.textContent = "Next";
      btnNext.className = "btn btn-primary";
    }
  }
}

/**
 * Validate the current step before proceeding.
 * @param {number} step - Step number to validate
 * @returns {boolean} True if valid
 */
function validate(step) {
  if (step === 1) {
    if (!currentPrimaryItem) {
      toast("Step 1: Please select a primary item first", "error");
      return false;
    }
    return true;
  }

  if (step === 2) {
    if (!selectedAreas || selectedAreas.length === 0) {
      toast("Step 2: Please select at least one room", "error");
      return false;
    }
    var unmeasured = selectedAreas.filter(function(a) { return !roomHasMeasurements(a.id); });
    if (unmeasured.length > 0) {
      toast("Step 2: Please measure: " + unmeasured.map(function(a) { return a.label; }).join(", "), "error");
      updatePillStates();
      return false;
    }
    return true;
  }

  if (step === 3) {
    var qtyEl = document.getElementById("primary-qty");
    var qtyValue = toNum(qtyEl ? qtyEl.value : 0);
    if (qtyValue <= 0) {
      toast("Step 3: Please confirm quantity", "error");
      return false;
    }
    if (!assemblyGroupItems.some(function(gi) { return gi.selected; })) {
      toast("Step 3: Select at least one assembly item", "error");
      return false;
    }
    return true;
  }

  return true;
}

/** Advance to the next step (or save on the final step). */
function nextStep() {
  try {
    if (!validate(currentStep)) return;

    if (currentStep === TOTAL_STEPS) {
      saveAndContinue();
      return;
    }

    currentStep++;
    updateProg();

    // Step-specific initialization
    if (currentStep === 2) updateStep2ProductReminder();
    if (currentStep === 3) {
      autoPopulateQtyFromMeasurements();
      updateAsmCtx();
      buildMeasurementDataCard();
      if (assemblyGroupItems && assemblyGroupItems.length > 0) {
        assemblyGroupItems.forEach(function(gi) {
          gi.currentQty = null;
          gi.selected = gi.loadDefault;
          gi.groupDetails.forEach(function(gd) {
            gd.currentQty = null;
            gd.selected = gd.isDefault;
          });
        });
        renderAssemblyGrid();
      }
      var gridQtyInput = document.getElementById("primary-item-qty-grid");
      var calcQtyInput = document.getElementById("primary-qty");
      if (gridQtyInput && calcQtyInput && calcQtyInput.value) {
        gridQtyInput.value = calcQtyInput.value;
      }
    }
    if (currentStep === 4) populateReview();

    // Scroll to top
    var mainEl = document.querySelector(".main");
    if (mainEl) mainEl.scrollTop = 0;
  } catch (err) {
    toast("Error: " + err.message, "error");
  }
}

/** Go back to the previous step. */
function prevStep() {
  if (currentStep > 1) {
    currentStep--;
    updateProg();
    var mainEl = document.querySelector(".main");
    if (mainEl) mainEl.scrollTop = 0;
  }
}

/** Reset all state for creating the next bid item. */
function resetForNextItem() {
  currentStep = 1;
  currentPrimaryItem = null;
  selectedAreas = [];
  roomMeasurements = {};
  assemblyGroupItems = [];
  currentDimensionRows = [];
  currentRoomPhotos = [];
  currentStairEntries = [];
  isCarpetMode = false;

  // Reset form elements
  var resetEl = function(id, prop, val) { var el = document.getElementById(id); if (el) el[prop] = val; };
  resetEl("primary-search", "value", "");
  resetEl("assembly-select", "value", "");
  resetEl("cust-comment", "value", "");
  resetEl("work-comment", "value", "");

  var primarySelected = document.getElementById("primary-selected");
  if (primarySelected) primarySelected.classList.remove("show");
  var carpetInfoCard = document.getElementById("carpet-info-card");
  if (carpetInfoCard) carpetInfoCard.classList.remove("show");
  var gridContainer = document.getElementById("grid-container");
  if (gridContainer) gridContainer.innerHTML = "";

  updateProg();
  renderAreaGroups();
  renderSelectedAreas();
  updateMeasureSummary();

  var mainEl = document.querySelector(".main");
  if (mainEl) mainEl.scrollTop = 0;
}


/* =============================================================================
 * 15. UI RENDERING HELPERS
 * =============================================================================
 * Functions that update various UI elements across multiple steps.
 * ========================================================================== */

/** Show product info reminder at top of Step 2. */
function updateStep2ProductReminder() {
  var reminderEl = document.getElementById("step2-product-reminder");
  var summaryRow = document.getElementById("carpet-summary-row");

  if (currentPrimaryItem) {
    var el = function(id) { return document.getElementById(id); };
    if (el("step2-product-name")) el("step2-product-name").textContent = currentPrimaryItem.desc || "(no description)";
    if (el("step2-product-sku")) el("step2-product-sku").textContent = "SKU: " + (currentPrimaryItem.sku || "--");
    if (el("step2-product-uom")) el("step2-product-uom").textContent = "UOM: " + (currentPrimaryItem.uom || "--");
    if (el("step2-product-rate")) el("step2-product-rate").textContent = "Rate: $" + (currentPrimaryItem.rate ? toNum(currentPrimaryItem.rate).toFixed(2) : "--");
    if (reminderEl) reminderEl.style.display = "block";

    if (isCarpetMode) {
      if (summaryRow) summaryRow.style.display = "flex";
      updateCarpetSummaryTotals();
    } else {
      if (summaryRow) summaryRow.style.display = "none";
    }
  } else {
    if (reminderEl) reminderEl.style.display = "none";
  }
}

/** Auto-fill the primary quantity input from room measurements. */
function autoPopulateQtyFromMeasurements() {
  var totalSF = 0;
  var measuredCount = 0;

  selectedAreas.forEach(function(area) {
    var m = roomMeasurements[area.id];
    if (!m) return;
    if (m.totalSF > 0) { totalSF += m.totalSF; measuredCount++; }
    else if (roomHasMeasurements(area.id)) { measuredCount++; }

    // For non-carpet, include stair SF in total
    if (!isCarpetMode && m.stairsCalc && m.stairsCalc.squareFeet) {
      totalSF += m.stairsCalc.squareFeet;
    }
  });

  var primaryQtyEl = document.getElementById("primary-qty");
  var qtySourceEl = document.getElementById("qty-source");

  if (primaryQtyEl) {
    if (isCarpetMode) {
      var totals = calculateTotalCarpetYardage();
      // Use optimized plan quantities if available, otherwise simple calculation
      if (currentOptimizedPlan) {
        primaryQtyEl.value = currentOptimizedPlan.totalSY.toFixed(2);
        if (qtySourceEl) {
          qtySourceEl.textContent = "From " + measuredCount + " measured room"
            + (measuredCount !== 1 ? "s" : "") + " ("
            + currentOptimizedPlan.cuts.length + " cuts, "
            + currentOptimizedPlan.totalLinearFt.toFixed(0) + " LF)";
        }
      } else {
        primaryQtyEl.value = totals.grandTotalSquareYards.toFixed(2);
        if (qtySourceEl) {
          qtySourceEl.textContent = "From " + measuredCount + " measured room"
            + (measuredCount !== 1 ? "s" : "") + " ("
            + totals.totalStrips + " cuts, "
            + totals.totalLinearFeet.toFixed(0) + " LF)";
        }
      }
    } else {
      primaryQtyEl.value = totalSF > 0 ? totalSF.toFixed(2) : "";
      if (qtySourceEl) {
        qtySourceEl.textContent = "From " + measuredCount + " measured room"
          + (measuredCount !== 1 ? "s" : "");
      }
    }
  }

  var qtyUomDisplay = document.getElementById("qty-uom-display");
  if (qtyUomDisplay) qtyUomDisplay.textContent = isCarpetMode ? "SY" : "SF";
  updateMeasureSummary();
}

/** Update the measurement summary counters (rooms counted, total SF/SY). */
function updateMeasureSummary() {
  var measuredCount = 0;
  var totalSF = 0;

  selectedAreas.forEach(function(area) {
    if (roomMeasurements[area.id] && roomMeasurements[area.id].totalSF > 0) {
      measuredCount++;
      totalSF += roomMeasurements[area.id].totalSF;
    }
  });

  var el = function(id) { return document.getElementById(id); };
  if (el("rooms-measured-count")) el("rooms-measured-count").textContent = measuredCount;
  if (el("total-floor-sf")) el("total-floor-sf").textContent = Math.round(totalSF);

  if (isCarpetMode) {
    var totals = calculateTotalCarpetYardage();
    if (el("total-carpet-sy")) el("total-carpet-sy").textContent = totals.grandTotalSquareYards.toFixed(2);
  }

  updateCarpetSummaryTotals();
}

/** Update the Step 3 context summary (primary item and room names). */
function updateAsmCtx() {
  var ctxPrimary = document.getElementById("ctx-primary");
  var ctxAreas = document.getElementById("ctx-areas");

  if (ctxPrimary && currentPrimaryItem) {
    ctxPrimary.textContent = "Primary: " + (currentPrimaryItem.desc || currentPrimaryItem.sku || "--").substring(0, 30);
  }
  if (ctxAreas) {
    var names = selectedAreas.map(function(a) { return a.label; }).join(", ");
    ctxAreas.textContent = "Rooms: " + (names.length > 40 ? names.substring(0, 40) + "..." : names);
  }
}

/** Build the measurement data summary card shown in Step 3. */
function buildMeasurementDataCard() {
  var card = document.getElementById("measurement-data-card");
  var grid = document.getElementById("measurement-data-grid");
  if (!card || !grid) return;

  var data = aggregateMeasurementData();
  var html = "";

  // Total floor area (include stair SF for hard surface flooring)
  var displayTotalSF = data.totalSF;
  if (isHardSurfaceFlooringCategory(currentPrimaryItem ? currentPrimaryItem.category : null)) {
    displayTotalSF += data.totalStairsSF || 0;
  }
  html += '<div class="measurement-data-row">'
    + '<span class="label"><span class="icon">&#128207;</span> Total Floor Area</span>'
    + '<span class="value">' + Math.round(displayTotalSF) + ' SF</span></div>';

  // Stair area (shown separately)
  if (data.totalStairsSF > 0) {
    html += '<div class="measurement-data-row">'
      + '<span class="label"><span class="icon">&#129692;</span> Stair Area</span>'
      + '<span class="value">' + Math.round(data.totalStairsSF) + ' SF</span></div>';
  }

  // Carpet yardage
  if (isCarpetMode && data.totalCarpetSY > 0) {
    html += '<div class="measurement-data-row">'
      + '<span class="label"><span class="icon">&#129526;</span> Carpet Yardage</span>'
      + '<span class="value">' + data.totalCarpetSY.toFixed(2) + ' SY ('
      + data.totalCarpetCuts + ' cuts)</span></div>';
  }

  // Demo types
  Object.entries(data.demoTypes).forEach(function(pair) {
    var type = pair[0], sf = pair[1];
    if (sf > 0) {
      html += '<div class="measurement-data-row demo-row">'
        + '<span class="label"><span class="icon">&#128296;</span> Demo ' + escHtml(type) + '</span>'
        + '<span class="value">' + Math.round(sf) + ' SF</span></div>';
    }
  });

  // Moldings
  Object.entries(data.moldingsRounded).forEach(function(pair) {
    var type = pair[0], count = pair[1];
    if (count > 0) {
      var label = type.replace(/-/g, " ").replace(/_/g, " ");
      html += '<div class="measurement-data-row">'
        + '<span class="label"><span class="icon">&#128207;</span> ' + escHtml(label) + '</span>'
        + '<span class="value">' + count + '</span></div>';
    }
  });

  // Fixtures
  Object.entries(data.fixtures).forEach(function(pair) {
    var type = pair[0], count = pair[1];
    if (count > 0) {
      html += '<div class="measurement-data-row fixture-row">'
        + '<span class="label"><span class="icon">&#128701;</span> ' + escHtml(type) + '</span>'
        + '<span class="value">' + count + '</span></div>';
    }
  });

  if (html) {
    grid.innerHTML = html;
    card.style.display = "block";
  } else {
    card.style.display = "none";
  }
}

// -- Area Pills & Chips Rendering --------------------------------------------

/** Render the area group pill buttons in Step 2. */
function renderAreaGroups() {
  var container = document.getElementById("area-groups-container");
  if (!container) return;

  var html = "";
  areaGroups.forEach(function(group) {
    var isCollapsed = group.id !== 'entry_core';
    html += '<div class="area-group' + (isCollapsed ? ' collapsed' : '') + '" id="group-' + group.id + '">';
    html += '<div class="area-group-label" data-group-id="' + group.id + '">' + escHtml(group.label) + '</div>';
    html += '<div class="area-pills">';

    group.items.forEach(function(item) {
      var isSelected = selectedAreas.some(function(a) { return a.id === item.id; });
      var hasMeasurement = roomMeasurements[item.id] && roomMeasurements[item.id].totalSF > 0;
      var needsMeasurement = isSelected && !hasMeasurement;

      var wrapperClass = "area-pill-wrapper";
      if (hasMeasurement) wrapperClass += " has-measurement";
      if (isSelected) wrapperClass += " selected";
      if (needsMeasurement) wrapperClass += " needs-measurement";

      html += '<div class="' + wrapperClass + '" data-area-id="' + item.id
        + '" data-area-label="' + escHtml(item.label)
        + '" data-has-closets="' + (item.hasClosets ? "1" : "0") + '">';
      html += '<button type="button" class="area-pill">' + escHtml(item.label) + '</button>';
      html += '<button type="button" class="area-pill-measure">&#128207;</button>';
      html += '</div>';
    });

    html += '</div></div>';
  });

container.innerHTML = html;
  container.querySelectorAll(".area-group-label").forEach(function(label) {
    label.addEventListener("click", function(e) {
      if (e.target.closest(".closet-picker")) return;
      var group = label.closest(".area-group");
      if (group) {
        var wasCollapsed = group.classList.contains("collapsed");
        group.classList.toggle("collapsed");
        if (wasCollapsed) {
          setTimeout(function() {
            group.scrollIntoView({ behavior: "smooth", block: "start" });
          }, 100);
        }
      }
    });
  });
  attachAreaPillListeners();
}

/** Attach click listeners to all area pill and measure buttons. */
function attachAreaPillListeners() {
  document.querySelectorAll(".area-pill-wrapper").forEach(function(wrapper) {
    var areaId = wrapper.dataset.areaId;
    var areaLabel = wrapper.dataset.areaLabel;
    var hasClosets = wrapper.dataset.hasClosets === "1";

    var pillBtn = wrapper.querySelector(".area-pill");
    var measureBtn = wrapper.querySelector(".area-pill-measure");

    if (pillBtn) {
      pillBtn.addEventListener("click", function(e) {
        e.preventDefault();
        e.stopPropagation();
        toggleAreaSelection(areaId, areaLabel, hasClosets);
      });
    }

    if (measureBtn) {
      measureBtn.addEventListener("click", function(e) {
        e.preventDefault();
        e.stopPropagation();
        var alreadySelected = selectedAreas.some(function(a) { return a.id === areaId; });
        if (!alreadySelected && hasClosets) {
          pendingClosetMeasure = true;
          var groupId = findGroupIdForArea(areaId);
          renderClosetPicker(areaId, areaLabel, groupId);
        } else {
          if (!alreadySelected) {
            addAreaToSelection(areaId, areaLabel);
          }
          openMeasureModal(areaId, areaLabel);
        }
      });
    }
  });
}

/** Update visual states of all area pill wrappers and the unmeasured warning. */
function updatePillStates() {
  document.querySelectorAll(".area-pill-wrapper").forEach(function(wrapper) {
    var areaId = wrapper.dataset.areaId;
    var isSelected = selectedAreas.some(function(a) { return a.id === areaId; });
    var hasMeasurement = roomHasMeasurements(areaId);

    wrapper.classList.toggle("selected", isSelected);
    wrapper.classList.toggle("has-measurement", hasMeasurement);
    wrapper.classList.toggle("needs-measurement", isSelected && !hasMeasurement);
  });

  // Unmeasured warning
  var unmeasured = selectedAreas.filter(function(a) { return !roomHasMeasurements(a.id); });
  var warningEl = document.getElementById("unmeasured-warning");
  var warningTextEl = document.getElementById("unmeasured-warning-text");

  if (warningEl) {
    if (unmeasured.length > 0) {
      warningEl.style.display = "flex";
      if (warningTextEl) {
        warningTextEl.textContent = unmeasured.length + " room"
          + (unmeasured.length > 1 ? "s" : "") + " need"
          + (unmeasured.length > 1 ? "" : "s") + " measurements";
      }
    } else {
      warningEl.style.display = "none";
    }
  }
}

/** Render the selected areas as chips below the pill grid. */
function renderSelectedAreas() {
  var container = document.getElementById("selected-areas-list");
  if (!container) return;

  if (selectedAreas.length === 0) {
    container.innerHTML = '<span class="selected-areas-empty">No rooms selected yet</span>';
    return;
  }

  var html = "";
  selectedAreas.forEach(function(area) {
    var m = roomMeasurements[area.id];
    var hasMeasurement = roomHasMeasurements(area.id);

    var chipClass = "selected-area-chip";
    if (!hasMeasurement) chipClass += " needs-measure";

    html += '<div class="' + chipClass + '" data-area-id="' + area.id + '">';

    // Display label with closet info
    var displayLabel = area.label;
    if (area.closetLabel) displayLabel += " * " + area.closetLabel;
    html += '<span>' + escHtml(displayLabel) + '</span>';

    // Measurement badges
    if (hasMeasurement) {
      var displaySF = (m.totalSF || 0)
        + (m.stairsCalc && m.stairsCalc.squareFeet ? m.stairsCalc.squareFeet : 0);
      html += '<span class="sf-badge">' + Math.round(displaySF) + ' SF</span>';

      if (isCarpetMode && m.carpetCalc && m.carpetCalc.squareYards > 0) {
        html += '<span class="sy-badge">' + m.carpetCalc.squareYards.toFixed(1) + ' SY</span>';
      }
      if (m.notes) {
        html += '<span class="notes-badge" title="' + escHtml(m.notes) + '">&#128221;</span>';
      }
      if (m.photos && m.photos.length > 0) {
        html += '<span class="photos-badge">&#128247; ' + m.photos.length + '</span>';
      }
    }

    html += '<button type="button" class="selected-area-chip-measure">&#128207;</button>';
    html += '<button type="button" class="selected-area-chip-remove">&times;</button>';
    html += '</div>';
  });

  container.innerHTML = html;
  bindSelectedAreaChipEvents(container);
}

/**
 * Bind click events to selected area chip measure/remove buttons.
 * @param {HTMLElement} container
 */
function bindSelectedAreaChipEvents(container) {
  container.querySelectorAll(".selected-area-chip").forEach(function(chip) {
    var areaId = chip.dataset.areaId;
    var area = selectedAreas.find(function(a) { return a.id === areaId; });
    var measureBtn = chip.querySelector(".selected-area-chip-measure");
    var removeBtn = chip.querySelector(".selected-area-chip-remove");

    if (measureBtn) {
      measureBtn.addEventListener("click", function(e) {
        e.preventDefault();
        e.stopPropagation();
        openMeasureModal(areaId, area ? area.label : areaId);
      });
    }

    if (removeBtn) {
      removeBtn.addEventListener("click", function(e) {
        e.preventDefault();
        e.stopPropagation();
        var idx = selectedAreas.findIndex(function(a) { return a.id === areaId; });
        if (idx >= 0) {
          selectedAreas.splice(idx, 1);
          delete roomMeasurements[areaId];
          updatePillStates();
          renderSelectedAreas();
          updateMeasureSummary();
        }
      });
    }
  });
}


/* =============================================================================
 * 16. EVENT BINDING & INITIALIZATION
 * =============================================================================
 * Application entry point. Loads data and binds all top-level event listeners.
 * ========================================================================== */

/**
 * Main initialization function. Called once on DOMContentLoaded.
 * Loads project context, resources, and assemblies, then sets up all UI.
 */
async function init() {
  projectId = getParam("projectRid") || getParam("rid") || getParam("projectId") || "";
  
  // &#8213;&#8213;&#8213; Load reference data &#8213;&#8213;&#8213;
 
  // -- Load reference data -----------------------------------------------
  await loadCtx();
  await loadResources();
  allAssemblies = await loadAsm();

  // -- Populate assembly dropdown ----------------------------------------
  populateAssemblyDropdown();

  // -- Render initial UI -------------------------------------------------
  renderAreaGroups();
  renderSelectedAreas();
  updateProg();

  // -- Bind event listeners ----------------------------------------------
  bindSearchEvents();
  bindResourceFilterEvents();
  bindCarpetParameterEvents();
  bindAreaManagementEvents();
  bindAssemblySelectionEvents();
  bindGridActionEvents();
  bindNavigationEvents();
  bindMeasureModalEvents();
  bindDemoKeywordEvents();
  bindMoldingEvents();
  bindFixtureCounterEvents();
  bindPhotoEvents();
  bindDirectionPillEvents();
}

// -- Initialization Helpers --------------------------------------------------

/** Populate the assembly dropdown with optgroups by category. */
function populateAssemblyDropdown() {
  var assemblySelect = document.getElementById("assembly-select");
  if (!assemblySelect || allAssemblies.length === 0) return;

  var categories = {};
  allAssemblies.forEach(function(a) {
    var cat = a.category || "Uncategorized";
    if (!categories[cat]) categories[cat] = [];
    categories[cat].push(a);
  });

  var html = '<option value="">-- Choose assembly --</option>';
  Object.keys(categories).sort().forEach(function(cat) {
    html += '<optgroup label="' + escHtml(cat) + '">';
    categories[cat].forEach(function(a) {
      html += '<option value="' + a.id + '">' + escHtml(a.config) + '</option>';
    });
    html += '</optgroup>';
  });

  assemblySelect.innerHTML = html;
}

// -- Event Binding Functions -------------------------------------------------
// These are broken into small, focused functions for maintainability.

/** Bind product search input and click-outside-to-close events. */
function bindSearchEvents() {
  var primarySearch = document.getElementById("primary-search");
  if (primarySearch) {
    primarySearch.addEventListener("input", function() {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(function() { handleSearch(primarySearch.value.trim()); }, SEARCH_DEBOUNCE_MS);
    });
    primarySearch.addEventListener("focus", function() {
      if (primarySearch.value.trim().length >= SEARCH_MIN_CHARS) {
        handleSearch(primarySearch.value.trim());
      }
    });
  }

  // Close search results when clicking outside
  document.addEventListener("click", function(e) {
    var resultsEl = document.getElementById("primary-results");
    var searchContainer = document.querySelector(".search-container");
    if (resultsEl && searchContainer && !searchContainer.contains(e.target)) {
      resultsEl.classList.remove("show");
    }
  });

  var primaryClear = document.getElementById("primary-clear");
  if (primaryClear) primaryClear.addEventListener("click", clearPrimaryItem);
}

/** Bind resource filter modal open/close/apply/clear events. */
function bindResourceFilterEvents() {
  var bind = function(id, handler) {
    var el = document.getElementById(id);
    if (el) el.addEventListener("click", handler);
  };

  bind("filter-btn", openResourceModal);
  bind("resource-modal-close", closeResourceModal);
  bind("resource-apply-btn", applyResourceFilter);
  bind("resource-clear-btn", clearResourceFilter);
  bind("clear-filter-btn", clearResourceFilter);

  var resourceSearchInput = document.getElementById("resource-search-input");
  if (resourceSearchInput) {
    resourceSearchInput.addEventListener("input", function() {
      renderResourceList(resourceSearchInput.value.trim());
    });
  }
}

/** Bind carpet width and pattern match input events. */
function bindCarpetParameterEvents() {
  var carpetWidthFtInput = document.getElementById("carpet-width-ft-input");
  var carpetWidthInInput = document.getElementById("carpet-width-in-input");
  
  function updateCarpetWidthFromInputs() {
    var ft = toNum(carpetWidthFtInput ? carpetWidthFtInput.value : 12);
    var inches = toNum(carpetWidthInInput ? carpetWidthInInput.value : 0);
    carpetWidth = ft + (inches / 12);
    if (carpetWidth <= 0) carpetWidth = DEFAULT_CARPET_WIDTH_FT;
  }
  
  if (carpetWidthFtInput) {
    carpetWidthFtInput.addEventListener("input", updateCarpetWidthFromInputs);
  }
  if (carpetWidthInInput) {
    carpetWidthInInput.addEventListener("input", updateCarpetWidthFromInputs);
  }

  var pmLengthInput = document.getElementById("carpet-pm-length-input");
  if (pmLengthInput) {
    pmLengthInput.addEventListener("input", function() {
      patternMatchLength = toNum(pmLengthInput.value) || 0;
    });
  }

  var seamInput = document.getElementById("carpet-seam-allowance-input");
  if (seamInput) {
    seamInput.addEventListener("input", function() {
      SEAM_ALLOWANCE_IN = toNum(seamInput.value);
      if (SEAM_ALLOWANCE_IN < 0) SEAM_ALLOWANCE_IN = 0;
    });
  }
}

/** Bind custom area input and clear areas button. */
function bindAreaManagementEvents() {
  var addCustomBtn = document.getElementById("add-custom-btn");
  var customAreaInput = document.getElementById("custom-area-input");
  if (addCustomBtn && customAreaInput) {
    addCustomBtn.addEventListener("click", function() {
      var name = customAreaInput.value.trim();
      if (name) {
        addAreaToSelection("custom_" + Date.now(), name);
        customAreaInput.value = "";
        updatePillStates();
        renderSelectedAreas();
        updateMeasureSummary();
      }
    });
  }

  var clearAreasBtn = document.getElementById("clear-areas-btn");
  if (clearAreasBtn) {
    clearAreasBtn.addEventListener("click", function() {
      selectedAreas = [];
      roomMeasurements = {};
      updatePillStates();
      renderSelectedAreas();
      updateMeasureSummary();
      hideCarpetDiagram();
    });
  }

  // Carpet diagram buttons
  var optimizeBtn = document.getElementById("btn-optimize-cuts");
  if (optimizeBtn) {
    optimizeBtn.addEventListener("click", function() {
      recalculateCarpetPlan();
    });
  }

  var dirLengthBtn = document.getElementById("btn-direction-length");
  var dirWidthBtn = document.getElementById("btn-direction-width");
  
  if (dirLengthBtn) {
    dirLengthBtn.addEventListener("click", function() {
      dirLengthBtn.classList.add("active");
      if (dirWidthBtn) dirWidthBtn.classList.remove("active");
      recalculateCarpetPlan("lengthwise");
    });
  }
  
  if (dirWidthBtn) {
    dirWidthBtn.addEventListener("click", function() {
      dirWidthBtn.classList.add("active");
      if (dirLengthBtn) dirLengthBtn.classList.remove("active");
      recalculateCarpetPlan("widthwise");
    });
  }
}

/** Show carpet diagram section and calculate initial plan. */
function showCarpetDiagram() {
  var section = document.getElementById("carpet-diagram-section");
  if (section && isCarpetMode) {
    section.style.display = "block";
    recalculateCarpetPlan();
  }
}

/** Hide carpet diagram section. */
function hideCarpetDiagram() {
  var section = document.getElementById("carpet-diagram-section");
  if (section) section.style.display = "none";
}

/** Bind assembly dropdown change event. */
function bindAssemblySelectionEvents() {
  var assemblySelectEl = document.getElementById("assembly-select");
  if (!assemblySelectEl) return;

  assemblySelectEl.addEventListener("change", async function() {
    var aid = assemblySelectEl.value;
    if (aid) {
      assemblySelectEl.classList.add("has-selection");
      showLoad("Loading assembly...");
      try {
        assemblyGroupItems = await loadAsmRows(aid);
        await renderAssemblyGrid();
      } catch (err) {
        toast("Error loading assembly: " + err.message, "error");
      }
      hideLoad();
    } else {
      assemblySelectEl.classList.remove("has-selection");
      assemblyGroupItems = [];
      var gridContainer = document.getElementById("grid-container");
      if (gridContainer) gridContainer.innerHTML = '<div class="empty-state">Select an assembly to see items</div>';
    }
  });
}

/** Bind grid quick action buttons (defaults, select all, clear all). */
function bindGridActionEvents() {
  var bind = function(id, handler) {
    var el = document.getElementById(id);
    if (el) el.addEventListener("click", handler);
  };

  bind("btn-use-defaults", useDefaults);
  bind("btn-select-all", selectAll);
  bind("btn-clear-all", clearAll);
}

/** Bind wizard navigation buttons (next, back, close). */
function bindNavigationEvents() {
  var bind = function(id, handler) {
    var el = document.getElementById(id);
    if (el) el.addEventListener("click", handler);
  };

  bind("btn-next", nextStep);
  bind("btn-back", prevStep);

  var btnClose = document.getElementById("btn-close");
  if (btnClose) {
    btnClose.addEventListener("click", function() {
      if (confirm("Close without saving?")) {
        if (projectId) {
          window.location.href = "/db/" + DBID_PROJECTS + "?a=dr&rid=" + projectId;
        } else if (window.opener) {
          window.close();
          window.opener.focus();
        } else {
          window.history.back();
        }
      }
    });
  }
}

/** Bind measurement modal open/close/save events and sub-controls. */
function bindMeasureModalEvents() {
  var bind = function(id, handler) {
    var el = document.getElementById(id);
    if (el) el.addEventListener("click", handler);
  };

  bind("measure-modal-close", closeMeasureModal);
  bind("measure-cancel-btn", closeMeasureModal);
  bind("measure-save-btn", saveMeasurements);
  bind("add-dimension-btn", addDimensionRow);
  bind("add-stair-btn", addStairEntry);
  bind("add-landing-btn", addLandingEntry);
  bindStairDemoEvents();
  // Door marker button  opens wall picker
  bind("door-add-btn", function() {
    var btn = document.getElementById("door-add-btn");
    var windowBtn = document.getElementById("window-add-btn");
    if (wallPickerTarget === "door") { closeWallPicker(); }
    else { if (windowBtn) windowBtn.classList.remove("active"); if (btn) btn.classList.add("active"); openWallPicker("door"); }
  });
  // Window marker button  opens wall picker
  bind("window-add-btn", function() {
    var btn = document.getElementById("window-add-btn");
    var doorBtn = document.getElementById("door-add-btn");
    if (wallPickerTarget === "window") { closeWallPicker(); }
    else { if (doorBtn) doorBtn.classList.remove("active"); if (btn) btn.classList.add("active"); openWallPicker("window"); }
  });
  // Wall picker: wall selection buttons
  document.querySelectorAll(".wall-picker-btn").forEach(function(btn) {
    btn.addEventListener("click", function() { onWallSelected(btn.dataset.wall); });
  });
  // Wall picker: confirm placement
  bind("wall-dist-confirm", function() { confirmWallPlacement(); });
  bind("seam-select-btn", function() { deselectMarker(); });
  // Wall picker: Enter key on distance input
  var wallDistInput = document.getElementById("wall-dist-input");
  if (wallDistInput) { wallDistInput.addEventListener("keydown", function(e) { if (e.key === "Enter") { e.preventDefault(); confirmWallPlacement(); } }); }
  var markerPosInput = document.getElementById("marker-position-input");
  if (markerPosInput) { markerPosInput.addEventListener("keydown", function(e) { if (e.key === "Enter") { e.preventDefault(); markerPosInput.blur(); } }); }  
  // Carpet direction buttons
  document.querySelectorAll(".carpet-direction-btn").forEach(function(btn) {
    btn.addEventListener("click", function() {
      document.querySelectorAll(".carpet-direction-btn").forEach(function(b) { b.classList.remove("selected"); });
      btn.classList.add("selected");
      currentCarpetDirection = btn.dataset.direction;
      seamOffset = 0;
      updateCarpetCalcPreview();
      updateStairsCalc();
      renderRoomDiagram();
    });
  });
}

/** Bind stair demo type buttons. */
function bindStairDemoEvents() {
  document.querySelectorAll(".stair-demo-btn").forEach(function(btn) {
    btn.addEventListener("click", function() {
      var wasSelected = btn.classList.contains("selected");
      
      // Deselect all stair demo buttons
      document.querySelectorAll(".stair-demo-btn").forEach(function(b) { 
        b.classList.remove("selected"); 
      });
      
      // Toggle the clicked one
      if (!wasSelected) {
        btn.classList.add("selected");
        currentStairDemoType = btn.dataset.stairDemo;
      } else {
        currentStairDemoType = "none";
      }
    });
  });
}

/** Bind demo type keyword toggle buttons. */
function bindDemoKeywordEvents() {
  document.querySelectorAll(".demo-keyword").forEach(function(btn) {
    btn.addEventListener("click", function() {
      var demoKeywords = document.getElementById("demo-keywords");
      var wasSelected = btn.classList.contains("selected");
      // Deselect all, then toggle the clicked one
      demoKeywords.querySelectorAll(".demo-keyword").forEach(function(b) { b.classList.remove("selected"); });
      if (!wasSelected) {
        btn.classList.add("selected");
        demoKeywords.classList.add("has-selection");
      } else {
        demoKeywords.classList.remove("has-selection");
      }
      
      // Update stair demo prompt visibility when room demo changes
      updateStairDemoPrompt();

      // If stairs have a count, scroll to stair demo prompt
      if (!wasSelected) {
        var hasStairs = currentStairEntries.some(function(e) { return toNum(e.count) > 0; });
        if (hasStairs) {
          var stairDemoPrompt = document.getElementById("stair-demo-prompt");
          if (stairDemoPrompt && stairDemoPrompt.style.display !== "none") {
            setTimeout(function() {
              stairDemoPrompt.scrollIntoView({ behavior: "smooth", block: "center" });
            }, 200);
          }
        }
      }
    });
  });
}

/** Bind molding increment/decrement buttons. */
function bindMoldingEvents() {
  document.querySelectorAll(".molding-btn").forEach(function(btn) {
    btn.addEventListener("click", function() {
      var item = btn.closest(".molding-item");
      var valueEl = item.querySelector(".molding-value");
      var val = toNum(valueEl.textContent);

      val = btn.classList.contains("minus")
        ? Math.max(0, val - MOLDING_STEP)
        : val + MOLDING_STEP;

      valueEl.textContent = val % 1 === 0 ? val : val.toFixed(1);
      item.classList.toggle("has-value", val > 0);
    });
  });
}

/** Bind fixture counter increment/decrement buttons. */
function bindFixtureCounterEvents() {
  document.querySelectorAll(".counter-btn").forEach(function(btn) {
    btn.addEventListener("click", function() {
      var row = btn.closest(".counter-row");
      var valueEl = row.querySelector(".counter-value");
      var val = toNum(valueEl.textContent);

      val = btn.classList.contains("minus") ? Math.max(0, val - 1) : val + 1;
      valueEl.textContent = val;
      row.classList.toggle("has-value", val > 0);
    });
  });
}

/** Bind photo capture button and file input. */
function bindPhotoEvents() {
  var captureBtn = document.getElementById("photo-capture-btn");
  var photoInput = document.getElementById("photo-input");

  if (captureBtn && photoInput) {
    captureBtn.addEventListener("click", function() {
      if (currentRoomPhotos.length < MAX_PHOTOS_PER_ROOM) photoInput.click();
    });

    photoInput.addEventListener("change", function(e) {
      var files = e.target.files;
      if (!files || files.length === 0) return;

      Array.from(files).forEach(function(file) {
        if (currentRoomPhotos.length >= MAX_PHOTOS_PER_ROOM) return;
        var reader = new FileReader();
        reader.onload = function(ev) {
          currentRoomPhotos.push({ data: ev.target.result, name: file.name });
          renderPhotoThumbnails();
        };
        reader.readAsDataURL(file);
      });
      photoInput.value = "";
    });
  }
}

/** Bind direction pill buttons for quick work comment insertion. */
function bindDirectionPillEvents() {
var lastEditedComment = null;
    var custCommentEl = document.getElementById("cust-comment");
    var workCommentEl = document.getElementById("work-comment");
    if (custCommentEl) {
      custCommentEl.addEventListener("input", function() { lastEditedComment = "cust"; });
    }
    if (workCommentEl) {
      workCommentEl.addEventListener("input", function() { lastEditedComment = "work"; });
    }
    var syncBtn = document.getElementById("sync-comments-btn");
    if (syncBtn) {
      syncBtn.addEventListener("click", function() {
        var cust = document.getElementById("cust-comment");
        var work = document.getElementById("work-comment");
        if (!cust || !work) return;
        if (lastEditedComment === "cust" && cust.value.trim()) {
          work.value = cust.value;
          toast("Customer comment copied to Work comment", "success");
        } else if (lastEditedComment === "work" && work.value.trim()) {
          cust.value = work.value;
          toast("Work comment copied to Customer comment", "success");
        } else if (cust.value.trim()) {
          work.value = cust.value;
          toast("Customer comment copied to Work comment", "success");
        } else if (work.value.trim()) {
          cust.value = work.value;
          toast("Work comment copied to Customer comment", "success");
        } else {
          toast("No comments to sync", "error");
        }
      });
    }
  document.querySelectorAll(".direction-pill:not(#sync-comments-btn)").forEach(function(pill) {
    pill.addEventListener("click", function() {
      var comment = pill.dataset.comment;
      var workCommentEl = document.getElementById("work-comment");
      if (workCommentEl) {
        var current = workCommentEl.value.trim();
        workCommentEl.value = current ? current + "\n" + comment : comment;
      }
    });
  });
}

// -- Application Entry Point -------------------------------------------------
document.addEventListener("DOMContentLoaded", init);

</script>
</body>
</html>
